<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寒暄</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xuyk.top/"/>
  <updated>2021-02-22T08:40:29.043Z</updated>
  <id>http://xuyk.top/</id>
  
  <author>
    <name>Xuyk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络灵魂拷问系列之谈一下TCP/IP四层模型与OSI七层模型可以吗</title>
    <link href="http://xuyk.top/posts/interview-net-model.html"/>
    <id>http://xuyk.top/posts/interview-net-model.html</id>
    <published>2021-02-22T08:40:00.000Z</published>
    <updated>2021-02-22T08:40:29.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络灵魂拷问系列之谈一下TCP-IP四层模型与OSI七层模型可以吗"><a href="#计算机网络灵魂拷问系列之谈一下TCP-IP四层模型与OSI七层模型可以吗" class="headerlink" title="计算机网络灵魂拷问系列之谈一下TCP/IP四层模型与OSI七层模型可以吗"></a>计算机网络灵魂拷问系列之谈一下TCP/IP四层模型与OSI七层模型可以吗</h1><h2 id="0-网络通信协议的意义"><a href="#0-网络通信协议的意义" class="headerlink" title="0.网络通信协议的意义"></a>0.网络通信协议的意义</h2><p>各个电脑厂商，比如联想、苹果、华硕之类的，每个品牌的电脑之间的通信，如果通信协议不同，那么就只能品牌电脑内通信，这是不可取的。所以搞了一个国际通行的协议，大家都按照协议来，使得所有电脑都可以互相通信</p><p>OSI七层网络模型：<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-osi.png" alt=""></p><ol><li><strong>物理层</strong>：以前电脑都是通过网线来联网，传输0和1的信号。属于物理上的连接</li><li><strong>数据链路层</strong>：电脑接收到0101010001这样的电路信号怎么识别和分组，从哪个电脑传输到哪个电脑。数据链路层来解决。以太网协议就是这一层来的，以太网规定每个电脑都有一个网卡，电路信号一般从电脑1网卡传输到电脑2网卡。电脑出厂时都有一个唯一的mac地址（12个16进制，前6产商编号，后6流水号，win10中ipconfig /all可查询mac物理地址）。一组电信号就是一帧，每帧分为标头和数据，标头包含了一些发送者、接收者和数据类型之类的信息。发送者会把数据通过广播发送给所有局域网里的电脑，每个电脑网卡通过比对接收者mac地址来判断是否是发送给自己</li><li><strong>网络层</strong>：数据链路层发送方通过广播发送给局域网内所有的电脑，那么他是如何判别哪些电脑是处于同一个局域网内的呢？通过网络层判别。ip协议，一般通过4个十进制数字表示，范围从0.0.0.0到255.255.255.255。每台计算机都分配一个ip地址，各自对子网掩码（一般是255.255.255.0）做二进制与运算，得到前三段（192.168.1）一致则为同一局域网。跨局域网通信：请求头填写接收方ip和路由器mac地址，经过交换机发送给路由器/网关，路由器/网关转换成目标mac地址，而后正确发送给对方电脑。ARP：局域网内个台电脑都把自己的ip地址和对应的mac地址广播给其他电脑，最后每台电脑都会知道其他电脑的地址了。【关键】网络层最关键的就是提供了ip协议，电脑A和电脑B通信，如果两者在一个局域网，则只需要在请求头填写接收方mac地址即可通信；如果不在，在请求头填写接收方ip地址和路由器的mac地址进行通信</li><li><strong>传输层</strong>：电脑上很多应用都从网卡发送和接收数据，该如何辨别是给哪个应用的呢？传输层引入了端口的概念，例如qq监听20386端口，数据包解析到发送到20386端口，就说明是给qq的。关联端口号的就是tcp协议和udp协议（udp不可靠，只管发送数据不管对方是否接收），规定了端对端的规则，例如怎么建立连接、怎么发送和读取数据。socket基于tcp协议封装，我们可以基于socket进行网络编程（ip地址+端口号）</li><li><strong>应用层</strong>：当收到基于tcp协议发送过来的数据包后，如何将数据包进行对应解析？数据包可能用于发送邮件（STMP协议）、发送HTTP请求，用了什么格式进行封装</li></ol><blockquote><p>例如我们使用java中的nio来搭建rpc通信框架，底层过程还是走了：传输层的tcp协议、网络层的ip协议、数据链路层的以太网协议和物理层的网线传递着0101的信号 </p></blockquote><p>TCP/IP四层模型常用协议：<br>数据链路层（以太网协议）、网络层（ip协议）、传输层（tcp协议）、应用层（HTTP协议）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络灵魂拷问系列之谈一下TCP-IP四层模型与OSI七层模型可以吗&quot;&gt;&lt;a href=&quot;#计算机网络灵魂拷问系列之谈一下TCP-IP四层模型与OSI七层模型可以吗&quot; class=&quot;headerlink&quot; title=&quot;计算机网络灵魂拷问系列之谈一下TCP/I
      
    
    </summary>
    
    
      <category term="计算机网络灵魂拷问系列" scheme="http://xuyk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="计算机网络模型" scheme="http://xuyk.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL灵魂拷问系列之MySQL如何优化</title>
    <link href="http://xuyk.top/posts/interview-MySQL-optimization.html"/>
    <id>http://xuyk.top/posts/interview-MySQL-optimization.html</id>
    <published>2021-02-20T09:52:00.000Z</published>
    <updated>2021-02-22T08:41:50.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问系列之MySQL如何优化"><a href="#MySQL灵魂拷问系列之MySQL如何优化" class="headerlink" title="MySQL灵魂拷问系列之MySQL如何优化"></a>MySQL灵魂拷问系列之MySQL如何优化</h1><h2 id="1-SQL语句日常优化"><a href="#1-SQL语句日常优化" class="headerlink" title="1. SQL语句日常优化"></a>1. SQL语句日常优化</h2><ol><li>通过skywalking发现慢sql、或者mysql中的慢查询日志（开启慢查询日志）</li><li>使用 <strong>explain</strong> 关键字查看sql执行计划</li><li>type一般控制在 <strong>ref</strong> 甚至更好的话，sql性能应该都不错</li><li><strong>key_len</strong>：表示索引的长度，越小越好</li><li><strong>rows</strong>：扫描行数，很重要，最少越好</li><li><strong>extra</strong>：当查询包含 <strong>using filesort</strong> 文件排序和 <strong>using temporary</strong>临时表（使用order/group by很容易出现），这样的sql必须优化</li></ol><h2 id="2-表结构优化"><a href="#2-表结构优化" class="headerlink" title="2. 表结构优化"></a>2. 表结构优化</h2><p><strong>在遵循三大范式的基础上，可以为了业务增加一定的冗余字段</strong></p><blockquote><p>个人笔记：<a href="http://note.youdao.com/s/LoTjHgzV">表结构设计优化</a></p></blockquote><h2 id="2-join优化"><a href="#2-join优化" class="headerlink" title="2. join优化"></a>2. join优化</h2><p><strong>（1）灵活使用左连接、右连接等</strong></p><ul><li><strong>left join</strong>：A表的全部数据，即使B表不包含A表的关系数据</li><li><strong>right join</strong>：B表的全部数据，即使B表不包含A表的关系数据</li><li><strong>inner join</strong>：A表和B表的交集</li><li><strong>full outer join</strong>：A表和B表并集</li><li><strong>cross join</strong>：笛卡尔连接，把A表的数据和B表的数据任意连接，结果行数 = A表行数 *B表行数；如果cross join带有on语句把两表的外键相连，则作用等于inner join</li></ul><p><strong>（2）使用join时，用数据量比较小的作为驱动表，用小表驱动大表，where条件尽量走索引，参与join的表不能超过3张</strong></p><blockquote><p>个人join优化笔记：<a href="http://note.youdao.com/s/CqwXTRyN">join优化</a></p></blockquote><h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><ol><li>遵循 <strong>最左前缀原则</strong></li><li>编写sql时避免 <strong>隐式转换</strong></li><li>必要时建议使用 <strong>组合索引、覆盖索引</strong></li></ol><blockquote><p>【个人索引优化笔记】<br>1：<a href="http://note.youdao.com/s/CVUXjziS">常见索引失效场景与解决方案</a><br>2：<a href="http://note.youdao.com/s/PBoh23ho">索引优化</a></p></blockquote><h2 id="4-limit优化"><a href="#4-limit优化" class="headerlink" title="4. limit优化"></a>4. limit优化</h2><ol><li>使用 <strong>覆盖索引 + join</strong>优化offset特别大的场景</li><li>模仿淘宝或者百度，对页面做限制（100页）</li></ol><blockquote><p>个人limit优化笔记：<a href="http://note.youdao.com/s/Fh5SAlZ1">limit优化</a></p></blockquote><h2 id="5-个人小结笔记"><a href="#5-个人小结笔记" class="headerlink" title="5. 个人小结笔记"></a>5. 个人小结笔记</h2><p>（1）表结构设计方面：首先需要遵循三大范式，字段不能再分割，非主键属性 <a href="https://zhuanlan.zhihu.com/p/259788257">https://zhuanlan.zhihu.com/p/259788257</a><br>a.字段不能再分割，比如只有一个地址字段，到时候如果按照省统计时就会非常头疼<br>b.每行记录要有唯一标识。比如学号、姓名、课程、课程分数，这一条记录就包含了学生、课程信息，主键无法保证唯一性，两个应该分开<br>c.不能存在冗余。比如学号、姓名、学院、学院电话。这里学院电话每行都有，肯定会存在冗余的情况。应该分开<br>d.适当加一些冗余字段，比如订单表记录商品金额，为的是保存当时商品信息快照，因为不同时期的商品价格可能发生变化</p><p>（2）表字段设计方面：字段尽量不允许为null，字段选择最适合的，比如性别、订单状态这样的字段可以使用tinyint，使用varchar可变的<br>字符串代替char等</p><p>（3）sql优化：通过skywalking或者mysql慢查询日志查询慢sql，通过explain关键字查询他的执行计划，保证type控制在ref，rows扫描行数<br>越少越好，extra列不出现临时表和文件排序；<br>a.join优化：遵循数据量小的表来驱动大表，where的条件尽量走索引，参与join的表最好不超过3张<br>b.索引优化：遵循最左前缀原则，避免隐式转换，否则可能造成索引失效。建议使用复合索引<br>c.limit优化：如果进行深度分页的话，比如10000，10，mysql的具体操作是查找10010条数据，然后丢弃前10000条，取后10条，性能很低。<br>这种情况，如果主键的自增类型，则直接可以让id&gt;10000，limit 10即可。如果不是自增类型，就根据主键索引查询到分页信息的主键，再<br>根据主键查询数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL灵魂拷问系列之MySQL如何优化&quot;&gt;&lt;a href=&quot;#MySQL灵魂拷问系列之MySQL如何优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL灵魂拷问系列之MySQL如何优化&quot;&gt;&lt;/a&gt;MySQL灵魂拷问系列之MySQL如何优化&lt;/
      
    
    </summary>
    
    
      <category term="MySQL灵魂拷问系列" scheme="http://xuyk.top/categories/MySQL%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MySQL" scheme="http://xuyk.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL灵魂拷问之数据库事务说说吧</title>
    <link href="http://xuyk.top/posts/interview-MySQL-transaction.html"/>
    <id>http://xuyk.top/posts/interview-MySQL-transaction.html</id>
    <published>2021-02-18T12:16:00.000Z</published>
    <updated>2021-02-22T08:42:02.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问之数据库事务说说吧"><a href="#MySQL灵魂拷问之数据库事务说说吧" class="headerlink" title="MySQL灵魂拷问之数据库事务说说吧"></a>MySQL灵魂拷问之数据库事务说说吧</h1><h2 id="1-事务的四大特性是什么-ACID"><a href="#1-事务的四大特性是什么-ACID" class="headerlink" title="1. 事务的四大特性是什么-ACID"></a>1. 事务的四大特性是什么-ACID</h2><ul><li><strong>原子性</strong>：一个事务作为一个整体，要么一起成功要么一起失败</li><li><strong>一致性</strong>：说的是数据一致性。事务执行前后，数据的执行是对的，不能存在某操作未执行的情况</li><li><strong>隔离性</strong>：各个事务之间互不干扰</li><li><strong>持久性</strong>：事务执行成功，对数据的操作是永久有效的</li></ul><h2 id="2-事务的隔离级别有哪些"><a href="#2-事务的隔离级别有哪些" class="headerlink" title="2. 事务的隔离级别有哪些"></a>2. 事务的隔离级别有哪些</h2><p>MySQL默认事务隔离级别：<strong>可重复读</strong></p><p>隔离级别依次是：读未提交、读已提交、可重复读、串行化，对应的性能从左到右依次递减</p><h3 id="2-1-事务隔离级别-读未提交"><a href="#2-1-事务隔离级别-读未提交" class="headerlink" title="2.1 事务隔离级别-读未提交"></a>2.1 事务隔离级别-读未提交</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-ReadUncommit.png" alt=""></p><p>读未提交：事务A可以查看到事务B修改的数据（事务B还未提交），也就是存在 <strong>脏读</strong> 的问题</p><h3 id="2-2-事务隔离级别-读已提交-不可重复读"><a href="#2-2-事务隔离级别-读已提交-不可重复读" class="headerlink" title="2.2 事务隔离级别-读已提交/不可重复读"></a>2.2 事务隔离级别-读已提交/不可重复读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-ReadCommitted.png" alt=""></p><p>存在 <strong>不可重复读</strong> 的问题</p><h3 id="2-3-事务隔离级别-可重复读"><a href="#2-3-事务隔离级别-可重复读" class="headerlink" title="2.3 事务隔离级别-可重复读"></a>2.3 事务隔离级别-可重复读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-RepeatableRead.png" alt=""></p><p>保证事务在运行期间，同一行数据是不会变更的</p><h3 id="2-4-可重复读的问题-幻读"><a href="#2-4-可重复读的问题-幻读" class="headerlink" title="2.4 可重复读的问题-幻读"></a>2.4 可重复读的问题-幻读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-IllusoryRead.png" alt=""></p><h3 id="2-5-事务隔离级别-串行化"><a href="#2-5-事务隔离级别-串行化" class="headerlink" title="2.5 事务隔离级别-串行化"></a>2.5 事务隔离级别-串行化</h3><p>MySQL事务隔离级别-串行化可以解决幻读的问题</p><p>事务A执行期间，事务B不允许执行，只能阻塞等待事务A执行完毕接着执行事务B</p><h2 id="3-MySQL是如何实现可重复读的（MVVC机制）？"><a href="#3-MySQL是如何实现可重复读的（MVVC机制）？" class="headerlink" title="3. MySQL是如何实现可重复读的（MVVC机制）？"></a>3. MySQL是如何实现可重复读的（MVVC机制）？</h2><p>使用 <strong>MVVC机制</strong>，也就是 <strong>多版本并发控制</strong>（Multi-Version Concurrency Control） 实现的可重复读</p><p>innodb对每一行都会追加两个隐藏列：<strong>创建这一行的事务id</strong>、<strong>删除这一行的事务id</strong>（事务id在MySQL中是 <strong>全局唯一并且递增</strong> 的）</p><p>核心规则： <strong>创建事务id &lt;= 当前事务id &lt; 删除事务id</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-mvvc-demo-one.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-mvvc-demo-two.png" alt=""></p><blockquote><p>并发场景下，多个事务对同一行进行修改，同一行就会存在多个版本<br>各个事务会对于这一行有一条创建事务id为自己id的快照</p></blockquote><blockquote><p>【参考链接】<br>1： <a href="https://mp.weixin.qq.com/s/XOBhxc_AiuUxvwBsB_JprQ">一文彻底读懂 MySQL 事务的四大隔离级别</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL灵魂拷问之数据库事务说说吧&quot;&gt;&lt;a href=&quot;#MySQL灵魂拷问之数据库事务说说吧&quot; class=&quot;headerlink&quot; title=&quot;MySQL灵魂拷问之数据库事务说说吧&quot;&gt;&lt;/a&gt;MySQL灵魂拷问之数据库事务说说吧&lt;/h1&gt;&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="MySQL灵魂拷问系列" scheme="http://xuyk.top/categories/MySQL%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MySQL" scheme="http://xuyk.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL灵魂拷问系列之MySQL基础拷问</title>
    <link href="http://xuyk.top/posts/interview-MySQL-common.html"/>
    <id>http://xuyk.top/posts/interview-MySQL-common.html</id>
    <published>2021-02-07T03:29:00.000Z</published>
    <updated>2021-02-22T08:41:25.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问系列之MySQL基础拷问"><a href="#MySQL灵魂拷问系列之MySQL基础拷问" class="headerlink" title="MySQL灵魂拷问系列之MySQL基础拷问"></a>MySQL灵魂拷问系列之MySQL基础拷问</h1><h2 id="1-MySQL有哪些存储引擎，有什么区别"><a href="#1-MySQL有哪些存储引擎，有什么区别" class="headerlink" title="1.MySQL有哪些存储引擎，有什么区别"></a>1.MySQL有哪些存储引擎，有什么区别</h2><p>mysql我们耳熟能详的就是两种存储引擎：<strong>Innodb、Myisam</strong></p><h3 id="1-1-Myisam"><a href="#1-1-Myisam" class="headerlink" title="1.1 Myisam"></a>1.1 Myisam</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-myisam.png" alt=""></p><ol><li><strong>不支持事务、外键</strong></li><li>从 <strong>物理存储角度</strong> 上看，Myisam属于 <strong>非聚簇索引</strong>，数据存在叶子结点（没有孩子的节点）上，叶子节点的data为数据的物理地址引用（索引文件和数据文件分开存储），，通过物理地址引用来找到具体的数据行。</li><li>适用于 <strong>少量插入、大量查询</strong> 的场景，以前做 <strong>大数据报表系统</strong> 的时候会用到，一次性大批量插入，接下来只是纯查询.不过现在基本已经不用myisam了（mysql扛不住，单表一般控制在500w）</li></ol><h3 id="1-2-Innodb"><a href="#1-2-Innodb" class="headerlink" title="1.2 Innodb"></a>1.2 Innodb</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-innodb.png" alt=""></p><ol><li>支持事务、外键</li><li>从 <strong>物理存储角度</strong> 上看，Innodb属于 <strong>聚簇索引</strong>，数据存在叶子结点（没有孩子的节点）上。如果是二级索引，则叶子结点存储的是主键，如果不止查询索引列，则需要再根据主键回表查询一次</li><li>目前来说，适用于大多数业务场景，无脑选即可</li></ol><blockquote><p>二级索引查找流程：先到二级索引的B+ Tree中根据name找到具体的叶子节点的data，data中存储的主键，根据主键再到聚簇索引（主键索引）中找到具体的数据行</p></blockquote><h3 id="1-3-Myisam和Innodb汇总比对图"><a href="#1-3-Myisam和Innodb汇总比对图" class="headerlink" title="1.3 Myisam和Innodb汇总比对图"></a>1.3 Myisam和Innodb汇总比对图</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-InnodbAndMyisam.png" alt=""></p><blockquote><p>Innodb二级索引叶子结点存储的是 <strong>索引和主键</strong>，需要查询到主键后，去主键索引查询数据</p></blockquote><h2 id="2-为什么MySQL的索引要使用B-树而不是其它树形结构-比如B树？"><a href="#2-为什么MySQL的索引要使用B-树而不是其它树形结构-比如B树？" class="headerlink" title="2.为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？"></a>2.为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？</h2><blockquote><p>具体细节参考：<br><a href="https://mp.weixin.qq.com/s/IZqjGK58mRUN4YFXO_QyHw">面试官：为什么MySQL的索引要使用B+树，而不是其它树？比如B树？</a></p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysq-b-tree.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-baddtree.png" alt=""></p><p>都属于多路搜索树</p><p>因为B树不管叶子节点还是非叶子节点，都会保存数据，如果要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低</p><p>而B+树只有在叶子节点存储数据，非叶子节点只保存索引值</p><p>数据库对B+ Tree还进行了优化，让每个叶子节点末尾有一个 <strong>next指针</strong> 指向下一个叶子节点的数据，使得在做范围查询的时候效率更高</p><h2 id="3-MySQL索引的使用规则"><a href="#3-MySQL索引的使用规则" class="headerlink" title="3.MySQL索引的使用规则"></a>3.MySQL索引的使用规则</h2><p>最左前缀匹配原则</p><p>假设表中只有A,B,C这三列的联合索引（A，B，C）</p><ol><li>全列匹配</li></ol><blockquote><p>select * from table where A = 1 and B = 2 and C = 3<br>说明：完美地走这个联合索引</p></blockquote><ol start="2"><li>最左前缀匹配</li></ol><blockquote><p>select * from table where A = 1 and B = 2<br>说明：走联合索引</p></blockquote><ol start="3"><li>最左匹配了，中间的值未匹配</li></ol><blockquote><p>select * from table where A = 1 and C = 3<br>说明：A走索引，C不走索引，会当作过滤条件，因为也走索引，所以在性能上也是可以接受的</p></blockquote><ol start="4"><li>未匹配最左匹配原则</li></ol><blockquote><p>select * from table where C = 3<br>说明：全表扫描，性能低，需要优化</p></blockquote><ol start="5"><li>前缀匹配</li></ol><blockquote><p>select * from table where A = 1 and B like “2%”<br>说明：like关键字 左边不能加 <strong>%</strong></p></blockquote><ol start="6"><li>范围/函数查询</li></ol><blockquote><p>select * from table where A &gt;= 0 and B = 2 and 函数（C） = 3<br>说明：A走索引，B不走索引，B作为筛选条件，C不走索引</p></blockquote><p><strong>索引的注意事项</strong></p><blockquote><p><a href="http://note.youdao.com/s/ZZP28HXU">理想设置索引和伪哈希技巧</a></p></blockquote><ol><li>单表索引数量不宜过多</li><li>类似于status、isValid这样的经常性重复的字段，创建索引意义不大</li><li>类似于网站这样前缀大致相同的字段，可以新建一个字段使用 <strong>crc32</strong> 函数对相同部分做hash，再对新字段创建索引</li></ol><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/ZxE8XDKUa8szJ6wRc-w-rA">InnoDB和MyISAM两者的对比</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL灵魂拷问系列之MySQL基础拷问&quot;&gt;&lt;a href=&quot;#MySQL灵魂拷问系列之MySQL基础拷问&quot; class=&quot;headerlink&quot; title=&quot;MySQL灵魂拷问系列之MySQL基础拷问&quot;&gt;&lt;/a&gt;MySQL灵魂拷问系列之MySQL基础拷问&lt;/
      
    
    </summary>
    
    
      <category term="MySQL灵魂拷问系列" scheme="http://xuyk.top/categories/MySQL%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MySQL" scheme="http://xuyk.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>线上出现问题了你有思路解决吗</title>
    <link href="http://xuyk.top/posts/interview-daily-prodProblem.html"/>
    <id>http://xuyk.top/posts/interview-daily-prodProblem.html</id>
    <published>2021-02-03T06:05:00.000Z</published>
    <updated>2021-02-03T06:06:33.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线上出现问题了你有思路解决吗"><a href="#线上出现问题了你有思路解决吗" class="headerlink" title="线上出现问题了你有思路解决吗"></a>线上出现问题了你有思路解决吗</h1><h2 id="1-线上服务器CPU使用率达到100-，如何排查、定位与解决呢"><a href="#1-线上服务器CPU使用率达到100-，如何排查、定位与解决呢" class="headerlink" title="1. 线上服务器CPU使用率达到100%，如何排查、定位与解决呢"></a>1. 线上服务器CPU使用率达到100%，如何排查、定位与解决呢</h2><p>面试官通过这个问题来试探面试者，有没有真实的玩过线上的机器</p><p><strong>导致CPU过高的一般原因</strong></p><ol><li>无线循环，例如递归调用等（可以整个sleep）</li><li>频繁GC（内存分配过快，导致区域很快就满了）</li><li>频繁创建新对象（可以考虑使用单例）</li><li>错误姿势的使用序列化和反序列化类库</li><li>正则表达式</li><li>线程上下文频繁切换</li></ol><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>top</strong> 到CPU占用最高的进程A <strong>pid1</strong></li><li>再使用 <strong>top -Hp</strong> 拿到指定进程占用最高的线程 <strong>pid2</strong></li><li>使用 <strong>printf %x pid2</strong> 将10进制线程号转换成16进制 <strong>8ccc</strong></li><li>通过 <strong>jstack pid1 &gt; dump.txt</strong> 获取进程A的堆栈快照</li><li>使用 <strong>cat dump.txt | grep -A 30 8ccc</strong> 根据16进制信息筛查出有问题的代码（往下展示30行）</li><li>排查代码中的问题并修复</li></ol><h2 id="2-线上机器的一个进程使用kill命令无法杀死怎么办？"><a href="#2-线上机器的一个进程使用kill命令无法杀死怎么办？" class="headerlink" title="2. 线上机器的一个进程使用kill命令无法杀死怎么办？"></a>2. 线上机器的一个进程使用kill命令无法杀死怎么办？</h2><p>kill进程如果死活杀不死，那么这个进程会进入 <strong>zombie（僵尸）</strong> 状态，也就是一个僵尸进程，这是因为 <strong>子进程释放了资源，但是没有经过父进程的确认</strong></p><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>ps aux</strong> 查看 <strong>stat</strong> ，如果对应这一栏值是 <strong>Z</strong> ,那么说明是僵尸进程</li><li>使用 <strong>ps -ef | grep 僵尸进程id</strong> 可以找到 <strong>父进程id</strong></li><li>使用 <strong>kill</strong> 杀死父进程即可</li></ol><h2 id="3-磁盘空间快满了，不影响服务的情况下如何解决？"><a href="#3-磁盘空间快满了，不影响服务的情况下如何解决？" class="headerlink" title="3. 磁盘空间快满了，不影响服务的情况下如何解决？"></a>3. 磁盘空间快满了，不影响服务的情况下如何解决？</h2><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>df -h</strong> 查看磁盘使用率情况</li><li>可以通过删除一些年份比较久的日志文件来释放空间。（一般可以通过 <strong>crontab定时任务</strong> 来每天定时清理一些日志文件，保证空间富余）</li><li>如果不是日志文件导致，就通过 <strong>find \ -size +100M | xargs ls -lh</strong> （查询根目录下所有大于100M的文件）</li><li>如果没找到大文件，可以查询占据磁盘空间大的目录，看看各个目录里是否有大量的小文件， <strong>du -h &gt; fs_du.log</strong></li></ol><h2 id="4-线上发生-java-lang-OutOfMemoryError-Java-heap-space-堆内存溢出怎么办？"><a href="#4-线上发生-java-lang-OutOfMemoryError-Java-heap-space-堆内存溢出怎么办？" class="headerlink" title="4. 线上发生 java.lang.OutOfMemoryError Java heap space 堆内存溢出怎么办？"></a>4. 线上发生 java.lang.OutOfMemoryError Java heap space 堆内存溢出怎么办？</h2><p><strong>堆内存溢出的原因及解决思路</strong></p><ol><li><strong>内存泄漏</strong>：找到堆栈引用链，查出哪个对象没有被回收导致内存泄漏（找到泄漏对象的创建位置）</li><li><strong>非内存泄漏</strong>：考虑调大JVM参数的xms xmx最大\小堆内存，为应用分配更多的堆内存；检查代码，排除有些对象生命周期是否太长了，又或者存储结构不合理（有时换个方式存储对象可以节省很多内存）</li></ol><p><strong>现实可能发生堆内存溢出的场景</strong></p><ol><li>数据库过多数据返回给服务端，导致内存溢出：</li><li>根据某个分类搜索商品列表（分页），如果这个分类的商品特别多，并且pageSize没有设置限制，被恶意攻击时，会一下子就把内存打崩</li><li>…</li></ol><p><strong>举个🌰说明</strong></p><pre class="line-numbers language-java"><code class="language-java">\<span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">*</span> 使用该选项运行：<span class="token operator">-</span>Xms20m <span class="token operator">-</span>Xmx20m <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>HeapDumpOnOutOfMemoryError      使用最小\最大堆内存都为20m 并且在堆内存溢出时做一次堆dump <span class="token operator">*</span>\<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOMTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> oomList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HeapOOMTest oomTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeapOOMTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            oomTest<span class="token punctuation">.</span>oomList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照配置运行代码，会发生堆内存溢出。</p><p>在实际项目中，堆内存溢出可能会导致进程崩溃，极端场景下进程可能直接就挂掉了，不会打印日志</p><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5COutOfMemoryError-JavaHeapSpace.png" alt=""></p><p><strong>项目根目录中，会生成dump文件，例如 java_pid15468.hprof</strong></p><p><strong>分析dump文件</strong></p><ol><li>MAT</li><li>VisualVM</li><li>PerfMa</li></ol><p>具体操作查看本人在有道云做的笔记</p><p><a href="http:\note.youdao.com\s\Jbdk16jn">实战：堆内存溢出【java.lang.OutOfMemoryError Java heap space】</a></p><p>也可以查看以下文章</p><p><a href="https:\club.perfma.com\article\670585">实战：OOM 后我如何分析解决的 | PerfMa应用性能技术社区</a></p><blockquote><p><strong>栈内存溢出</strong>：可能由 <strong>递归创建过多栈帧</strong> 导致栈内存溢出<br><strong>方法区内存溢出</strong>：可能由 <strong>常量占据内存过多</strong> 导致元空间内存不足</p></blockquote><h2 id="5-如果一个项目越跑越慢，你觉得可能是因为什么？"><a href="#5-如果一个项目越跑越慢，你觉得可能是因为什么？" class="headerlink" title="5. 如果一个项目越跑越慢，你觉得可能是因为什么？"></a>5. 如果一个项目越跑越慢，你觉得可能是因为什么？</h2><ol><li>垃圾收集非常频繁，stop the world时间越来越长，导致项目执行越来越慢</li><li>数据库数据量变大（慢SQL优化或者分库分表来解决）</li><li>Code Cache默认的240M代码缓存区满了。未满时，代码以编译的方式执行，如果满了，代码会以解释的方式执行，执行速度上比编译执行慢了一个数量级，严重影响项目性能</li><li>线程争抢过于激烈，导致代码争抢不到CPU时间片去执行任务</li><li>操作系统问题则重启大法好</li></ol><blockquote><p>代码缓存区相关知识点：<a href="http:\note.youdao.com\s\czDaSk5r">实战：代码缓存区域满</a></p></blockquote><p>可以通过 <strong>skywalking</strong> 来预防和辅助分析问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线上出现问题了你有思路解决吗&quot;&gt;&lt;a href=&quot;#线上出现问题了你有思路解决吗&quot; class=&quot;headerlink&quot; title=&quot;线上出现问题了你有思路解决吗&quot;&gt;&lt;/a&gt;线上出现问题了你有思路解决吗&lt;/h1&gt;&lt;h2 id=&quot;1-线上服务器CPU使用率达到10
      
    
    </summary>
    
    
      <category term="日常工作应用" scheme="http://xuyk.top/categories/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="线上问题" scheme="http://xuyk.top/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM灵魂拷问系列之整点类加载机制吧</title>
    <link href="http://xuyk.top/posts/interview-jvm-classloader.html"/>
    <id>http://xuyk.top/posts/interview-jvm-classloader.html</id>
    <published>2021-01-31T13:24:00.000Z</published>
    <updated>2021-02-22T08:42:13.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之问点类加载机制吧"><a href="#JVM灵魂拷问系列之问点类加载机制吧" class="headerlink" title="JVM灵魂拷问系列之问点类加载机制吧"></a>JVM灵魂拷问系列之问点类加载机制吧</h1><h2 id="1-你知道java文件是如何被运行的吗？"><a href="#1-你知道java文件是如何被运行的吗？" class="headerlink" title="1. 你知道java文件是如何被运行的吗？"></a>1. 你知道java文件是如何被运行的吗？</h2><ol><li>Java文件经过编译后变成 <strong>.class字节码文件</strong></li><li>字节码文件通过 <strong>类加载器</strong> 被搬运加载到 JVM 虚拟机中 </li></ol><h2 id="2-那你说说类加载器的流程吧，从类被加载到释放内存"><a href="#2-那你说说类加载器的流程吧，从类被加载到释放内存" class="headerlink" title="2. 那你说说类加载器的流程吧，从类被加载到释放内存"></a>2. 那你说说类加载器的流程吧，从类被加载到释放内存</h2><p>总共有七个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中 <strong>验证，准备，解析三个部分统称为连接</strong> </p><ol><li><strong>加载</strong>：将class文件加载进内存中</li><li><strong>连接</strong>：（1）验证，做一个安全检查，保证字节码符合JVM相关规则与规范；（2）准备：设置静态变量初始值等（3）解析：将常量池的引用替换为真实地址引用</li><li><strong>初始化</strong>：赋值的过程</li><li><strong>卸载</strong>：GC释放无用对象的内存</li></ol><h2 id="3-类加载器是怎么加载一个class的（双亲委派机制）？"><a href="#3-类加载器是怎么加载一个class的（双亲委派机制）？" class="headerlink" title="3. 类加载器是怎么加载一个class的（双亲委派机制）？"></a>3. 类加载器是怎么加载一个class的（双亲委派机制）？</h2><p><strong>双亲委派加载机制</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-classLoader-pic.png" alt=""></p><p>当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的。</p><ol><li>首先由最顶层的类加载器 <strong>Bootstrap ClassLoader</strong> 试图加载</li><li>如果没加载到，则把任务转交给 <strong>Extension ClassLoader</strong> 试图加载</li><li>如果也没加载到，则转交给 <strong>App ClassLoader</strong> 进行加载</li><li>如果它也没有加载得到的话，则返回给 <strong>委托的发起者</strong>，由它到指定的文件系统或网络等URL中加载该类。</li><li>如果它们都没有加载到这个类时，则抛出 <strong>ClassNotFoundException</strong> 异常。</li></ol><p><strong>那为什么要这么做呢？</strong></p><p>比如加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到 <strong>BootStrap ClassLoader</strong> 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>例子🌰：如果我们自己写了String类，其实是会报错的，因为在加载的过程中，会先找到 <strong>rt.jar</strong> 中的String.class。</p><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/Llps6z99cpPMN2ekeQljrA">Jar 包依赖冲突排查思路和解决方法</a><br>2：<a href="https://juejin.cn/post/6844904048013869064">大白话带你认识JVM</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM灵魂拷问系列之问点类加载机制吧&quot;&gt;&lt;a href=&quot;#JVM灵魂拷问系列之问点类加载机制吧&quot; class=&quot;headerlink&quot; title=&quot;JVM灵魂拷问系列之问点类加载机制吧&quot;&gt;&lt;/a&gt;JVM灵魂拷问系列之问点类加载机制吧&lt;/h1&gt;&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="JVM灵魂拷问系列" scheme="http://xuyk.top/categories/JVM%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="http://xuyk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM灵魂拷问系列之垃圾回收</title>
    <link href="http://xuyk.top/posts/interview-jvm-GarbageCollection.html"/>
    <id>http://xuyk.top/posts/interview-jvm-GarbageCollection.html</id>
    <published>2021-01-30T08:35:00.000Z</published>
    <updated>2021-02-22T08:42:22.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之垃圾回收"><a href="#JVM灵魂拷问系列之垃圾回收" class="headerlink" title="JVM灵魂拷问系列之垃圾回收"></a>JVM灵魂拷问系列之垃圾回收</h1><h2 id="1-垃圾回收发生在哪些区域？"><a href="#1-垃圾回收发生在哪些区域？" class="headerlink" title="1. 垃圾回收发生在哪些区域？"></a>1. 垃圾回收发生在哪些区域？</h2><p>JVM内存模型中， <strong>线程共享区域</strong> 会发生垃圾回收，也就是 <strong>堆内存</strong> 和 <strong>方法区</strong></p><p>线程独占区域的内存，会随着线程的消亡而销毁，不需要垃圾回收</p><h2 id="2-说说JVM在哪些情况下会进行垃圾回收？"><a href="#2-说说JVM在哪些情况下会进行垃圾回收？" class="headerlink" title="2. 说说JVM在哪些情况下会进行垃圾回收？"></a>2. 说说JVM在哪些情况下会进行垃圾回收？</h2><p>Eden区域/永久代内存满了会进行垃圾回收</p><p>一般有通过两种方式来判断：<strong>引用计数法</strong> 和 <strong>可达性分析</strong></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>通过对象的引用计数器来判断该对象是否被引用，被其他地方引用一次+1，反之-1，值为0表示没有引用可回收</p><p><strong>缺点</strong>：循环引用的情况无法解决，所以Java没用使用引用计数法</p><h3 id="2-2-可达性分析"><a href="#2-2-可达性分析" class="headerlink" title="2.2 可达性分析"></a>2.2 可达性分析</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-AccessibilityAnalysis.png" alt=""></p><p>以根对象为起点向下搜索，走过的路径为引用链，<strong>如果对象到根对象没用引用链相连</strong>，则认定这个对象不可达，是可以回收，如图Object5和Object7是可回收的 </p><p><strong>哪些对象可以作为根对象</strong></p><ol><li>虚拟机栈（栈帧中的本地变量表）引用的对象</li><li>方法区类静态属性引用的对象</li><li>方法区常量引用的对象</li><li>本地方法栈中JNI（即Native方法）引用的对象</li></ol><h2 id="3-说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？"><a href="#3-说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？" class="headerlink" title="3. 说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？"></a>3. 说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？</h2><ol><li>强引用：平时使用的引用，Object o = new Object();，只要强引用在对象就不会被回收.<strong>哪怕出现内存溢出也不回收</strong></li><li>软引用：SoftReference<string> sf = new SoftReference&lt;&gt;(“hello”);一般是描述一些有用但非必需的对象。<strong>内存不足才回收</strong><br>软引用比较适合用来实现缓存，比如网页缓存图片缓存等等</string></li><li>弱引用：WeakReference<string> sf = new WeakReference&lt;&gt;(“hello”);一般是描述一些有用但非必需的对象。<strong>不管内存是否不足都会被回收</strong></string></li><li>虚引用：任何时候都可能被回收，主要用来跟踪被回收的活动，一般跟引用引用队列配合使用</li></ol><h2 id="4-说说JVM的垃圾回收算法？对象什么时候转移到老年代？"><a href="#4-说说JVM的垃圾回收算法？对象什么时候转移到老年代？" class="headerlink" title="4.说说JVM的垃圾回收算法？对象什么时候转移到老年代？"></a>4.说说JVM的垃圾回收算法？对象什么时候转移到老年代？</h2><p>首先，我们需要了解一个原则：<strong>JVM一边运行代码一边判断和清理垃圾对象是不现实的</strong>，所以提到垃圾回收都会说一个概念： <strong>Stop The World</strong>，意思是JVM会停止工作线程的运行来进行垃圾回收 -&gt; 发生小小的卡顿</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-StopTheWorld.png" alt=""></p><blockquote><p>例子：聚会（程序运行）不断产生垃圾，清洁工清理垃圾（垃圾收集器），如果聚会不停止（程序不短暂暂停），则清洁工就没办法进入场地清理垃圾，打扫好屋子</p></blockquote><p>JVM使用 <strong>分代收集算法</strong> 来进行垃圾回收，根据不同区域使用不同垃圾回收算法，既可以有效清除垃圾对象，又提高了垃圾回收的效率</p><blockquote><p>这里省略另一种算法 <strong>增量算法</strong>：每次只收集一小片区域的垃圾（每次回收全部垃圾系统停顿更长，此算法可减小系统停顿）</p></blockquote><h3 id="4-1-年轻代垃圾回收算法-复制算法"><a href="#4-1-年轻代垃圾回收算法-复制算法" class="headerlink" title="4.1 年轻代垃圾回收算法-复制算法"></a>4.1 年轻代垃圾回收算法-复制算法</h3><p><strong>Minor/Young GC</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-youngGeneration.png" alt=""></p><p>98%的对象都会很快消亡，所以 <strong>大多数对象的生命周期都很短</strong></p><p>流程：对象在创建时，一般会先存放到Eden，Eden满了之后就会触发垃圾回收，会把Eden中存活对象拷贝到S1中，清理Eden区域的所有对象。如果Eden区域又满时，会把Eden区域和S1的存活对象复制到S2区域，再清楚所有Eden区域和S1区域的对象。如此反复..</p><blockquote><p>优点：性能好、无碎片<br>缺点：内存利用率低</p></blockquote><h3 id="4-2-老年代垃圾回收算法-标记清除-标记整理算法"><a href="#4-2-老年代垃圾回收算法-标记清除-标记整理算法" class="headerlink" title="4.2 老年代垃圾回收算法-标记清除/标记整理算法"></a>4.2 老年代垃圾回收算法-标记清除/标记整理算法</h3><p><strong>老年代的对象都是被长期引用的</strong>，老年代的垃圾回收比较慢，一般是年轻代垃圾回收的10倍以上</p><p><strong>新创建的对象也有可能直接进入老年代</strong>：</p><ol><li>对象大于JVM参数-XX:PretenureSizeThreshold的阈值时，直接分配到老年代</li><li>新生代的空间不足以存放该对象</li></ol><p>老年代的垃圾回收：<strong>Major GC</strong> </p><blockquote><p>执行Major GC时一般都伴随这Minor GC，所以老年代回收约等于Full GC。</p></blockquote><p><strong>Major GC 触发条件</strong>：</p><ol><li>老年代空间不足</li><li>元空间不足</li><li>某一对象晋升到老年代但是老年代空间不足</li><li>显式调用<code>System.gc()</code>方法，可以使用-XX:+DisableExplicitGC来忽略此调用</li></ol><p><strong>标记清除算法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-markClean.png" alt=""></p><ol><li>使用 <strong>可达性分析</strong> 标记可回收对象</li><li>清除可回收对象</li></ol><blockquote><p>优点：实现简单<br>缺点：清除后会存在内存碎片，例如图中情况下，如果想分配一个连续三个内存空间的数组，则图中的内存块无法做到</p></blockquote><p><strong>标记整理算法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-markSort.png" alt=""></p><ol><li>使用 <strong>可达性分析</strong> 标记可回收对象</li><li>把存活对象移动到一端</li><li>清除可回收对象</li></ol><blockquote><p>优点：无内存碎片<br>缺点：对比标记清除开销大</p></blockquote><h3 id="4-3-对象什么时候转移到老年代"><a href="#4-3-对象什么时候转移到老年代" class="headerlink" title="4.3 对象什么时候转移到老年代"></a>4.3 对象什么时候转移到老年代</h3><ol><li>经过 <strong>15次Young GC还存活</strong> 的对象会转移到老年代。例如<strong>Spring容器里管理的对象实例</strong>，被Spring容器引用，所以长期存活转移到老年代</li><li>新创建的大对象，如果Eden区域放不下，则会转移到老年代</li><li><strong>S区域放不下</strong> 的对象会转移到老年代</li></ol><h2 id="5-GC简单汇总图"><a href="#5-GC简单汇总图" class="headerlink" title="5. GC简单汇总图"></a>5. GC简单汇总图</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-GCList.png" alt=""></p><blockquote><p>Full GC待补充</p></blockquote><h2 id="6-常用的垃圾回收器"><a href="#6-常用的垃圾回收器" class="headerlink" title="6. 常用的垃圾回收器"></a>6. 常用的垃圾回收器</h2><p><strong>parnew + CMS</strong> </p><p>目前主流的jdk版本使用的组合</p><p>parnew： <strong>新生代垃圾回收器</strong>，使用<strong>多线程</strong>去回收垃圾对象，使用复制算法<br>CMS：<strong>老年代垃圾回收器</strong>，是一个<strong>并发收集器</strong>，使用标记清除算法</p><p><strong>G1分代垃圾回收器</strong></p><p>jdk新版本使用的垃圾回收器</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM灵魂拷问系列之垃圾回收&quot;&gt;&lt;a href=&quot;#JVM灵魂拷问系列之垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;JVM灵魂拷问系列之垃圾回收&quot;&gt;&lt;/a&gt;JVM灵魂拷问系列之垃圾回收&lt;/h1&gt;&lt;h2 id=&quot;1-垃圾回收发生在哪些区域？&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JVM灵魂拷问系列" scheme="http://xuyk.top/categories/JVM%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="http://xuyk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM灵魂拷问系列之JVM内存模型知多少</title>
    <link href="http://xuyk.top/posts/interview-jvm-model.html"/>
    <id>http://xuyk.top/posts/interview-jvm-model.html</id>
    <published>2021-01-29T07:19:00.000Z</published>
    <updated>2021-02-22T08:42:31.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之JVM内存模型知多少"><a href="#JVM灵魂拷问系列之JVM内存模型知多少" class="headerlink" title="JVM灵魂拷问系列之JVM内存模型知多少"></a>JVM灵魂拷问系列之JVM内存模型知多少</h1><h2 id="1-JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？"><a href="#1-JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？" class="headerlink" title="1.JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？"></a>1.JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？</h2><blockquote><p>前提流程分析：我们在部署项目时，无论是旧项目（SSH、SSM）还是新项目（SpringBoot内置tomcat），都会放在tomcat中的目录中部署运行的。<br>tomcat由java编写，本质上是一个JVM进程，当请求到来时，jvm通过编译后的项目字节码来执行我们的业务代码响应请求</p></blockquote><p>众所周知，不讲tomcat自带的线程池，我们平时使用的框架或者自定义的线程池都说明了一点，系统中运行着多个线程，这些线程既有自己独有的空间（栈内存），也有共同分享的空间（堆内存）</p><h3 id="1-1-堆内存（线程共享）"><a href="#1-1-堆内存（线程共享）" class="headerlink" title="1.1 堆内存（线程共享）"></a>1.1 堆内存（线程共享）</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-heap.png" alt=""></p><p>由图可知，堆分为三个部分：<strong>新生代、老年代和持久代/元空间</strong></p><blockquote><p>元空间不存放在堆中而是存放在在本地内存中，这里用作比较之用</p></blockquote><p>JVM在启动过程中，线程会创建很多对象，这些对象一般优先存放在 <strong>新生代的Eden伊甸园区域</strong> ，如果对象大于一定程度，则存放在 <strong>老年代</strong> 中</p><p>java语言的特点：一处编译，处处运行。说的就是我们写的项目代码会通过编译器编译成字节码文件，由不同系统的java虚拟机来运行他们。而这些 <strong>字节码文件（类信息等）</strong> 也是需要一个地方进行存放的，JDK8之前，存放地为 <strong>永久代</strong> ，JDK8之后为 <strong>元空间</strong></p><p>JDK8前后分代改进：</p><ul><li>JDK8以前：在 <strong>永久代</strong> 存放常量池和类信息</li><li>JDK8以后：在 <strong>metaspace元空间</strong> 存放类信息</li></ul><p><strong>为什么 JDK1.8 把永久代干掉</strong></p><ol><li>oracle收购两家公司，其中一家公司JDK1.8以前没有永久代，干脆干掉了再新增一个元空间</li><li>永久代存放一系列常量，类、方法的相关信息，但是这些都没办法确定，但是 <strong>永久代空间固定，可能导致内存溢出</strong>（内存不足以存放信息-OutOfMemoryError：PermGen）</li><li>元空间本质是本地内存，理论上 <strong>取决于操作系统可以分配的内存大小，可以解决内存不足的情况</strong></li></ol><h3 id="1-2-栈内存-虚拟机栈（线程独享）"><a href="#1-2-栈内存-虚拟机栈（线程独享）" class="headerlink" title="1.2 栈内存/虚拟机栈（线程独享）"></a>1.2 栈内存/虚拟机栈（线程独享）</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-stack.png" alt=""></p><p>当线程创建时，会创建一个由多个栈帧组成的虚拟机栈，存放着例如 <strong>局部变量、对象引用</strong> 等</p><h3 id="1-3-本地方法栈（线程独享）"><a href="#1-3-本地方法栈（线程独享）" class="headerlink" title="1.3 本地方法栈（线程独享）"></a>1.3 本地方法栈（线程独享）</h3><p>存放一些由 <strong>C语言编写的native方法</strong> ，例如我们常用到的 <strong>Unsafe（CAS）</strong> </p><h3 id="1-4-程序计数器（线程独享）"><a href="#1-4-程序计数器（线程独享）" class="headerlink" title="1.4 程序计数器（线程独享）"></a>1.4 程序计数器（线程独享）</h3><p>用来 <strong>记录线程执行字节码的地址</strong> ，也就是对执行到哪一行代码做一个标记。当线程被挂起，再恢复时，方便及时定位到继续执行的位置</p><h3 id="1-5-方法区（线程共享）"><a href="#1-5-方法区（线程共享）" class="headerlink" title="1.5 方法区（线程共享）"></a>1.5 方法区（线程共享）</h3><p>方法区是 <strong>逻辑层面</strong> 上的划分，如图</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-methodArea.png" alt=""></p><p>方法区在 <strong>堆</strong> 中存储着 <strong>静态变量 和 字符串常量</strong><br>方法区在 <strong>元空间</strong> 中存储着 <strong>类相关信息 和 运行时常量</strong></p><blockquote><p>【静态常量池】：属于<strong>堆</strong>，存放着 <strong>文本常量</strong> 或者 <strong>被final修饰的常量</strong>，也存放着一些 <strong>类名、方法名</strong> 等<br>【运行时常量池】：属于<strong>元空间/本地内存</strong>，当类被加载到内存中，JVM会把静态常量池中的内容存放到运行时常量池中。<br>【字符串常量池】：属于<strong>堆</strong>，运行时常量池分出来的一部分，类加载到内存中时，字符串会存放在字符串常量池中</p></blockquote><h2 id="2-你知道JVM是如何运行起来的吗？对象是如何分配的？"><a href="#2-你知道JVM是如何运行起来的吗？对象是如何分配的？" class="headerlink" title="2.你知道JVM是如何运行起来的吗？对象是如何分配的？"></a>2.你知道JVM是如何运行起来的吗？对象是如何分配的？</h2><p>举个例子🌰：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PREFIX <span class="token operator">=</span> <span class="token string">"名称前缀"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        MyService myService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myService<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token string">"testName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>PREFIX <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-demoDesc.jpg" alt=""></p><ol><li>java代码通过编译器编译成JVM可读懂的class字节码文件。项目启动，JVM调用main方法，或者存在Spring容器实例化必需类时，都会通过 <strong>类加载机制</strong> 把MyController.class文件加载到内存中，在堆内存中创建MyController实例，将MyController类相关信息存放在元空间中，在堆内存的静态常量池中创建静态常量</li><li>当请求到来时，线程执行<code>doRequest()</code>方法，会在 <strong>堆内存</strong> 中创建一个MyService对象实例，同时在栈内存中创建一个栈帧，存放方法信息和局部引用变量myService，指向堆内存中的示例。静态常量池的”名称前缀”也会存入运行时常量池</li><li>当myService执行<code>printName()</code>方法时，会创建<code>printName()</code>方法对应的栈帧，字符串常量池创建”testName”，局部变量name也存在栈帧中，指向”testName”</li><li>当<code>printName()</code>方法执行完毕，对应栈帧销毁，而后<code>doRequest()</code>执行完毕，对应栈帧销毁。因栈帧中的引用销毁了，堆内存相关的数据没有引用，下一次会被垃圾回收</li></ol><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/BLcJm5xG">JVM内存结构个人笔记</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM灵魂拷问系列之JVM内存模型知多少&quot;&gt;&lt;a href=&quot;#JVM灵魂拷问系列之JVM内存模型知多少&quot; class=&quot;headerlink&quot; title=&quot;JVM灵魂拷问系列之JVM内存模型知多少&quot;&gt;&lt;/a&gt;JVM灵魂拷问系列之JVM内存模型知多少&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="JVM灵魂拷问系列" scheme="http://xuyk.top/categories/JVM%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="http://xuyk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游</title>
    <link href="http://xuyk.top/posts/interview-springcloud.html"/>
    <id>http://xuyk.top/posts/interview-springcloud.html</id>
    <published>2021-01-27T10:54:00.000Z</published>
    <updated>2021-01-29T07:47:25.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游"><a href="#Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游" class="headerlink" title="Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游"></a>Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游</h1><p><strong>SpringCloud组件</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringCloud-component.png" alt=""></p><p><strong>一个请求怎么在SpringCloud中遨游</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringCloud-structure.jpg" alt=""></p><ol><li>在Spring Cloud中，每个服务和组件都需要在 <strong>Eureka注册中心</strong> 注册，注册成功后，Eureka也会主动发起 <strong>心跳检测来进行健康检查和信息同步</strong></li><li>服务启动时，会根据环境从配置中心中拉取对应配置来启动</li><li>浏览器发起请求，到达网关层，网关层根据 <strong>路由转发</strong> 到指定服务A（网关层还可起到限流、鉴权、负载均衡等作用）</li><li>如果服务A需要需要依赖服务B，则会通过 <strong>ribbon负载均衡策略</strong> 找到某一台服务B的实例，再通过 <strong>feign调用</strong> 实例服务，其中使用 <strong>hystrix</strong> 进行服务 <strong>降级/熔断</strong> </li><li>A服务执行业务完毕，返回数据给网关，网关返回浏览器/前端工程</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之一个请求怎么在Spri
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SpringCloud" scheme="http://xuyk.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring灵魂拷问系列之简单理一下SpringMVC流程</title>
    <link href="http://xuyk.top/posts/interview-springmvc.html"/>
    <id>http://xuyk.top/posts/interview-springmvc.html</id>
    <published>2021-01-25T15:54:00.000Z</published>
    <updated>2021-01-25T15:58:16.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之简单理一下SpringMVC流程"><a href="#Spring灵魂拷问系列之简单理一下SpringMVC流程" class="headerlink" title="Spring灵魂拷问系列之简单理一下SpringMVC流程"></a>Spring灵魂拷问系列之简单理一下SpringMVC流程</h1><p> <img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringMVC-structure.jpg" alt=""></p><p>SpringMVC大体流程：</p><ol><li>tomcat工作线程将请求转发给Spring MVC框架的<strong>中央控制器DispatcherServlet</strong></li><li>中央控制器根据请求信息做相关的<strong>适配</strong>和<strong>映射</strong>，将请求转发到对应Controller</li><li>根据<code>@RequestMapping</code>来<strong>定位</strong>和<strong>调用</strong>到http请求对应的处理方法（处理器映射器、处理器适配器、处理器）</li><li>业务执行完毕后会有一个返回值。（1）以前：会通过JSP/模版引擎，将前端页面存放在后端工程中，返回值这里就是页面模版的名字，Spring MVC根据返回的数据对象对html页面进行渲染；（2）如今，前后端分离，返回值为json字符串，前端会根据返回的json数据，对html页面进行渲染</li><li>将渲染后的html页面返回给浏览器进行显示</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之简单理一下SpringMVC流程&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之简单理一下SpringMVC流程&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之简单理一下SpringMVC流程&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SpringMVC" scheme="http://xuyk.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring灵魂拷问系列之Spring基础拷问</title>
    <link href="http://xuyk.top/posts/interview-spring-base.html"/>
    <id>http://xuyk.top/posts/interview-spring-base.html</id>
    <published>2021-01-23T12:04:00.000Z</published>
    <updated>2021-01-23T12:04:06.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之Spring基础拷问"><a href="#Spring灵魂拷问系列之Spring基础拷问" class="headerlink" title="Spring灵魂拷问系列之Spring基础拷问"></a>Spring灵魂拷问系列之Spring基础拷问</h1><h2 id="0-面试连环炮"><a href="#0-面试连环炮" class="headerlink" title="0.面试连环炮"></a>0.面试连环炮</h2><p>Spring IOC和AOP的理解 -&gt; 动态代理 -&gt; JDK/Cglib动态代理 -&gt; Spring Bean线程安全 -&gt; Spring事务实现原理和事务传播机制</p><h2 id="1-说说对Spring-IOC的理解"><a href="#1-说说对Spring-IOC的理解" class="headerlink" title="1.说说对Spring IOC的理解"></a>1.说说对Spring IOC的理解</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-old-process.jpg" alt=""></p><p>以前的一套系统：<br>web服务器：绑定地址端口，负责接收请求<br>servlet：引入serviceImpl类来处理请求（doPost、doGet）</p><p>像这样每个servlet都新建一个serviceImpl服务类实例，导致耦合度很高，当需要换一个服务实现类时，每个地方都需要修改成新的类，导致改动、测试成本巨大</p><p>Spring IOC：<strong>控制反转，依赖注入，让系统的类与类之间解耦</strong></p><p>Tomcat启动Spring容器，扫描指定路径的包路径，所有加了Spring注解的类会被Spring容器初始和实例化Bean并且交给Spring容器管理，当某个地方使用到时，Spring容器会自动注入实例</p><blockquote><p>Spring MVC：核心Servlet、Filter，负责用户请求的转发，转发给对应的Controller，之后调用相应的服务类进行处理</p></blockquote><p>底层：通过反射来动态的构建对象实例</p><p>当改成Spring IOC解耦时，只需要修改service的实现类即可。这样的话，在具体请求过来时，Spring会根据反射动态生成实现类来处理请求了</p><h2 id="2-说说对Spring-AOP的理解"><a href="#2-说说对Spring-AOP的理解" class="headerlink" title="2.说说对Spring AOP的理解"></a>2.说说对Spring AOP的理解</h2><p><strong>核心技术：动态代理</strong></p><blockquote><p>不关心底层代码的实现逻辑，在此实现逻辑前后做一些公共的处理，例如事务处理、统计方法耗时等</p></blockquote><p>把代码公共/重复的代码抽取出来，比如日志、事务、通知等业务，做一个切面</p><h2 id="3-cglib动态代理和jdk动态代理的区别"><a href="#3-cglib动态代理和jdk动态代理的区别" class="headerlink" title="3.cglib动态代理和jdk动态代理的区别"></a>3.cglib动态代理和jdk动态代理的区别</h2><p>动态代理，动态的创建一个代理类和他的实例对象出来，在里面引用真正需要调用的类，代理类在此做一些增强（事务、日志等）</p><p>两者区别在于 <strong>生成动态代理类的方式</strong></p><p>Spring AOP使用的 <strong>JDK动态代理</strong> ，生成实现同个接口代理类，构造实例出来。当需要代理的类没有接口时，Spring AOP会改用 <strong>Cglib动态代理</strong> ，生成该类的子类（动态生成字节码），覆盖目标类的方法，在覆盖方法中进行增强</p><ol><li><strong>JDK动态代理</strong>：代理类实现 <strong>InvocationHandler</strong> 接口， <strong>Proxy</strong> 生成代理对象，当调用接口方法时，真正会调用的是代理类的 <strong>invoke</strong> 方法</li><li><strong>Cglib动态代理</strong>：代理类实现 <strong>MethodInterceptor</strong> 接口， <strong>Enhancer</strong> 生成代理对象，当调用类方法时，拦截器会拦截在方法前后进行增强（ <strong>intercept方法</strong> ）</li></ol><h2 id="4-Spring中的Bean是线程安全的吗"><a href="#4-Spring中的Bean是线程安全的吗" class="headerlink" title="4.Spring中的Bean是线程安全的吗"></a>4.Spring中的Bean是线程安全的吗</h2><p>Spring Bean的作用域：</p><ul><li><strong>singleton</strong>：默认，单例，只有一个实例</li><li><strong>prototype</strong>：为每个bean请求都提供一个实例</li><li><strong>request</strong>：为每个网络请求request创建一个实例，请求完成后被垃圾回收</li><li><strong>session</strong>：为每个session创建一个实例，请求完成后被垃圾回收</li><li><strong>global-session</strong>：标准的HTTP Session作用域</li></ul><blockquote><p>基本大部分时候我们都使用默认的singleton单例作用域</p></blockquote><p><strong>Spring Bean是线程不安全的</strong></p><blockquote><p>例如，bean中存在一个变量data（未被volatile修饰），多线程并发（多个请求同时发起同个服务）时，多个线程同时调用实例A的同一方法（该方法里存在data++），基于线程的工作内存和主内存不一定同步的机制，就会发生线程安全问题<br>如果不存在实例变量，逻辑处理只操作数据库的话，一般不会有线程安全问题</p></blockquote><h2 id="5-Spring的事务实现原理是什么？"><a href="#5-Spring的事务实现原理是什么？" class="headerlink" title="5.Spring的事务实现原理是什么？"></a>5.Spring的事务实现原理是什么？</h2><p>日常编码中，需要对代码逻辑增加事务，使用Transactional注解，Spring会通过AOP/动态代理的机制，对方法进行增强，织入事务，方法执行前开启事务，执行成功后提交事务，异常回滚事务</p><h2 id="6-能聊聊你对Spring事务的传播机制的理解吗？"><a href="#6-能聊聊你对Spring事务的传播机制的理解吗？" class="headerlink" title="6.能聊聊你对Spring事务的传播机制的理解吗？"></a>6.能聊聊你对Spring事务的传播机制的理解吗？</h2><p><strong>事务传播机制级别 - 最常用的是前4个</strong></p><ul><li><strong>REQUIRED</strong>：如果父方法没有事务，则新创建一个事务，存在事务则加入事务</li><li><strong>SUPPORTS</strong>：如果父方法存在事务则加入事务，当前没有事务，则不开启事务执行</li><li><strong>REQUIRES_NEW</strong>：无论当前父方法有没有事务，都新建一个事务，父方法存在事务时，两者事务是隔离开的</li><li><strong>NESTED</strong>：父方法存在事务，则嵌套事务执行（外层代码出错内层代码一起回滚，内层代码出错只有内层回滚），如果没有事务，按照REQUIRED属性执行</li><li><strong>MONDATORY</strong>：如果当前父方法存在事务则加入事务，当前没有事务，则抛异常</li><li><strong>NOT_SUPPORTED</strong>：强制要求非事务运行，如果父方法存在事务则挂起</li><li><strong>NEVER</strong>：非事务方式执行，如果存在事务会报错</li></ul><p><strong>方法A调用方法B，希望方法A出错只回滚方法A自己，不回滚方法B，该怎么办</strong></p><blockquote><p>选择事务传播机制的REQUIRES_NEW</p></blockquote><p><strong>方法A调用方法B，方法B只能回滚自己，方法A可以带着方法B一起回滚</strong></p><blockquote><p>NESTED嵌套事务</p></blockquote><h2 id="7-谈谈Spring-Boot的核心架构"><a href="#7-谈谈Spring-Boot的核心架构" class="headerlink" title="7.谈谈Spring Boot的核心架构"></a>7.谈谈Spring Boot的核心架构</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringBoot-structure.jpg" alt=""></p><p>在早期java web开发时，我们使用SSM框架那一套，需要打包部署到线上的tomcat上，请求到来，根据Spring MVC框架流程，来一一调用controller、service、dao层等。</p><p>早期开发时，我们也需要根据业务引入比较多的中间件技术，例如redis、elasticsearch、rabbitmq等，引入时配置比较繁琐复杂，例如引入jar包，编写xml配置文件，定义bean等</p><p><strong>SpringBoot</strong></p><ol><li>内嵌了tomcat，上线时可以直接部署启动；</li><li>通过 <strong>自动装配</strong> 的特性，在整合第三方组件时，只要引入相关的starter依赖，会自动做一些配置、定义生成对应bean等操作，只要配置必要的相关地址等配置，一定程度上降低了原先整合的成本，详细可看<a href="http://xuyk.top/posts/SpringBoot-autoConfiguration.html">SpringBoot之自动配置原理</a></li></ol><h2 id="8-Spring-Bean的生命周期"><a href="#8-Spring-Bean的生命周期" class="headerlink" title="8.Spring Bean的生命周期"></a>8.Spring Bean的生命周期</h2><p><strong>Spring Bean大致的生命周期</strong></p><p>实例化 -&gt; 初始化 -&gt; Spring容器管理下长期存活 -&gt; 销毁</p><h3 id="1-实例化Bean"><a href="#1-实例化Bean" class="headerlink" title="1.实例化Bean"></a>1.实例化Bean</h3><p>如果需要使用bean，需要先实例化</p><ul><li>对于 BeanFactory 容器，通过 createBean 进行实例化</li><li>对于 ApplicationContext 容器，通过 BeanDefinition 进行实例化</li></ul><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h3><p>当需要使用的bean依赖其他的bean，也需要把依赖的bean创建并且注入进来，注入的方式有两种</p><ul><li><strong>构造器注入</strong></li><li><strong>setter注入</strong></li></ul><h3 id="3-处理Aware接口"><a href="#3-处理Aware接口" class="headerlink" title="3.处理Aware接口"></a>3.处理Aware接口</h3><p>如果bean实现了 ApplicationContextAware 接口，Spring容器就会通过 <code>setApplicationContext(ApplicationContext)</code> 方法，把Spring容器传递给这个bean</p><h3 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4.BeanPostProcessor"></a>4.BeanPostProcessor</h3><p>bean实例化完成之后，如果想对Bean进行一些自定义的处理，那么可以让Bean实现 BeanPostProcessor 接口，将会调用<code>postProcessBeforeInitialization(Object obj,String s)</code>方法</p><blockquote><p>初始化之前</p></blockquote><h3 id="5-初始化initializingBean与init-method"><a href="#5-初始化initializingBean与init-method" class="headerlink" title="5.初始化initializingBean与init-method"></a>5.初始化initializingBean与init-method</h3><p>对bean进行初始化</p><h3 id="6-BeanPostProcessor"><a href="#6-BeanPostProcessor" class="headerlink" title="6.BeanPostProcessor"></a>6.BeanPostProcessor</h3><p>如果Bean实现 BeanPostProcessor 接口，将会调用<code>postProcessAfterInitialization(Object obj,String s)</code>方法</p><blockquote><p>由于发生在初始化完成之后，所以经常用于内存或者缓存的操作</p></blockquote><h3 id="7-DisposableBean"><a href="#7-DisposableBean" class="headerlink" title="7.DisposableBean"></a>7.DisposableBean</h3><p>当Bean不再被需要时，如果Bean实现了DisposableBean接口，会调用他的<code>destory()</code>方法</p><h3 id="8-destroy-method"><a href="#8-destroy-method" class="headerlink" title="8.destroy-method"></a>8.destroy-method</h3><p>如果bean配置的destroy-method属性，会自动调用配置的销毁方法</p><h2 id="9-能说说Spring中使用了哪些设计模式吗"><a href="#9-能说说Spring中使用了哪些设计模式吗" class="headerlink" title="9.能说说Spring中使用了哪些设计模式吗"></a>9.能说说Spring中使用了哪些设计模式吗</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><p>Spring IOC自己就是一个大工厂，把所有bean实例都放在Spring容器中，需要使用就直接从Spring容器中拿</p><h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>Spring Bean默认使用单例，保证类在运行期间只有一个实例对象，最常见的就是懒汉式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonTest singletonTest<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonTest <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    singletonTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singletonTest<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用双重检查 + synchronized关键字保证只生成一个实例，volatile保证不发生指令重排</p></blockquote><h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h3><p>主要涉及到的就是Spirng AOP，例如XXXAware那些某个增强类，创建动态代理对象实例，在调用被代理对象的方法时，会先执行代理类的增强代码，再执行方法代码，例如Spring Bean生命周期中，实现 ApplicationContextAware 接口后，Spring容器会把 ApplicationContext 注入到bean中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之Spring基础拷问&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之Spring基础拷问&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之Spring基础拷问&quot;&gt;&lt;/a&gt;Spring灵魂拷问系列之Spri
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring" scheme="http://xuyk.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之Java内存模型</title>
    <link href="http://xuyk.top/posts/interview-JMM.html"/>
    <id>http://xuyk.top/posts/interview-JMM.html</id>
    <published>2021-01-17T06:25:00.000Z</published>
    <updated>2021-01-17T06:25:11.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之Java内存模型"><a href="#并发编程灵魂拷问系列之Java内存模型" class="headerlink" title="并发编程灵魂拷问系列之Java内存模型"></a>并发编程灵魂拷问系列之Java内存模型</h1><h2 id="0-面试连环炮路径"><a href="#0-面试连环炮路径" class="headerlink" title="0.面试连环炮路径"></a>0.面试连环炮路径</h2><p>JMM（Java内存模型）-&gt; 原子性、可见性、有序性 -&gt; volatile和可见性 -&gt; volatile和有序性（指令重排+happens-before）-&gt; volatile和原子性 -&gt; volatile底层原理（内存屏障级别的原理）</p><h2 id="1-聊一下Java的内存模型"><a href="#1-聊一下Java的内存模型" class="headerlink" title="1.聊一下Java的内存模型"></a>1.聊一下Java的内存模型</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM-process.jpg" alt=""></p><p>volatile：共享变量修改时会强制刷新一下主内存的值</p><ol><li>线程1/2 read 主内存的共享变量， load 到工作内存中，此时读到的值都为0</li><li>线程1/2 use 从工作内存中拿出共享变量，进行操作（比如 <strong>++</strong> 操作，那么计算之后的值都为1）</li><li>线程1/2 assign 把工作内存设置回工作内存中，之后工作内存尝试 <strong>store</strong> 写入主内存，写入成功就是 <strong>write</strong></li><li>结果就是主内存data从 0 -&gt; 1</li></ol><h2 id="2-你知道Java内存模型的原子性、有序性、可见性是什么"><a href="#2-你知道Java内存模型的原子性、有序性、可见性是什么" class="headerlink" title="2.你知道Java内存模型的原子性、有序性、可见性是什么"></a>2.你知道Java内存模型的原子性、有序性、可见性是什么</h2><p><strong>原子性</strong>：指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1。</p><p><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。Java保证可见性可以认为通过volatile、synchronized、final来实现。</p><p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行，Java通过volatile、synchronized来保证。具备有序性，则不会发生指令重排</p><p>volatile禁止指令重排序，防止编译器编译优化时对代码重新排序，导致代码顺序变化。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM_orderliness.png" alt=""></p><p>【例子】正常情况是资源准备完毕，flag才设置为true，但是如图，如果发生指令重排，可能导致先设置为true再进行资源准备，导致直接直接execute而报错</p><h2 id="3-讲讲volatile的工作原理，如何保证可见性？"><a href="#3-讲讲volatile的工作原理，如何保证可见性？" class="headerlink" title="3.讲讲volatile的工作原理，如何保证可见性？"></a>3.讲讲volatile的工作原理，如何保证可见性？</h2><p>volatile关键字用来保证 <strong>可见性</strong> 和 <strong>有序性</strong> 的，不能保证原子性（极端特殊情况下可保证而已）</p><p>举例说明无法保证原子性（还是这张图）：<br><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM-process.jpg" alt=""></p><blockquote><p>就算使用volatile修饰data，当线程1更新data=1到主内存，使得线程二工作内存的data值失效，但是可能此时data已经在被运算中，及时失效了，还是会通过assign把data=1设置到工作内存中，最后write到主内存<br>需要保证原子性，还是需要 <strong>synchronized</strong> 、 <strong>lock</strong> 来保证</p></blockquote><p>当volatile修饰值data，保证data在多线程之间的 <strong>可见性</strong> ，如果data修改，会强制刷新其他线程工作内存中的data的值（让其他线程工作内存data的值失效，来起到强制刷新的作用）</p><p>volatile通过 <strong>禁止指令重排</strong> 来保证 <strong>有序性</strong> </p><h2 id="4-你知道指令重排和happens-before是什么吗？"><a href="#4-你知道指令重排和happens-before是什么吗？" class="headerlink" title="4.你知道指令重排和happens-before是什么吗？"></a>4.你知道指令重排和happens-before是什么吗？</h2><p>一般情况下，为了提高程序执行的效率，编译器或者指令器会对代码进行优化，例如指令重排。</p><p>java中有一个 <strong>happens-before</strong> 原则,<strong>一定程度上来避免胡乱地指令重排</strong>。他在一些特殊情况下，不允许编译器或者指令器对写的代码进行指令重排。</p><p>其中有一个与volatile相关的原则，如果代码中存在volatile修饰的值，此值进行volatile写后，再volatile读，那么顺序上必须先写再读</p><blockquote><p>比如代码中,代码顺序A-&gt;B-&gt;C，那么A的顺序就优于C；或者比如对lock的操作顺序不能被重排（代码先unlock再lock，就不能重排为lock后unlock，否则导致流程错乱）</p></blockquote><h2 id="5-volatile是如何基于内存屏障保证可见性和有序性的？"><a href="#5-volatile是如何基于内存屏障保证可见性和有序性的？" class="headerlink" title="5.volatile是如何基于内存屏障保证可见性和有序性的？"></a>5.volatile是如何基于内存屏障保证可见性和有序性的？</h2><p>内存屏障：禁止重排序</p><p><strong>如何保证有序性</strong><br>如果使用了volatile修饰一个值后，那么会对该值的读写前后会加入一些内存屏障，加入屏障之后，来避免发生指令重排</p><p><strong>如何保证可见性</strong><br>如果使用了volatile修饰一个值data后，在对data执行写操作，JVM会发送<strong>lock前缀指令</strong>给CPU，CPU收到指令，计算完毕会把data强制刷新到主内存里，其他线程通过<strong>对总线的嗅探</strong>，让工作内存的data值失效，之后读取data值时因为工作内存data值失效，所以从缓存中获取。保证了可见性</p><blockquote><p>lock前缀指令 + MESI缓存一致性协议</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之Java内存模型&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之Java内存模型&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之Java内存模型&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JMM" scheme="http://xuyk.top/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之对AQS理解吗</title>
    <link href="http://xuyk.top/posts/interview-AQS.html"/>
    <id>http://xuyk.top/posts/interview-AQS.html</id>
    <published>2021-01-16T09:05:00.000Z</published>
    <updated>2021-01-24T07:03:44.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之对AQS理解吗"><a href="#并发编程灵魂拷问系列之对AQS理解吗" class="headerlink" title="并发编程灵魂拷问系列之对AQS理解吗"></a>并发编程灵魂拷问系列之对AQS理解吗</h1><p><strong>AQS</strong> 即 AbstractQueuedSynchronizer，队列同步器。早期是因为JDK6以前的synchronized关键字使用的是重量级锁，性能不太好，所以作者编写了AQS。</p><p>在JUC中 CountDownLatch、ReentrantLock、ThreadPoolExecutor、ReentrantReadWriteLock 等底层用的都是AQS，AQS几乎占据了JUC并发包里的半壁江山，如果想要获取锁可以被中断、超时获取锁、尝试获取锁那就用AQS吧。</p><p>AQS内部维护了一个 <strong>先进先出队列</strong> 和 <strong>state状态变量</strong></p><ul><li>先进先出队列载体是 Node节点，节点里包含状态值，属于独占/共享模式，前驱/后继节点等信息</li><li>state由 <strong>volatile</strong> 修饰，标识当前锁的状态，1表示加锁成功 0未加锁</li></ul><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AQS-first.png" alt=""></p><ol><li>当线程1操作CAS加锁成功，AQS中的加锁线程变为线程1，state设置为1。</li><li>与此同时线程2加锁失败会进入FIFO先进先出等待队列，当线程1执行完成后，state设为0，然后唤醒等待队列的首位线程也就是线程2，让线程2进行CAS操作</li></ol><p><strong>独占式锁和共享式锁</strong></p><ul><li>独占式：有且只有一个线程能获取到锁，如：ReentrantLock。</li><li>共享式：可以多个线程同时获取到锁，如：CountDownLatch</li></ul><p><strong>公平锁和非公平锁</strong></p><ul><li>公平锁：先到先得，线程通过排队的方式来获取锁</li><li>非公平锁：后来的线程可能会率先获取到锁，非公平锁性能优于公平锁</li></ul><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/k8s-B1ZsEQylba4NWjehEA">由浅入深逐步讲解Java并发的半壁江山AQS</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/ZNURbYIdYqDNXLtRAvDxBQ">1.5w字，30图带你彻底掌握 AQS</a><br>4：<a href="https://mp.weixin.qq.com/s/-OEOk5NNgyjI8aYBm9Sspg">【对线面试官】AQS&amp;&amp;ReentrantLock</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之对AQS理解吗&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之对AQS理解吗&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之对AQS理解吗&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之对AQS理解吗&lt;/h1&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="AQS" scheme="http://xuyk.top/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之如何理解CAS</title>
    <link href="http://xuyk.top/posts/interview-CAS.html"/>
    <id>http://xuyk.top/posts/interview-CAS.html</id>
    <published>2021-01-15T01:12:00.000Z</published>
    <updated>2021-01-24T06:46:42.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之如何理解CAS"><a href="#并发编程灵魂拷问系列之如何理解CAS" class="headerlink" title="并发编程灵魂拷问系列之如何理解CAS"></a>并发编程灵魂拷问系列之如何理解CAS</h1><p><strong>什么是CAS</strong></p><p> CAS，compare And set/swap等，他底层的硬件级别操作（CPU指令cmpxchg）来保证一定是原子性操作，让同一时间只能有一个线程执行CAS操作，在此时间其他线程执行CAS会失败。java里经常使用unsafe类来执行CAS操作</p><p> CAS有三个参数：<strong>当前值A、内存值V、修改的新值B</strong></p><ul><li>如果A和V相等，则把内存值V修改成新值B</li><li>如果A和V不相等，要么重试，要么放弃更新</li></ul><p><strong>为什么要使用CAS呢</strong></p><ul><li>synchronized关键字每次都需要使用锁来保证同一时间只有一个线程执行操作</li><li>CAS允许多个线程同时操作共享数据，但是同一时间只能有一个线程执行CAS操作，在很多情况下比synchronized更加高效，例如 <strong>对一个值进行累加</strong> 这样的操作</li></ul><blockquote><p>AtomicLong等底层使用了CAS，但是更推荐使用LongAdder，性能更高（数组来分散目标值减少自旋重试）</p></blockquote><p><strong>CAS的缺点</strong></p><ul><li>无法解决ABA的问题（共享变量从A -&gt; B -&gt; A），需要加一个版本号</li><li>循环时间长导致资源消耗</li><li>循环执行CAS操作不成功会陷入自旋而耗费cpu资源，锁竞争激烈的场景更倾向于使用重量级锁</li></ul><blockquote><p>解决ABA问题，可以使用结合 <strong>乐观锁</strong> 的机制，例如Java中的 <strong>AtomicStampedReference</strong> 类</p></blockquote><p><strong>使用场景</strong></p><ol><li>如果高并发执行时间久 ，用SYN好， 因为SYN底层用了wait() 阻塞后是不消耗CPU资源的</li><li>如果锁竞争不激烈说明自旋不严重，此时用CAS。</li></ol><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/kvuPxn-vc8dke093XSE5IQ">由浅入深讲解JUC下 CAS + Lock</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/uHl9cnNBtvY_Xc-5WfwpmQ">【对线面试官】 CAS</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之如何理解CAS&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之如何理解CAS&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之如何理解CAS&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之如何理解CAS&lt;/h1&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="CAS" scheme="http://xuyk.top/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之ConcurrentHashMap</title>
    <link href="http://xuyk.top/posts/interview-ConcurrentHashMap.html"/>
    <id>http://xuyk.top/posts/interview-ConcurrentHashMap.html</id>
    <published>2021-01-13T08:40:00.000Z</published>
    <updated>2021-01-13T08:40:49.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之ConcurrentHashMap"><a href="#并发编程灵魂拷问系列之ConcurrentHashMap" class="headerlink" title="并发编程灵魂拷问系列之ConcurrentHashMap"></a>并发编程灵魂拷问系列之ConcurrentHashMap</h1><h2 id="那有什么线程安全的HashMap可以代替呢"><a href="#那有什么线程安全的HashMap可以代替呢" class="headerlink" title="那有什么线程安全的HashMap可以代替呢"></a>那有什么线程安全的HashMap可以代替呢</h2><p>一般面试连环炮会在大致问完HashMap后有此一问，<strong>既然HashMap是线程不安全的，那有什么线程安全的HashMap可以代替呢</strong>，就是为了引出ConcurrentHashMap。</p><ul><li><p>JDK1.8之前：采用分段锁的机制，整个数组被分为对个段（segment），每一段都有一个锁，段与段之间可以并发访问，但是多个线程同时访问同一段时，需要获取锁才能进行访问，提升了一定的性能，但是高并发下性能还是不够强</p></li><li><p>JDK1.8之后：取消分段锁机制，回归一个大数组的方式，采用CAS + synchronized，数据结构和Hashmap一样，使用数组 + 链表 + 红黑树</p></li></ul><blockquote><p>【分析】：JDK1.8之后，锁的粒度控制到了数组的每一个元素，当多线程对数组同一个元素进行操作比如put等，会先通过 CAS 的方式让同一时间只有一个线程A成功执行 CAS ，然后进行put ，其他线程就会使用synchronized 关键字对这个数组元素对象加锁，串行的等待线程A执行完毕后继续获取锁，进行后续操作</p></blockquote><p>【总结】：JDK1.8之后的ConcurrentHashMap，当多个线程对数组不同位置的元素进行操作时，可以并发操作；如果多个线程对数组统一位置元素进行操作时，则加锁串行化处理</p><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/XajTc9dqNNi_ByLR2B_J3A">为什么ConcurrentHashMap的读操作不需要加锁？</a><br>2：<a href="https://mp.weixin.qq.com/s/wZWPg2ldcG1QwHbk6oPOWQ">面试官邪魅一笑: 你说说 Java8 的 ConcurrentHashMap ？</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之ConcurrentHashMap&quot;&gt;&lt;/a&gt;并发
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://xuyk.top/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之说说synchronized</title>
    <link href="http://xuyk.top/posts/interview-synchronized.html"/>
    <id>http://xuyk.top/posts/interview-synchronized.html</id>
    <published>2021-01-10T02:04:00.000Z</published>
    <updated>2021-01-24T07:10:44.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之synchronized"><a href="#并发编程灵魂拷问系列之synchronized" class="headerlink" title="并发编程灵魂拷问系列之synchronized"></a>并发编程灵魂拷问系列之synchronized</h1><h2 id="1-什么是synchronized，JDK1-6前后变化？"><a href="#1-什么是synchronized，JDK1-6前后变化？" class="headerlink" title="1.什么是synchronized，JDK1.6前后变化？"></a>1.什么是synchronized，JDK1.6前后变化？</h2><p>我们可以知道，并发问题一般都是因为 <strong>多个线程同时操作同一个共享数据</strong> 所造成的，解决办法就是加锁，例如 <strong>synchronized加锁</strong></p><ul><li>JDK1.6之前：synchronized使用的是操作系统的互斥锁（底层操作系统的mutex相关指令），因为需要在用户态和内核态进行切换，开销很大，导致并发激烈时性能很差</li><li>JDK1.6之后：进行了锁优化，比如锁升/分级、锁消除、锁粗化等，性能大幅提高，推荐使用</li></ul><h2 id="2-那synchronized底层原理是什么呢？"><a href="#2-那synchronized底层原理是什么呢？" class="headerlink" title="2.那synchronized底层原理是什么呢？"></a>2.那synchronized底层原理是什么呢？</h2><p>synchronized属于 <strong>非公平锁</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>synchronized是基于Monitor来实现同步的，每一个对象都有对应着一个Monitor，如果需要加锁，则必须获取monitor的lock锁。</p><p>monitor锁是可重入锁，有一个计数器，当进入同步代码块时，执行monitorenter指令，计数器+1，退出一个同步代码块时，执行monitorexit指令，计数器-1；当发生对同一对象多次加锁时，计数器加减多次</p><ol><li>对于同步方法，JVM采用 <strong>ACC_SYNCHRONIZED</strong> 标记符来实现同步。</li><li>对于同步代码块。JVM采用 <strong>monitorenter</strong> 、<strong>monitorexit</strong> 两个指令来实现同步。</li></ol><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/synchronized-monitor.jpg" alt=""></p><h2 id="3-什么是锁升-分级？"><a href="#3-什么是锁升-分级？" class="headerlink" title="3.什么是锁升/分级？"></a>3.什么是锁升/分级？</h2><blockquote><p>synchronized 一般来说都对 <strong>对象</strong> 进行加锁</p></blockquote><p>这个可以从对象入手分析，对象在 <strong>堆</strong> 的存储中存有对象头，对象头中的 <strong>Mark Word</strong> 存储着对象的运行时数据，包括对象的hashcode、对象持有的锁等，当中锁从状态进行了分类：</p><p><strong>无锁、偏向锁、轻量级锁、重量级锁</strong>。</p><p>线程获取锁，会根据锁竞争激烈程度进行锁升级来提高性能，<strong>锁可以升级但是不能降级</strong>。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/synchronized-lock-update1.png" alt=""></p><p><strong>总结：</strong></p><ol><li><p><strong>偏向锁</strong>：作者认为很多情况都是一个线程多次获取锁，这种情况加锁解锁最好不需要消耗太多资源，引入了偏向锁。当一个线程获取到锁，锁进进入了偏向模式（偏向锁），下一次该线程获取锁时，不需要额外进行额外进行操作，减少消耗。<strong>所以适合没有多线程来竞争锁的场景</strong></p></li><li><p><strong>轻量级锁</strong>：当其他线程来竞争原本偏向线程A的偏向锁时，等线程A释放锁后，该锁的偏向锁被撤销，升级为轻量级锁（只有发生了多线程之间的锁竞争，该锁会从偏向锁升级为轻量级锁）。<br>轻量级锁生效后，当线程X持有锁时，线程Y获取该对象的锁被线程X持有，则进行 <strong>自旋</strong> （循环使用CAS来获取锁）</p></li><li><p><strong>重量级锁</strong>：当线程Y自旋超过一定时间或者次数，锁会升级为重量级锁，防止CPU空转（自旋过久）。升级为重量级锁后，线程Y不在主动获取锁，而是线程X释放锁之后通知线程Y去获取锁，线程Y从自旋变为阻塞。</p></li></ol><p>简单来说：</p><ul><li><strong>偏向锁</strong>：在Mark Word 记录线程ID进行比对</li><li><strong>轻量级锁</strong>：通过CAS + 自旋的方式竞争</li><li><strong>重量级锁</strong>：使用monitor对象，阻塞</li></ul><h2 id="4-什么是锁消除？"><a href="#4-什么是锁消除？" class="headerlink" title="4.什么是锁消除？"></a>4.什么是锁消除？</h2><p>前文可知，线程安全问题条件之一是存在共享数据，但是当 <strong>synchronized</strong> 修饰的代码块中不存在共享数据时，JDK会通过逃逸分析判断这段代码不会有线程安全问题，自动消除这个锁</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>someMethod方法中的object是局部变量，当多个线程进入方法，会new一个新的object，不存在共享数据，所以会进行 <strong>锁消除</strong></p></blockquote><h2 id="5-什么是锁粗化？"><a href="#5-什么是锁粗化？" class="headerlink" title="5.什么是锁粗化？"></a>5.什么是锁粗化？</h2><p>将多个加锁解锁操作连接在一起，JDK会根据优化策略将其扩展成一个范围更大的锁</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 粗化前</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do some thing</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 能够很快执行完毕，且无需同步的代码</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 粗化后：</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//进行锁粗化：整合成一次锁请求、同步、释放</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do some thing</span>        <span class="token comment" spellcheck="true">// 能够很快执行完毕，且无需同步的代码</span>        <span class="token comment" spellcheck="true">// do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-synchronized都可以修饰哪些对象？"><a href="#6-synchronized都可以修饰哪些对象？" class="headerlink" title="6.synchronized都可以修饰哪些对象？"></a>6.synchronized都可以修饰哪些对象？</h2><ul><li>1.修饰实例方法：锁定的是this对象（类锁）</li><li>2.修饰静态方法：锁定的是class对象（对象内置锁）</li><li>3.修饰代码块：锁定任意指定的对象</li></ul><h2 id="7-synchronized有什么缺点呢"><a href="#7-synchronized有什么缺点呢" class="headerlink" title="7.synchronized有什么缺点呢"></a>7.synchronized有什么缺点呢</h2><ul><li>1.锁的粒度还是比较大的</li><li>2.锁竞争激烈情况下，可能发生死锁</li><li>3.锁竞争激烈时，因为串行化，多个线程排队竞争锁效率不会太高</li></ul><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/8UtdfawQ">synchronized和锁</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/e_fYFWK5Qnxjmz6Abi7uqw">由浅入深逐步了解 Synchronized</a><br>4：<a href="https://mp.weixin.qq.com/s/v1XgT2X4IuF3_WNqeUVhVA">全网最细：17张图带你秒杀synchronized关键字</a><br>5:<a href="https://mp.weixin.qq.com/s/wwGvEt_3x9oHORwuXDqX5g">【对线面试官】synchronized</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之synchronized&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之synchronized&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之synchronized&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之synchr
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="synchronized" scheme="http://xuyk.top/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之HashMap</title>
    <link href="http://xuyk.top/posts/interview-hmap.html"/>
    <id>http://xuyk.top/posts/interview-hmap.html</id>
    <published>2021-01-06T09:00:00.000Z</published>
    <updated>2021-01-28T01:47:07.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之HashMap"><a href="#并发编程灵魂拷问系列之HashMap" class="headerlink" title="并发编程灵魂拷问系列之HashMap"></a>并发编程灵魂拷问系列之HashMap</h1><h2 id="1-你知道hashmap底层的数据结构是什么"><a href="#1-你知道hashmap底层的数据结构是什么" class="headerlink" title="1.你知道hashmap底层的数据结构是什么"></a>1.你知道hashmap底层的数据结构是什么</h2><ol><li>JDK1.8之前：数组 + 链表</li><li>JDK1.8之后：数组 + 链表 + 红黑树</li></ol><h2 id="2-hashmap在JDK1-8前后有什么区别"><a href="#2-hashmap在JDK1-8前后有什么区别" class="headerlink" title="2.hashmap在JDK1.8前后有什么区别"></a>2.hashmap在JDK1.8前后有什么区别</h2><ol><li>JDK1.8之前数据结构为数组+链表，JDK1.8+采用数组+链表+红黑树</li></ol><blockquote><p>红黑树查询速度更快，最坏情况的时间复杂度为O(logn)</p></blockquote><ol start="2"><li>JDK1.8之前向链表插入数据时采用头插法，JDK1.8+采用尾插法</li></ol><blockquote><p>因为头插法在多线程环境下，在扩容时resize，也就是节点重新分配位置，有可能会发生A-&gt;B-&gt;A这样的环形链表，导致下次取值时会发生无限循环。尾插法则不会</p></blockquote><ol start="3"><li>JDK1.8之前计算hash值做了四次移位和四次异或，JDK1.8+只用一次异或来提升效率</li></ol><blockquote><p>可能觉得一次扰动就足够了，多了边际作用不大</p></blockquote><ol start="4"><li>JDK1.8之前扩容的时候需要对原数组中的元素进行重新hash定位在新数组的位置，JDK1.8+采用更简单的判断逻辑，位置不变或索引+旧容量大小</li></ol><blockquote><p>扩容为原来数组的两倍，在计算数组位置的二进制掩码中只是高位多了个1，效果等于加上旧数组的长度</p></blockquote><h2 id="3-jdk1-8后hashmap链表和红黑树如何切换"><a href="#3-jdk1-8后hashmap链表和红黑树如何切换" class="headerlink" title="3.jdk1.8后hashmap链表和红黑树如何切换"></a>3.jdk1.8后hashmap链表和红黑树如何切换</h2><ol><li>链表 -&gt; 红黑树： 插入数据时，当链表长度大于等于8，并且数组长度大于等于64，该链表转化为红黑树</li><li>红黑树 -&gt; 链表：长度小于等于6，该红黑树转化成链表</li></ol><h2 id="4-hashmap插入链表是怎么插入的"><a href="#4-hashmap插入链表是怎么插入的" class="headerlink" title="4.hashmap插入链表是怎么插入的"></a>4.hashmap插入链表是怎么插入的</h2><ol><li>JDK1.8之前：头插法，因为当时作者认为新插入的元素往往更可能被查找</li><li>JDK1.8之后：尾插法</li></ol><blockquote><p>【追问】那为什么要改成尾插法呢？</p></blockquote><p>因为头插法在多线程环境下，在扩容时resize，也就是节点重新分配位置，有可能会发生A-&gt;B-&gt;A这样的环形链表，导致下次取值时会发生无限循环。</p><p>尾插法在扩容时会保持链表原本的顺序，就不会出现环的问题</p><blockquote><p>【那么hashmap在JDK1.8之后还线程安全吗】</p></blockquote><p>不安全，例如多线程情况下的put操作，就无法保证上一秒put的值，与下一秒get的还是原值（里面就有很多某属性++，这些都有线程安全问题）</p><blockquote><p>【那有什么办法解决这个线程安全的问题】</p></blockquote><ol><li>可以使用 hashtable ，但是因为直接在方法上锁，导致性能低下所以不考虑</li><li>可以使用 concurrentHashMap </li></ol><h2 id="5-jdk1-8对hash算法和寻址算法是如何优化的？"><a href="#5-jdk1-8对hash算法和寻址算法是如何优化的？" class="headerlink" title="5.jdk1.8对hash算法和寻址算法是如何优化的？"></a>5.jdk1.8对hash算法和寻址算法是如何优化的？</h2><p>我们在put一个kv时，会进行(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)运算（key为null则取0），也就是<strong>拿key的hash值高16位和低16位做异或运算</strong>；</p><p>【优化】：通过对key的hashcode和hashcode右移16位做<strong>异或运算</strong>，也就是把key的hashcode的高16位和低16位做异或运算，通过这样算出的值会<strong>保留高低16位的特征</strong>，尽可能让结果的低16位值不一样，</p><blockquote><p>【hash算法优化】：hash值高低16为进行异或计算，可以同时保留高低16位的特征，减少hash冲突</p></blockquote><p>接着对异或结果进行 “取模运算” ，定位到数组中具体的某个位置上</p><p>【优化】：因为取模运算性能比较差，所以使用 <strong>(n-1) &amp; hash</strong> 来代替取模运算，这里的&amp;运算一般来讲就都是低16位的运算（因为n是数组长度，一般n-1都很小，换算成32位前16位基本为0），所以要保证hash算法后算出来的hash值要尽可能不一样</p><blockquote><p>【寻址算法优化】：同样效果，则使用性能更高的与运算也就是 (n-1)&amp;hash 来进行寻址</p></blockquote><h2 id="6-HashMap如何解决hash碰撞问题的？"><a href="#6-HashMap如何解决hash碰撞问题的？" class="headerlink" title="6.HashMap如何解决hash碰撞问题的？"></a>6.HashMap如何解决hash碰撞问题的？</h2><p>先说一下发生场景：</p><p>在put\get操作中，当两个key-value键值对通过hash算法异或和取模运算之后，定位到的数组位置还是一样时，我们称之为发生了hash碰撞\hash冲突</p><p>【解决方法】<br>hashmap通过在该数组位置挂上链表+红黑树的方式来解决hash碰撞的问题。当发生hash碰撞时，后面的kv会在定位到链表的下个空置节点</p><p>但是如果链表长度过长，极端情况下查询某个值的时间复杂度就为O(n)，性能比较差，所以hashmap在链表达到8（同时数组长度大于64）后会把链表转换成红黑树（时间复杂度为O(logn)），性能会好一些</p><blockquote><p>红黑树长度达到6或6以下后，会由红黑树转为链表</p></blockquote><h2 id="7-hashmap是如何扩容的"><a href="#7-hashmap是如何扩容的" class="headerlink" title="7.hashmap是如何扩容的"></a>7.hashmap是如何扩容的</h2><ol><li>当hashmap数组长度达到 负载因子（默认0.75）* 当前数组容量时，会进行扩容，扩容到原来的2倍，扩容过程涉及到rehash、复制数据等</li><li>当某一链表长度达到8但是数组长度小于64时，会进行扩容</li></ol><p>具体扩容：创建新的数组，将原数组重新hash并且分散到新数组中，可能 位置不变 或 索引+旧容量大小</p><blockquote><p>数组长度变化，取模（与运算）后的结果也相应发生改变。rehash过程中使用 (n-1) &amp; hash(key) 代替取模操作，提高了性能</p></blockquote><h2 id="8-HashMap的主要参数都有哪些？"><a href="#8-HashMap的主要参数都有哪些？" class="headerlink" title="8. HashMap的主要参数都有哪些？"></a>8. HashMap的主要参数都有哪些？</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap-params.jpg" alt=""></p><blockquote><p>摘自公众号【Java3y】</p></blockquote><h2 id="9-阐述一下HashMap在JDK7的环产生原理"><a href="#9-阐述一下HashMap在JDK7的环产生原理" class="headerlink" title="9.阐述一下HashMap在JDK7的环产生原理"></a>9.阐述一下HashMap在JDK7的环产生原理</h2><p>因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；</p><p>A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap-ring.jpg" alt=""></p><blockquote><p>【参考链接】：<br>1：<a href="https:\mp.weixin.qq.com\s\0Gf2DzuzgEx0i3mHVvhKNQ">《吊打面试官》系列-HashMap</a><br>2：<a href="https:\mp.weixin.qq.com\s\ubwe-2U19Y7GQsIByYTWng">HashMap就是这么简单【源码剖析】</a><br>3：<a href="http:\xuyk.top\posts\hashmap.html">HashMap-链表散列</a><br>4：<a href="https:\zhuanlan.zhihu.com\p\125628540">一个HashMap跟面试官扯了半个小时</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之HashMap&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之HashMap&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之HashMap&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之HashMap&lt;/h1&gt;&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="HashMap" scheme="http://xuyk.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>一款自定义RPC框架 x-rpc</title>
    <link href="http://xuyk.top/posts/x-rpc.html"/>
    <id>http://xuyk.top/posts/x-rpc.html</id>
    <published>2021-01-05T01:20:00.000Z</published>
    <updated>2021-01-05T03:35:46.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x-rpc"><a href="#x-rpc" class="headerlink" title="x-rpc"></a>x-rpc</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>在微服务大行其道的2021，说到服务之间的通信，大家都会马上想到RPC（Remote Procedure Call Protocol）远程方法调用，也就是可以让我们调用远程第三方服务时能像调用本地方法一样简单快捷省事儿。其中被大家所熟知的就有SpringCloud中的Feign、Alibaba的Dubbo和谷歌的gRpc等。为了对这些框架有更深刻的了解，笔者自己尝试造了个轮子，也就是x-rpc。</p><p>x-rpc是一款基于 Netty+protostuff+Zookeeper 实现的 RPC 框架，框架大体结构参考的是dubbo：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/dubbo-architure.jpg" alt=""></p><blockquote><p>服务提供方（服务端）启动，向注册中心注册所要发布的服务列表；消费端（客户端）启动，向注册中心订阅/拉取所关心的服务，也就是进行服务发现；消费端发起请求，服务端响应。</p></blockquote><p>简单说明一下x-rpc的设计思路：</p><ol><li><strong>网络传输</strong> ：netty作为<strong>底层通信</strong>框架，能够在简化网络编程的同时压榨cpu，充分提高应用的性能，是网络通信框架的不二之选。</li><li><strong>注册中心</strong> ：天生就用来作为分布式系统下的注册中心、统一配置管理中心、命名服务中心等功能的zookeeper毋庸置疑承担了<strong>服务发现</strong>和<strong>服务注册</strong>的角色</li><li><strong>序列化</strong> ：因为JDK自带的序列化效率很低并且有安全问题，所有这里采用谷歌的protostuff负责<strong>数据包的序列化和反序列化</strong>，当然kryo、Marshalling也是不错的选择</li><li><strong>动态代理</strong> ： 使用动态代理可以屏蔽远程方法调用的细节比如网络传输。也就是说当你调用远程方法的时候，实际会通过代理对象来传输网络请求。</li><li><strong>负载均衡</strong>：这里采用的是客户端负载均衡，通过轮询对服务的每个服务端节点进行依次请求，避免单机压力过大，达到负载均衡效果。</li></ol><h2 id="2-计划列表"><a href="#2-计划列表" class="headerlink" title="2.计划列表"></a>2.计划列表</h2><p><strong>已优化列表</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 重用 Channel 避免重复连接服务端</li><li><input checked="" disabled="" type="checkbox"> 使用 zookeeper 进行服务发现与注册</li><li><input checked="" disabled="" type="checkbox"> 心跳链路检测</li><li><input checked="" disabled="" type="checkbox"> 使用 CompletableFuture 包装接收服务端返回结果</li><li><input checked="" disabled="" type="checkbox"> 客户端调用远程服务进行负载均衡，x-rpc默认使用<strong>轮询</strong>进行负载均衡</li><li><input checked="" disabled="" type="checkbox"> 集成spring</li></ul><p><strong>代办列表</strong></p><ul><li><input disabled="" type="checkbox"> 数据传输时的数据包重新设计：加入魔数（识别之用）、采用序列化方式编号等</li><li><input disabled="" type="checkbox"> 对数据包进行压缩，例如gzip压缩</li><li><input disabled="" type="checkbox"> SPI 机制<br>…</li></ul><h2 id="3-图解说明"><a href="#3-图解说明" class="headerlink" title="3.图解说明"></a>3.图解说明</h2><p>下面是整个x-rpc的代码架构，基于maven构建</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-projects-desc.png" alt=""></p><p>正常在使用过程中，遵循如下顺序：</p><p>1.服务端启动 -&gt; 2.客户端启动 -&gt; 3.客户端服务端整个请求流程（包括客户端发送请求 -&gt; 服务端响应请求 -&gt; 客户端处理响应数据）</p><p>我们就来一一剖析，进一步理解rpc底层大概都干了啥</p><h3 id="3-1-服务端启动"><a href="#3-1-服务端启动" class="headerlink" title="3.1 服务端启动"></a>3.1 服务端启动</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverStartup.jpg" alt=""></p><ol><li>【具体操作】：通过rpc自定义注解@RpcService（@RpcScan属性basePackages范围内）找到所要发布的服务列表，通过扫描注册的方式将服务实例注入到spring bean中</li><li>【具体操作】：在服务实例初始化前，每个注册在spring的实例都会通过zookeeper客户端Curator创建持久节点注册服务，保存服务名和服务端地址，并对该节点进行监听，发生变化时</li><li>【具体操作】：使用ConcurrentHashMap和Set缓存已注册的服务列表，用于后续客户端获取服务列表使用</li><li>【具体操作】：创建启动Netty服务端，异步监控启动结果，添加shutdownHook用于应用关闭释放资源，服务端pipeline用于请求/响应信息的编解码、客户端请求处理等</li></ol><h3 id="3-2-客户端启动"><a href="#3-2-客户端启动" class="headerlink" title="3.2 客户端启动"></a>3.2 客户端启动</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-clientStartup.jpg" alt=""></p><ol><li>【具体操作】：通过@RpcScan属性basePackages，把该范围内的标识spring注解的类注入至spring bean；在bean初始化后，为标识了@RpcReference的属性添加proxy代理实例，之后调用该属性方法时会调用代理类的invoke方法</li><li>pipeline用于请求/响应信息的编解码、服务端响应结果处理等</li></ol><h3 id="3-3-整个调用流程"><a href="#3-3-整个调用流程" class="headerlink" title="3.3 整个调用流程"></a>3.3 整个调用流程</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-wholeRequestProcess.jpg" alt=""></p><blockquote><p>【server/client pipeline】：netty中的调用链，用到了设计模式中的责任链模式</p></blockquote><h2 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4.运行项目"></a>4.运行项目</h2><h3 id="4-1-将项目-clone-至本地"><a href="#4-1-将项目-clone-至本地" class="headerlink" title="4.1 将项目 clone 至本地"></a>4.1 将项目 clone 至本地</h3><pre class="line-numbers language-java"><code class="language-java">git clone https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>xuyikai1<span class="token operator">/</span>x<span class="token operator">-</span>rpc<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-部署运行zookeeper-3-5-8，推荐使用docker"><a href="#4-2-部署运行zookeeper-3-5-8，推荐使用docker" class="headerlink" title="4.2 部署运行zookeeper 3.5.8，推荐使用docker"></a>4.2 部署运行zookeeper 3.5.8，推荐使用docker</h3><p>下载：</p><pre class="line-numbers language-java"><code class="language-java">docker pull zookeeper<span class="token operator">:</span><span class="token number">3.5</span><span class="token punctuation">.</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-java"><code class="language-java">docker run <span class="token operator">-</span>d <span class="token operator">--</span>name zookeeper <span class="token operator">-</span>p <span class="token number">2181</span><span class="token operator">:</span><span class="token number">2181</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>zookeeper:3.5.8</p><h3 id="4-3-使用-maven-命令-install-整个x-rpc项目"><a href="#4-3-使用-maven-命令-install-整个x-rpc项目" class="headerlink" title="4.3 使用 maven 命令 install 整个x-rpc项目"></a>4.3 使用 maven 命令 install 整个x-rpc项目</h3><p>这里使用IDEA进行操作：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-mavenInstall.png" alt=""></p><h3 id="4-4-启动服务端"><a href="#4-4-启动服务端" class="headerlink" title="4.4 启动服务端"></a>4.4 启动服务端</h3><p>运行 rpc-example-server 中的 RpcServerTest1的<code>main()</code>方法启动服务端</p><p>服务端启动成功如图：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverStartupSuccess.png" alt=""></p><p>zookeeper节点情况：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-prettyZoo.png" alt=""></p><blockquote><p>zookeeper client使用的是 <a href="https://github.com/vran-dev/PrettyZoo">prettyZoo</a></p></blockquote><h3 id="4-5-启动客户端-发送请求"><a href="#4-5-启动客户端-发送请求" class="headerlink" title="4.5 启动客户端/发送请求"></a>4.5 启动客户端/发送请求</h3><p>运行 rpc-example-client 中的 RpcServerTest1的<code>main()</code>方法启动服务端</p><p>客户端启动/发送数据情况：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-clientStartupSuccess.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverReceiveRequestSuccess.png" alt=""></p><blockquote><p>这里测试demo中客户端发送了两次请求</p></blockquote><h2 id="5-源码"><a href="#5-源码" class="headerlink" title="5.源码"></a>5.源码</h2><p><a href="https://github.com/xuyikai1/x-rpc">GitHub - xuyikai1/x-rpc</a></p><h2 id="6-感谢"><a href="#6-感谢" class="headerlink" title="6.感谢"></a>6.感谢</h2><p>项目很多细节都是参考 javaGuide 的<a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a>，在这里表示感谢</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x-rpc&quot;&gt;&lt;a href=&quot;#x-rpc&quot; class=&quot;headerlink&quot; title=&quot;x-rpc&quot;&gt;&lt;/a&gt;x-rpc&lt;/h1&gt;&lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;
      
    
    </summary>
    
    
      <category term="rpc" scheme="http://xuyk.top/categories/rpc/"/>
    
    
      <category term="rpc" scheme="http://xuyk.top/tags/rpc/"/>
    
      <category term="netty" scheme="http://xuyk.top/tags/netty/"/>
    
      <category term="protostuff" scheme="http://xuyk.top/tags/protostuff/"/>
    
      <category term="zookeeper" scheme="http://xuyk.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>ShutdownHook钩子</title>
    <link href="http://xuyk.top/posts/shutdownHook.html"/>
    <id>http://xuyk.top/posts/shutdownHook.html</id>
    <published>2021-01-01T07:40:00.000Z</published>
    <updated>2021-01-05T03:28:02.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用钩子shutdownHook优雅关闭资源"><a href="#使用钩子shutdownHook优雅关闭资源" class="headerlink" title="使用钩子shutdownHook优雅关闭资源"></a>使用钩子shutdownHook优雅关闭资源</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>这是一个笔者在造rpc轮子的时候诞生的需求，也是一个挺细节的小知识点。故写一篇blog用于记录。</p><p>这里先来简单讲一下rpc。rpc，远程方法调用，他旨在屏蔽了很多细节让我们调用远程方法和调用本地方法一样简单，目前存在的rpc框架就有<strong>dubbo</strong>、<strong>gRpc</strong>等</p><blockquote><p>想想平时对接第三方api时是不是经历http请求、序列化、拆箱校验、数据标准化装箱等操作呢</p></blockquote><p>而rpc在使用时也涉及道诸多系统资源的使用，例如线程池、注册中心（zookeeper等）等，当rpc服务端（服务提供方）停止服务时，是否也应该释放这些资源呢？</p><p>结果是必然的。想到这一层，需求就诞生了，经过多方寻找，类似于git + jenkins上的webHook，也就是shutdownHook钩子浮出水面</p><h2 id="2-shutdownHook"><a href="#2-shutdownHook" class="headerlink" title="2.shutdownHook"></a>2.shutdownHook</h2><p>这是JVM本身提供的功能，当 JVM 接受到系统的关闭通知之后，调用 ShutdownHook 内的方法，用以完成清理操作，从而平滑的退出应用，下面是示例代码：</p><p><strong>CustomShutdownHook.class</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomShutdownHook</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> CustomShutdownHook CUSTOM_SHUTDOWN_HOOK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CustomShutdownHook <span class="token function">getCustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> CUSTOM_SHUTDOWN_HOOK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">releaseResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"addShutdownHook for clearAll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addShutdownHook</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 1.删除服务端注册信息</span>            ZookeeperClient<span class="token punctuation">.</span><span class="token function">clearRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 2.关闭所有线程池</span>            ThreadPoolExecutorUtils<span class="token punctuation">.</span><span class="token function">shutDownAllThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>自定义的shutdownHook，用于关闭服务端在zookeeper上注册的信息以及线程池资源</p></blockquote><p><strong>RpcServer.class</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 校验</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 添加JVM钩子 用于应用关闭时 自动释放资源</span>        CustomShutdownHook<span class="token punctuation">.</span><span class="token function">getCustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">releaseResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 启动服务端</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>服务端启动时add自定义的ShutDownHook</p></blockquote><p><strong>关闭应用</strong></p><p>此方式支持在以下几种场景优雅停机:</p><ul><li><p>1.程序正常退出</p></li><li><p>2.使用System.exit()</p></li><li><p>3.终端使用Ctrl+C</p></li><li><p>4.使用Kill pid干掉进程</p></li></ul><h2 id="3-Tips"><a href="#3-Tips" class="headerlink" title="3.Tips"></a>3.Tips</h2><blockquote><p>摘自：<a href="https://zhuanlan.zhihu.com/p/82350423">Java中使用shutdownHook的一些注意事项</a></p></blockquote><p><strong>1. 不要使用kill -9来结束你的应用程序</strong></p><p>kill -9是操作系统的终极杀器，如果你使用kill -9的话，应用程序是没有任何发言权的，它只能选择默默退出，几乎可以肯定，shutdownHook不会被调用。</p><p><strong>2. shutdownHook涉及的方法应该尽量的短</strong></p><p>这个可能和操作系统有关系，不同的操作系统可能有不同的差异：</p><blockquote><p>When a computer shuts down, the final stage of the shutdown process sends every remaining process a SIGTERM, gives those processes a few seconds grace, then sends them a SIGKILL.</p></blockquote><p>也就是说，如果shutdownHook过长，可能方法还没执行完，进程就被操作系统强制杀掉了，这一点在addShutdownHook()的文档上也有提及:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">*</span> <span class="token operator">&lt;</span>p<span class="token operator">></span> Shutdown hooks should also finish their work quickly<span class="token punctuation">.</span>  When a<span class="token operator">*</span> program invokes <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> #exit exit<span class="token punctuation">}</span> the expectation is<span class="token operator">*</span> that the virtual machine will promptly shut down and exit<span class="token punctuation">.</span>  When the<span class="token operator">*</span> virtual machine is terminated due to user logoff or system shutdown the<span class="token operator">*</span> underlying operating system may only allow a fixed amount of time in<span class="token operator">*</span> which to shut down and exit<span class="token punctuation">.</span>  It is therefore inadvisable to attempt any<span class="token operator">*</span> user interaction or to perform a <span class="token keyword">long</span><span class="token operator">-</span>running computation in a shutdown<span class="token operator">*</span> hook<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. shutdownHook的方法应该是线程安全的</strong></p><p>这是因为，用户可能多次发送信号导致方法被不同的线程被多次调用，关于这一点文档也有说明：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">*</span> They should<span class="token punctuation">,</span> in<span class="token operator">*</span> particular<span class="token punctuation">,</span> be written to be thread<span class="token operator">-</span>safe and to avoid deadlocks insofar<span class="token operator">*</span> as possible<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>4. 关于shutdownHook方法的异常</strong></p><p>shutdownHook调用过程中产生的所有异常都会被忽略掉并且可能不会输出任何提示信息，因此程序可能蕴含了一个久久不能被发现的BUG导致你的shutdownHook无法被执行，在调用shutdownHook的过程中，一定要仔细检查你的代码，保证正确性。</p><p><strong>5. 某些场景下要提供at most once的保证</strong></p><p>这点其实是接第三点说的，就是你的shutdownHook可能被调用多次，但其实关闭一次就够了，多次调用可能会引发一些意想不到的异常。比如KafkaStream的close方法，就提供了这样的保证：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit timeUnit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Stopping Streams client with timeoutMillis = {} ms."</span><span class="token punctuation">,</span> timeUnit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>KafkaStreams<span class="token punctuation">.</span>State<span class="token punctuation">.</span>PENDING_SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Already in the pending shutdown state, wait to complete shutdown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ....</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用CAS操作来做这样的检查：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>ACTIVE<span class="token punctuation">,</span> CLOSED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// close here</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>【参考链接】：<br>1：<a href="https://zhuanlan.zhihu.com/p/340284353">微服务项目优雅上线、下线小技巧，你学废了吗</a><br>2：<a href="https://zhuanlan.zhihu.com/p/82350423">Java中使用shutdownHook的一些注意事项</a><br>3：<a href="https://zhuanlan.zhihu.com/p/86392065">ShutdownHook- Java 优雅停机解决方案</a><br>4：<a href="https://zhuanlan.zhihu.com/p/159298442">SpringBoot 2.3.0正式发布：优雅停机，配置文件位置新特性一览</a><br>5：<a href="https://zhuanlan.zhihu.com/p/265806389">Spring Boot 系列：最新版优雅停机详解</a><br>6：<a href="https://zhuanlan.zhihu.com/p/336252174">回调方法？钩子方法？模板模式？</a><br>7：<a href="https://mp.weixin.qq.com/s/EgbqwZ6BL-IJubr_Co4ZEg">拒绝 kill -9， SpringBoot 优雅停机详解！</a><br>8：<a href="https://blog.csdn.net/caide3/article/details/108782865">Java程序优雅关闭的两种方法</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用钩子shutdownHook优雅关闭资源&quot;&gt;&lt;a href=&quot;#使用钩子shutdownHook优雅关闭资源&quot; class=&quot;headerlink&quot; title=&quot;使用钩子shutdownHook优雅关闭资源&quot;&gt;&lt;/a&gt;使用钩子shutdownHook优雅关闭
      
    
    </summary>
    
    
      <category term="日常工作应用" scheme="http://xuyk.top/categories/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="shutdownHook" scheme="http://xuyk.top/tags/shutdownHook/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之自动配置原理</title>
    <link href="http://xuyk.top/posts/SpringBoot-autoConfiguration.html"/>
    <id>http://xuyk.top/posts/SpringBoot-autoConfiguration.html</id>
    <published>2020-12-08T09:24:00.000Z</published>
    <updated>2021-01-05T01:15:24.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot之自动配置原理"><a href="#SpringBoot之自动配置原理" class="headerlink" title="SpringBoot之自动配置原理"></a>SpringBoot之自动配置原理</h1><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h2><p>创建SpringBoot项目时，都会默认创建一个Application启动类，并且标注着<code>@SpringBootApplication</code>注解。深入探究会发现<code>@SpringBootApplication</code>注解除了自定义注解经常出现的元注解外，主要还有三个注解标注：<code>@SpringBootConfiguration</code>、<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>，这三个注解可以说就是入口前的三把钥匙了，但是钥匙只有一把，所以我们不妨跟着其中的注释一一整理一番</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/SpringBootApplication.png" alt="SpringBootApplication"></p><blockquote><p><code>@SpringBootConfiguration</code>：再进入一层会发现就是我们配置类常用注解<code>@Configuration</code>，目的是<strong>使用JavaConfig的配置方式来代替XML的繁琐配置</strong></p></blockquote><blockquote><p><code>@ComponentScan</code>：扫描注解，默认是扫描当前类下的package。将Spring一些例如<code>@Controller</code>/<code>@Service</code>/<code>@Component</code>/<code>@Repository</code>等注解加载到IOC容器中。（备注：<code>@EnableAutoConfiguration</code>中的<code>@AutoConfigurationPackage</code>则是用来扫描一些其他组件注解的，比如Spring Data Jpa中的<code>@Entity</code>注解等）</p></blockquote><blockquote><p><code>@EnableAutoConfiguration</code>：自动配置核心注解，下文详细分析</p></blockquote><h2 id="2-EnableAutoConfiguration实现自动配置"><a href="#2-EnableAutoConfiguration实现自动配置" class="headerlink" title="2.@EnableAutoConfiguration实现自动配置"></a>2.<code>@EnableAutoConfiguration</code>实现自动配置</h2><blockquote><p>我们通过代码一步步抽丝剥茧</p></blockquote><h3 id="2-1-EnableAutoConfiguration注解"><a href="#2-1-EnableAutoConfiguration注解" class="headerlink" title="2.1 EnableAutoConfiguration注解"></a>2.1 EnableAutoConfiguration注解</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/EnableAutoConfiguration-annotation.png" alt="EnableAutoConfiguration"></p><blockquote><p>排除元注解和前面我们解释过的<code>@AutoConfigurationPackage</code>注解，可以看出，重点在于<code>@Import(AutoConfigurationImportSelector.class)</code>上。</p></blockquote><h3 id="2-2-自动配置链路分析"><a href="#2-2-自动配置链路分析" class="headerlink" title="2.2 自动配置链路分析"></a>2.2 自动配置链路分析</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/selectImports.png" alt="AutoConfigurationImportSelector.selectImports"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/getAutoConfigurationEntry.png" alt="getAutoConfigurationEntry"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/getCandidateConfigurations.png" alt="getCandidateConfigurations"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/loadFactoryNames.png" alt="SpringFactoriesLoader.loadFactoryNames"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring.factories.path.png" alt="/spring.factories.path"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring.factories.content.png" alt="spring.factories.content"></p><p>从上图和备注我们大致就可以理清自动配置的思路了，通过<strong>自动装配导入选择器</strong><code>AutoConfigurationImportSelector.class</code>来获取候选的一些自动配置项列表，这些自动配置项（127项）都以key为EnableAutoConfiguration统一存储在<strong>spring-boot-autoconfigure-x.x.x.x.jar的META-INF/spring.fatocies中</strong>。</p><h3 id="2-3-配置自动装配加载"><a href="#2-3-配置自动装配加载" class="headerlink" title="2.3 配置自动装配加载"></a>2.3 配置自动装配加载</h3><p>当然这些配置并不是全部127项都加载进去，而是按需分配，开发人员可以通过<code>@SpringBootApplication</code>的<strong>exclude属性</strong>来排除指定的配置项，再根据默认配置的<code>getConfigurationClassFilter()</code>方法获取到的过滤器过滤掉了，最后剩下23个默认配置项</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/Application-scanPackages-exclude.png" alt=""></p><blockquote><p><code>scanBasePackages</code>：扫描注解，默认是扫描当前类下的package。将Spring一些例如@Controller/@Service/@Component/@Repository等注解加载到IOC容器中。<br><code>exclude</code>：排除特定的自动配置类</p></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><ul><li>自动配置的核心是<code>@EnableAutoConfiguration</code>，SpringBoot在启动时会用SPI机制来加载spring.factories中的自动配置项，然后根据开发者的配置和默认配置筛选保留对应的配置进行加载。</li><li>自动配置功能保证了SpringBoot开箱即用的特点，省心省事</li></ul><blockquote><p>【参考链接】：<br>1：<a href="https://zhuanlan.zhihu.com/p/163685081">面试高频题：springboot自动装配的原理你能说出来吗？</a><br>2：<a href="https://zhuanlan.zhihu.com/p/55637237">SpringBoot自动配置原理</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot之自动配置原理&quot;&gt;&lt;a href=&quot;#SpringBoot之自动配置原理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot之自动配置原理&quot;&gt;&lt;/a&gt;SpringBoot之自动配置原理&lt;/h1&gt;&lt;h2 id=&quot;1-分析&quot;
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://xuyk.top/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://xuyk.top/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
