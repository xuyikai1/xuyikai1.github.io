<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寒暄</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xuyk.top/"/>
  <updated>2021-01-25T15:58:16.596Z</updated>
  <id>http://xuyk.top/</id>
  
  <author>
    <name>Xuyk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring灵魂拷问系列之简单理一下SpringMVC流程</title>
    <link href="http://xuyk.top/posts/interview-springmvc.html"/>
    <id>http://xuyk.top/posts/interview-springmvc.html</id>
    <published>2021-01-25T15:54:00.000Z</published>
    <updated>2021-01-25T15:58:16.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之简单理一下SpringMVC流程"><a href="#Spring灵魂拷问系列之简单理一下SpringMVC流程" class="headerlink" title="Spring灵魂拷问系列之简单理一下SpringMVC流程"></a>Spring灵魂拷问系列之简单理一下SpringMVC流程</h1><p> <img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringMVC-structure.jpg" alt=""></p><p>SpringMVC大体流程：</p><ol><li>tomcat工作线程将请求转发给Spring MVC框架的<strong>中央控制器DispatcherServlet</strong></li><li>中央控制器根据请求信息做相关的<strong>适配</strong>和<strong>映射</strong>，将请求转发到对应Controller</li><li>根据<code>@RequestMapping</code>来<strong>定位</strong>和<strong>调用</strong>到http请求对应的处理方法（处理器映射器、处理器适配器、处理器）</li><li>业务执行完毕后会有一个返回值。（1）以前：会通过JSP/模版引擎，将前端页面存放在后端工程中，返回值这里就是页面模版的名字，Spring MVC根据返回的数据对象对html页面进行渲染；（2）如今，前后端分离，返回值为json字符串，前端会根据返回的json数据，对html页面进行渲染</li><li>将渲染后的html页面返回给浏览器进行显示</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之简单理一下SpringMVC流程&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之简单理一下SpringMVC流程&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之简单理一下SpringMVC流程&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SpringMVC" scheme="http://xuyk.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游</title>
    <link href="http://xuyk.top/posts/interview-springcloud.html"/>
    <id>http://xuyk.top/posts/interview-springcloud.html</id>
    <published>2021-01-25T15:54:00.000Z</published>
    <updated>2021-01-27T08:10:19.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游"><a href="#Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游" class="headerlink" title="Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游"></a>Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游</h1><p><strong>SpringCloud组件</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringCloud-component.png" alt=""></p><p><strong>一个请求怎么在SpringCloud中遨游</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringCloud-structure.jpg" alt=""></p><ol><li>在Spring Cloud中，每个服务和组件都需要在 <strong>Eureka注册中心</strong> 注册，注册成功后，Eureka也会主动发起 <strong>心跳检测来进行健康检查和信息同步</strong></li><li>服务启动时，会根据环境从配置中心中拉取对应配置来启动</li><li>浏览器发起请求，到达网关层，网关层根据 <strong>路由转发</strong> 到指定服务A（网关层还可起到限流、鉴权、负载均衡等作用）</li><li>如果服务A需要需要依赖服务B，则会通过 <strong>ribbon负载均衡策略</strong> 找到某一台服务B的实例，再通过 <strong>feign调用</strong> 实例服务，其中使用 <strong>hystrix</strong> 进行服务 <strong>降级/熔断</strong> </li><li>A服务执行业务完毕，返回数据给网关，网关返回浏览器/前端工程</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之一个请求怎么在Spri
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SpringCloud" scheme="http://xuyk.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring灵魂拷问系列之Spring基础拷问</title>
    <link href="http://xuyk.top/posts/interview-spring-base.html"/>
    <id>http://xuyk.top/posts/interview-spring-base.html</id>
    <published>2021-01-23T12:04:00.000Z</published>
    <updated>2021-01-23T12:04:06.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之Spring基础拷问"><a href="#Spring灵魂拷问系列之Spring基础拷问" class="headerlink" title="Spring灵魂拷问系列之Spring基础拷问"></a>Spring灵魂拷问系列之Spring基础拷问</h1><h2 id="0-面试连环炮"><a href="#0-面试连环炮" class="headerlink" title="0.面试连环炮"></a>0.面试连环炮</h2><p>Spring IOC和AOP的理解 -&gt; 动态代理 -&gt; JDK/Cglib动态代理 -&gt; Spring Bean线程安全 -&gt; Spring事务实现原理和事务传播机制</p><h2 id="1-说说对Spring-IOC的理解"><a href="#1-说说对Spring-IOC的理解" class="headerlink" title="1.说说对Spring IOC的理解"></a>1.说说对Spring IOC的理解</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-old-process.jpg" alt=""></p><p>以前的一套系统：<br>web服务器：绑定地址端口，负责接收请求<br>servlet：引入serviceImpl类来处理请求（doPost、doGet）</p><p>像这样每个servlet都新建一个serviceImpl服务类实例，导致耦合度很高，当需要换一个服务实现类时，每个地方都需要修改成新的类，导致改动、测试成本巨大</p><p>Spring IOC：<strong>控制反转，依赖注入，让系统的类与类之间解耦</strong></p><p>Tomcat启动Spring容器，扫描指定路径的包路径，所有加了Spring注解的类会被Spring容器初始和实例化Bean并且交给Spring容器管理，当某个地方使用到时，Spring容器会自动注入实例</p><blockquote><p>Spring MVC：核心Servlet、Filter，负责用户请求的转发，转发给对应的Controller，之后调用相应的服务类进行处理</p></blockquote><p>底层：通过反射来动态的构建对象实例</p><p>当改成Spring IOC解耦时，只需要修改service的实现类即可。这样的话，在具体请求过来时，Spring会根据反射动态生成实现类来处理请求了</p><h2 id="2-说说对Spring-AOP的理解"><a href="#2-说说对Spring-AOP的理解" class="headerlink" title="2.说说对Spring AOP的理解"></a>2.说说对Spring AOP的理解</h2><p><strong>核心技术：动态代理</strong></p><blockquote><p>不关心底层代码的实现逻辑，在此实现逻辑前后做一些公共的处理，例如事务处理、统计方法耗时等</p></blockquote><p>把代码公共/重复的代码抽取出来，比如日志、事务、通知等业务，做一个切面</p><h2 id="3-cglib动态代理和jdk动态代理的区别"><a href="#3-cglib动态代理和jdk动态代理的区别" class="headerlink" title="3.cglib动态代理和jdk动态代理的区别"></a>3.cglib动态代理和jdk动态代理的区别</h2><p>动态代理，动态的创建一个代理类和他的实例对象出来，在里面引用真正需要调用的类，代理类在此做一些增强（事务、日志等）</p><p>两者区别在于 <strong>生成动态代理类的方式</strong></p><p>Spring AOP使用的 <strong>JDK动态代理</strong> ，生成实现同个接口代理类，构造实例出来。当需要代理的类没有接口时，Spring AOP会改用 <strong>Cglib动态代理</strong> ，生成该类的子类（动态生成字节码），覆盖目标类的方法，在覆盖方法中进行增强</p><ol><li><strong>JDK动态代理</strong>：代理类实现 <strong>InvocationHandler</strong> 接口， <strong>Proxy</strong> 生成代理对象，当调用接口方法时，真正会调用的是代理类的 <strong>invoke</strong> 方法</li><li><strong>Cglib动态代理</strong>：代理类实现 <strong>MethodInterceptor</strong> 接口， <strong>Enhancer</strong> 生成代理对象，当调用类方法时，拦截器会拦截在方法前后进行增强（ <strong>intercept方法</strong> ）</li></ol><h2 id="4-Spring中的Bean是线程安全的吗"><a href="#4-Spring中的Bean是线程安全的吗" class="headerlink" title="4.Spring中的Bean是线程安全的吗"></a>4.Spring中的Bean是线程安全的吗</h2><p>Spring Bean的作用域：</p><ul><li><strong>singleton</strong>：默认，单例，只有一个实例</li><li><strong>prototype</strong>：为每个bean请求都提供一个实例</li><li><strong>request</strong>：为每个网络请求request创建一个实例，请求完成后被垃圾回收</li><li><strong>session</strong>：为每个session创建一个实例，请求完成后被垃圾回收</li><li><strong>global-session</strong>：标准的HTTP Session作用域</li></ul><blockquote><p>基本大部分时候我们都使用默认的singleton单例作用域</p></blockquote><p><strong>Spring Bean是线程不安全的</strong></p><blockquote><p>例如，bean中存在一个变量data（未被volatile修饰），多线程并发（多个请求同时发起同个服务）时，多个线程同时调用实例A的同一方法（该方法里存在data++），基于线程的工作内存和主内存不一定同步的机制，就会发生线程安全问题<br>如果不存在实例变量，逻辑处理只操作数据库的话，一般不会有线程安全问题</p></blockquote><h2 id="5-Spring的事务实现原理是什么？"><a href="#5-Spring的事务实现原理是什么？" class="headerlink" title="5.Spring的事务实现原理是什么？"></a>5.Spring的事务实现原理是什么？</h2><p>日常编码中，需要对代码逻辑增加事务，使用Transactional注解，Spring会通过AOP/动态代理的机制，对方法进行增强，织入事务，方法执行前开启事务，执行成功后提交事务，异常回滚事务</p><h2 id="6-能聊聊你对Spring事务的传播机制的理解吗？"><a href="#6-能聊聊你对Spring事务的传播机制的理解吗？" class="headerlink" title="6.能聊聊你对Spring事务的传播机制的理解吗？"></a>6.能聊聊你对Spring事务的传播机制的理解吗？</h2><p><strong>事务传播机制级别 - 最常用的是前4个</strong></p><ul><li><strong>REQUIRED</strong>：如果父方法没有事务，则新创建一个事务，存在事务则加入事务</li><li><strong>SUPPORTS</strong>：如果父方法存在事务则加入事务，当前没有事务，则不开启事务执行</li><li><strong>REQUIRES_NEW</strong>：无论当前父方法有没有事务，都新建一个事务，父方法存在事务时，两者事务是隔离开的</li><li><strong>NESTED</strong>：父方法存在事务，则嵌套事务执行（外层代码出错内层代码一起回滚，内层代码出错只有内层回滚），如果没有事务，按照REQUIRED属性执行</li><li><strong>MONDATORY</strong>：如果当前父方法存在事务则加入事务，当前没有事务，则抛异常</li><li><strong>NOT_SUPPORTED</strong>：强制要求非事务运行，如果父方法存在事务则挂起</li><li><strong>NEVER</strong>：非事务方式执行，如果存在事务会报错</li></ul><p><strong>方法A调用方法B，希望方法A出错只回滚方法A自己，不回滚方法B，该怎么办</strong></p><blockquote><p>选择事务传播机制的REQUIRES_NEW</p></blockquote><p><strong>方法A调用方法B，方法B只能回滚自己，方法A可以带着方法B一起回滚</strong></p><blockquote><p>NESTED嵌套事务</p></blockquote><h2 id="7-谈谈Spring-Boot的核心架构"><a href="#7-谈谈Spring-Boot的核心架构" class="headerlink" title="7.谈谈Spring Boot的核心架构"></a>7.谈谈Spring Boot的核心架构</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringBoot-structure.jpg" alt=""></p><p>在早期java web开发时，我们使用SSM框架那一套，需要打包部署到线上的tomcat上，请求到来，根据Spring MVC框架流程，来一一调用controller、service、dao层等。</p><p>早期开发时，我们也需要根据业务引入比较多的中间件技术，例如redis、elasticsearch、rabbitmq等，引入时配置比较繁琐复杂，例如引入jar包，编写xml配置文件，定义bean等</p><p><strong>SpringBoot</strong></p><ol><li>内嵌了tomcat，上线时可以直接部署启动；</li><li>通过 <strong>自动装配</strong> 的特性，在整合第三方组件时，只要引入相关的starter依赖，会自动做一些配置、定义生成对应bean等操作，只要配置必要的相关地址等配置，一定程度上降低了原先整合的成本，详细可看<a href="http://xuyk.top/posts/SpringBoot-autoConfiguration.html">SpringBoot之自动配置原理</a></li></ol><h2 id="8-Spring-Bean的生命周期"><a href="#8-Spring-Bean的生命周期" class="headerlink" title="8.Spring Bean的生命周期"></a>8.Spring Bean的生命周期</h2><p><strong>Spring Bean大致的生命周期</strong></p><p>实例化 -&gt; 初始化 -&gt; Spring容器管理下长期存活 -&gt; 销毁</p><h3 id="1-实例化Bean"><a href="#1-实例化Bean" class="headerlink" title="1.实例化Bean"></a>1.实例化Bean</h3><p>如果需要使用bean，需要先实例化</p><ul><li>对于 BeanFactory 容器，通过 createBean 进行实例化</li><li>对于 ApplicationContext 容器，通过 BeanDefinition 进行实例化</li></ul><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h3><p>当需要使用的bean依赖其他的bean，也需要把依赖的bean创建并且注入进来，注入的方式有两种</p><ul><li><strong>构造器注入</strong></li><li><strong>setter注入</strong></li></ul><h3 id="3-处理Aware接口"><a href="#3-处理Aware接口" class="headerlink" title="3.处理Aware接口"></a>3.处理Aware接口</h3><p>如果bean实现了 ApplicationContextAware 接口，Spring容器就会通过 <code>setApplicationContext(ApplicationContext)</code> 方法，把Spring容器传递给这个bean</p><h3 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4.BeanPostProcessor"></a>4.BeanPostProcessor</h3><p>bean实例化完成之后，如果想对Bean进行一些自定义的处理，那么可以让Bean实现 BeanPostProcessor 接口，将会调用<code>postProcessBeforeInitialization(Object obj,String s)</code>方法</p><blockquote><p>初始化之前</p></blockquote><h3 id="5-初始化initializingBean与init-method"><a href="#5-初始化initializingBean与init-method" class="headerlink" title="5.初始化initializingBean与init-method"></a>5.初始化initializingBean与init-method</h3><p>对bean进行初始化</p><h3 id="6-BeanPostProcessor"><a href="#6-BeanPostProcessor" class="headerlink" title="6.BeanPostProcessor"></a>6.BeanPostProcessor</h3><p>如果Bean实现 BeanPostProcessor 接口，将会调用<code>postProcessAfterInitialization(Object obj,String s)</code>方法</p><blockquote><p>由于发生在初始化完成之后，所以经常用于内存或者缓存的操作</p></blockquote><h3 id="7-DisposableBean"><a href="#7-DisposableBean" class="headerlink" title="7.DisposableBean"></a>7.DisposableBean</h3><p>当Bean不再被需要时，如果Bean实现了DisposableBean接口，会调用他的<code>destory()</code>方法</p><h3 id="8-destroy-method"><a href="#8-destroy-method" class="headerlink" title="8.destroy-method"></a>8.destroy-method</h3><p>如果bean配置的destroy-method属性，会自动调用配置的销毁方法</p><h2 id="9-能说说Spring中使用了哪些设计模式吗"><a href="#9-能说说Spring中使用了哪些设计模式吗" class="headerlink" title="9.能说说Spring中使用了哪些设计模式吗"></a>9.能说说Spring中使用了哪些设计模式吗</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><p>Spring IOC自己就是一个大工厂，把所有bean实例都放在Spring容器中，需要使用就直接从Spring容器中拿</p><h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>Spring Bean默认使用单例，保证类在运行期间只有一个实例对象，最常见的就是懒汉式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonTest singletonTest<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonTest <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    singletonTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singletonTest<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用双重检查 + synchronized关键字保证只生成一个实例，volatile保证不发生指令重排</p></blockquote><h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h3><p>主要涉及到的就是Spirng AOP，例如XXXAware那些某个增强类，创建动态代理对象实例，在调用被代理对象的方法时，会先执行代理类的增强代码，再执行方法代码，例如Spring Bean生命周期中，实现 ApplicationContextAware 接口后，Spring容器会把 ApplicationContext 注入到bean中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之Spring基础拷问&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之Spring基础拷问&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之Spring基础拷问&quot;&gt;&lt;/a&gt;Spring灵魂拷问系列之Spri
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring" scheme="http://xuyk.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之Java内存模型</title>
    <link href="http://xuyk.top/posts/interview-JMM.html"/>
    <id>http://xuyk.top/posts/interview-JMM.html</id>
    <published>2021-01-17T06:25:00.000Z</published>
    <updated>2021-01-17T06:25:11.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之Java内存模型"><a href="#并发编程灵魂拷问系列之Java内存模型" class="headerlink" title="并发编程灵魂拷问系列之Java内存模型"></a>并发编程灵魂拷问系列之Java内存模型</h1><h2 id="0-面试连环炮路径"><a href="#0-面试连环炮路径" class="headerlink" title="0.面试连环炮路径"></a>0.面试连环炮路径</h2><p>JMM（Java内存模型）-&gt; 原子性、可见性、有序性 -&gt; volatile和可见性 -&gt; volatile和有序性（指令重排+happens-before）-&gt; volatile和原子性 -&gt; volatile底层原理（内存屏障级别的原理）</p><h2 id="1-聊一下Java的内存模型"><a href="#1-聊一下Java的内存模型" class="headerlink" title="1.聊一下Java的内存模型"></a>1.聊一下Java的内存模型</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM-process.jpg" alt=""></p><p>volatile：共享变量修改时会强制刷新一下主内存的值</p><ol><li>线程1/2 read 主内存的共享变量， load 到工作内存中，此时读到的值都为0</li><li>线程1/2 use 从工作内存中拿出共享变量，进行操作（比如 <strong>++</strong> 操作，那么计算之后的值都为1）</li><li>线程1/2 assign 把工作内存设置回工作内存中，之后工作内存尝试 <strong>store</strong> 写入主内存，写入成功就是 <strong>write</strong></li><li>结果就是主内存data从 0 -&gt; 1</li></ol><h2 id="2-你知道Java内存模型的原子性、有序性、可见性是什么"><a href="#2-你知道Java内存模型的原子性、有序性、可见性是什么" class="headerlink" title="2.你知道Java内存模型的原子性、有序性、可见性是什么"></a>2.你知道Java内存模型的原子性、有序性、可见性是什么</h2><p><strong>原子性</strong>：指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1。</p><p><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。Java保证可见性可以认为通过volatile、synchronized、final来实现。</p><p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行，Java通过volatile、synchronized来保证。具备有序性，则不会发生指令重排</p><p>volatile禁止指令重排序，防止编译器编译优化时对代码重新排序，导致代码顺序变化。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM_orderliness.png" alt=""></p><p>【例子】正常情况是资源准备完毕，flag才设置为true，但是如图，如果发生指令重排，可能导致先设置为true再进行资源准备，导致直接直接execute而报错</p><h2 id="3-讲讲volatile的工作原理，如何保证可见性？"><a href="#3-讲讲volatile的工作原理，如何保证可见性？" class="headerlink" title="3.讲讲volatile的工作原理，如何保证可见性？"></a>3.讲讲volatile的工作原理，如何保证可见性？</h2><p>volatile关键字用来保证 <strong>可见性</strong> 和 <strong>有序性</strong> 的，不能保证原子性（极端特殊情况下可保证而已）</p><p>举例说明无法保证原子性（还是这张图）：<br><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM-process.jpg" alt=""></p><blockquote><p>就算使用volatile修饰data，当线程1更新data=1到主内存，使得线程二工作内存的data值失效，但是可能此时data已经在被运算中，及时失效了，还是会通过assign把data=1设置到工作内存中，最后write到主内存<br>需要保证原子性，还是需要 <strong>synchronized</strong> 、 <strong>lock</strong> 来保证</p></blockquote><p>当volatile修饰值data，保证data在多线程之间的 <strong>可见性</strong> ，如果data修改，会强制刷新其他线程工作内存中的data的值（让其他线程工作内存data的值失效，来起到强制刷新的作用）</p><p>volatile通过 <strong>禁止指令重排</strong> 来保证 <strong>有序性</strong> </p><h2 id="4-你知道指令重排和happens-before是什么吗？"><a href="#4-你知道指令重排和happens-before是什么吗？" class="headerlink" title="4.你知道指令重排和happens-before是什么吗？"></a>4.你知道指令重排和happens-before是什么吗？</h2><p>一般情况下，为了提高程序执行的效率，编译器或者指令器会对代码进行优化，例如指令重排。</p><p>java中有一个 <strong>happens-before</strong> 原则,<strong>一定程度上来避免胡乱地指令重排</strong>。他在一些特殊情况下，不允许编译器或者指令器对写的代码进行指令重排。</p><p>其中有一个与volatile相关的原则，如果代码中存在volatile修饰的值，此值进行volatile写后，再volatile读，那么顺序上必须先写再读</p><blockquote><p>比如代码中,代码顺序A-&gt;B-&gt;C，那么A的顺序就优于C；或者比如对lock的操作顺序不能被重排（代码先unlock再lock，就不能重排为lock后unlock，否则导致流程错乱）</p></blockquote><h2 id="5-volatile是如何基于内存屏障保证可见性和有序性的？"><a href="#5-volatile是如何基于内存屏障保证可见性和有序性的？" class="headerlink" title="5.volatile是如何基于内存屏障保证可见性和有序性的？"></a>5.volatile是如何基于内存屏障保证可见性和有序性的？</h2><p>内存屏障：禁止重排序</p><p><strong>如何保证有序性</strong><br>如果使用了volatile修饰一个值后，那么会对该值的读写前后会加入一些内存屏障，加入屏障之后，来避免发生指令重排</p><p><strong>如何保证可见性</strong><br>如果使用了volatile修饰一个值data后，在对data执行写操作，JVM会发送<strong>lock前缀指令</strong>给CPU，CPU收到指令，计算完毕会把data强制刷新到主内存里，其他线程通过<strong>对总线的嗅探</strong>，让工作内存的data值失效，之后读取data值时因为工作内存data值失效，所以从缓存中获取。保证了可见性</p><blockquote><p>lock前缀指令 + MESI缓存一致性协议</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之Java内存模型&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之Java内存模型&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之Java内存模型&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JMM" scheme="http://xuyk.top/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之对AQS理解吗</title>
    <link href="http://xuyk.top/posts/interview-AQS.html"/>
    <id>http://xuyk.top/posts/interview-AQS.html</id>
    <published>2021-01-16T09:05:00.000Z</published>
    <updated>2021-01-24T07:03:44.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之对AQS理解吗"><a href="#并发编程灵魂拷问系列之对AQS理解吗" class="headerlink" title="并发编程灵魂拷问系列之对AQS理解吗"></a>并发编程灵魂拷问系列之对AQS理解吗</h1><p><strong>AQS</strong> 即 AbstractQueuedSynchronizer，队列同步器。早期是因为JDK6以前的synchronized关键字使用的是重量级锁，性能不太好，所以作者编写了AQS。</p><p>在JUC中 CountDownLatch、ReentrantLock、ThreadPoolExecutor、ReentrantReadWriteLock 等底层用的都是AQS，AQS几乎占据了JUC并发包里的半壁江山，如果想要获取锁可以被中断、超时获取锁、尝试获取锁那就用AQS吧。</p><p>AQS内部维护了一个 <strong>先进先出队列</strong> 和 <strong>state状态变量</strong></p><ul><li>先进先出队列载体是 Node节点，节点里包含状态值，属于独占/共享模式，前驱/后继节点等信息</li><li>state由 <strong>volatile</strong> 修饰，标识当前锁的状态，1表示加锁成功 0未加锁</li></ul><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AQS-first.png" alt=""></p><ol><li>当线程1操作CAS加锁成功，AQS中的加锁线程变为线程1，state设置为1。</li><li>与此同时线程2加锁失败会进入FIFO先进先出等待队列，当线程1执行完成后，state设为0，然后唤醒等待队列的首位线程也就是线程2，让线程2进行CAS操作</li></ol><p><strong>独占式锁和共享式锁</strong></p><ul><li>独占式：有且只有一个线程能获取到锁，如：ReentrantLock。</li><li>共享式：可以多个线程同时获取到锁，如：CountDownLatch</li></ul><p><strong>公平锁和非公平锁</strong></p><ul><li>公平锁：先到先得，线程通过排队的方式来获取锁</li><li>非公平锁：后来的线程可能会率先获取到锁，非公平锁性能优于公平锁</li></ul><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/k8s-B1ZsEQylba4NWjehEA">由浅入深逐步讲解Java并发的半壁江山AQS</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/ZNURbYIdYqDNXLtRAvDxBQ">1.5w字，30图带你彻底掌握 AQS</a><br>4：<a href="https://mp.weixin.qq.com/s/-OEOk5NNgyjI8aYBm9Sspg">【对线面试官】AQS&amp;&amp;ReentrantLock</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之对AQS理解吗&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之对AQS理解吗&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之对AQS理解吗&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之对AQS理解吗&lt;/h1&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="AQS" scheme="http://xuyk.top/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之如何理解CAS</title>
    <link href="http://xuyk.top/posts/interview-CAS.html"/>
    <id>http://xuyk.top/posts/interview-CAS.html</id>
    <published>2021-01-15T01:12:00.000Z</published>
    <updated>2021-01-24T06:46:42.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之如何理解CAS"><a href="#并发编程灵魂拷问系列之如何理解CAS" class="headerlink" title="并发编程灵魂拷问系列之如何理解CAS"></a>并发编程灵魂拷问系列之如何理解CAS</h1><p><strong>什么是CAS</strong></p><p> CAS，compare And set/swap等，他底层的硬件级别操作（CPU指令cmpxchg）来保证一定是原子性操作，让同一时间只能有一个线程执行CAS操作，在此时间其他线程执行CAS会失败。java里经常使用unsafe类来执行CAS操作</p><p> CAS有三个参数：<strong>当前值A、内存值V、修改的新值B</strong></p><ul><li>如果A和V相等，则把内存值V修改成新值B</li><li>如果A和V不相等，要么重试，要么放弃更新</li></ul><p><strong>为什么要使用CAS呢</strong></p><ul><li>synchronized关键字每次都需要使用锁来保证同一时间只有一个线程执行操作</li><li>CAS允许多个线程同时操作共享数据，但是同一时间只能有一个线程执行CAS操作，在很多情况下比synchronized更加高效，例如 <strong>对一个值进行累加</strong> 这样的操作</li></ul><blockquote><p>AtomicLong等底层使用了CAS，但是更推荐使用LongAdder，性能更高（数组来分散目标值减少自旋重试）</p></blockquote><p><strong>CAS的缺点</strong></p><ul><li>无法解决ABA的问题（共享变量从A -&gt; B -&gt; A），需要加一个版本号</li><li>循环时间长导致资源消耗</li><li>循环执行CAS操作不成功会陷入自旋而耗费cpu资源，锁竞争激烈的场景更倾向于使用重量级锁</li></ul><blockquote><p>解决ABA问题，可以使用结合 <strong>乐观锁</strong> 的机制，例如Java中的 <strong>AtomicStampedReference</strong> 类</p></blockquote><p><strong>使用场景</strong></p><ol><li>如果高并发执行时间久 ，用SYN好， 因为SYN底层用了wait() 阻塞后是不消耗CPU资源的</li><li>如果锁竞争不激烈说明自旋不严重，此时用CAS。</li></ol><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/kvuPxn-vc8dke093XSE5IQ">由浅入深讲解JUC下 CAS + Lock</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/uHl9cnNBtvY_Xc-5WfwpmQ">【对线面试官】 CAS</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之如何理解CAS&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之如何理解CAS&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之如何理解CAS&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之如何理解CAS&lt;/h1&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="CAS" scheme="http://xuyk.top/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之ConcurrentHashMap</title>
    <link href="http://xuyk.top/posts/interview-ConcurrentHashMap.html"/>
    <id>http://xuyk.top/posts/interview-ConcurrentHashMap.html</id>
    <published>2021-01-13T08:40:00.000Z</published>
    <updated>2021-01-13T08:40:49.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之ConcurrentHashMap"><a href="#并发编程灵魂拷问系列之ConcurrentHashMap" class="headerlink" title="并发编程灵魂拷问系列之ConcurrentHashMap"></a>并发编程灵魂拷问系列之ConcurrentHashMap</h1><h2 id="那有什么线程安全的HashMap可以代替呢"><a href="#那有什么线程安全的HashMap可以代替呢" class="headerlink" title="那有什么线程安全的HashMap可以代替呢"></a>那有什么线程安全的HashMap可以代替呢</h2><p>一般面试连环炮会在大致问完HashMap后有此一问，<strong>既然HashMap是线程不安全的，那有什么线程安全的HashMap可以代替呢</strong>，就是为了引出ConcurrentHashMap。</p><ul><li><p>JDK1.8之前：采用分段锁的机制，整个数组被分为对个段（segment），每一段都有一个锁，段与段之间可以并发访问，但是多个线程同时访问同一段时，需要获取锁才能进行访问，提升了一定的性能，但是高并发下性能还是不够强</p></li><li><p>JDK1.8之后：取消分段锁机制，回归一个大数组的方式，采用CAS + synchronized，数据结构和Hashmap一样，使用数组 + 链表 + 红黑树</p></li></ul><blockquote><p>【分析】：JDK1.8之后，锁的粒度控制到了数组的每一个元素，当多线程对数组同一个元素进行操作比如put等，会先通过 CAS 的方式让同一时间只有一个线程A成功执行 CAS ，然后进行put ，其他线程就会使用synchronized 关键字对这个数组元素对象加锁，串行的等待线程A执行完毕后继续获取锁，进行后续操作</p></blockquote><p>【总结】：JDK1.8之后的ConcurrentHashMap，当多个线程对数组不同位置的元素进行操作时，可以并发操作；如果多个线程对数组统一位置元素进行操作时，则加锁串行化处理</p><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/XajTc9dqNNi_ByLR2B_J3A">为什么ConcurrentHashMap的读操作不需要加锁？</a><br>2：<a href="https://mp.weixin.qq.com/s/wZWPg2ldcG1QwHbk6oPOWQ">面试官邪魅一笑: 你说说 Java8 的 ConcurrentHashMap ？</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之ConcurrentHashMap&quot;&gt;&lt;/a&gt;并发
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://xuyk.top/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之说说synchronized</title>
    <link href="http://xuyk.top/posts/interview-synchronized.html"/>
    <id>http://xuyk.top/posts/interview-synchronized.html</id>
    <published>2021-01-10T02:04:00.000Z</published>
    <updated>2021-01-24T07:10:44.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之synchronized"><a href="#并发编程灵魂拷问系列之synchronized" class="headerlink" title="并发编程灵魂拷问系列之synchronized"></a>并发编程灵魂拷问系列之synchronized</h1><h2 id="1-什么是synchronized，JDK1-6前后变化？"><a href="#1-什么是synchronized，JDK1-6前后变化？" class="headerlink" title="1.什么是synchronized，JDK1.6前后变化？"></a>1.什么是synchronized，JDK1.6前后变化？</h2><p>我们可以知道，并发问题一般都是因为 <strong>多个线程同时操作同一个共享数据</strong> 所造成的，解决办法就是加锁，例如 <strong>synchronized加锁</strong></p><ul><li>JDK1.6之前：synchronized使用的是操作系统的互斥锁（底层操作系统的mutex相关指令），因为需要在用户态和内核态进行切换，开销很大，导致并发激烈时性能很差</li><li>JDK1.6之后：进行了锁优化，比如锁升/分级、锁消除、锁粗化等，性能大幅提高，推荐使用</li></ul><h2 id="2-那synchronized底层原理是什么呢？"><a href="#2-那synchronized底层原理是什么呢？" class="headerlink" title="2.那synchronized底层原理是什么呢？"></a>2.那synchronized底层原理是什么呢？</h2><p>synchronized属于 <strong>非公平锁</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>synchronized是基于Monitor来实现同步的，每一个对象都有对应着一个Monitor，如果需要加锁，则必须获取monitor的lock锁。</p><p>monitor锁是可重入锁，有一个计数器，当进入同步代码块时，执行monitorenter指令，计数器+1，退出一个同步代码块时，执行monitorexit指令，计数器-1；当发生对同一对象多次加锁时，计数器加减多次</p><ol><li>对于同步方法，JVM采用 <strong>ACC_SYNCHRONIZED</strong> 标记符来实现同步。</li><li>对于同步代码块。JVM采用 <strong>monitorenter</strong> 、<strong>monitorexit</strong> 两个指令来实现同步。</li></ol><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/synchronized-monitor.jpg" alt=""></p><h2 id="3-什么是锁升-分级？"><a href="#3-什么是锁升-分级？" class="headerlink" title="3.什么是锁升/分级？"></a>3.什么是锁升/分级？</h2><blockquote><p>synchronized 一般来说都对 <strong>对象</strong> 进行加锁</p></blockquote><p>这个可以从对象入手分析，对象在 <strong>堆</strong> 的存储中存有对象头，对象头中的 <strong>Mark Word</strong> 存储着对象的运行时数据，包括对象的hashcode、对象持有的锁等，当中锁从状态进行了分类：</p><p><strong>无锁、偏向锁、轻量级锁、重量级锁</strong>。</p><p>线程获取锁，会根据锁竞争激烈程度进行锁升级来提高性能，<strong>锁可以升级但是不能降级</strong>。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/synchronized-lock-update1.png" alt=""></p><p><strong>总结：</strong></p><ol><li><p><strong>偏向锁</strong>：作者认为很多情况都是一个线程多次获取锁，这种情况加锁解锁最好不需要消耗太多资源，引入了偏向锁。当一个线程获取到锁，锁进进入了偏向模式（偏向锁），下一次该线程获取锁时，不需要额外进行额外进行操作，减少消耗。<strong>所以适合没有多线程来竞争锁的场景</strong></p></li><li><p><strong>轻量级锁</strong>：当其他线程来竞争原本偏向线程A的偏向锁时，等线程A释放锁后，该锁的偏向锁被撤销，升级为轻量级锁（只有发生了多线程之间的锁竞争，该锁会从偏向锁升级为轻量级锁）。<br>轻量级锁生效后，当线程X持有锁时，线程Y获取该对象的锁被线程X持有，则进行 <strong>自旋</strong> （循环使用CAS来获取锁）</p></li><li><p><strong>重量级锁</strong>：当线程Y自旋超过一定时间或者次数，锁会升级为重量级锁，防止CPU空转（自旋过久）。升级为重量级锁后，线程Y不在主动获取锁，而是线程X释放锁之后通知线程Y去获取锁，线程Y从自旋变为阻塞。</p></li></ol><p>简单来说：</p><ul><li><strong>偏向锁</strong>：在Mark Word 记录线程ID进行比对</li><li><strong>轻量级锁</strong>：通过CAS + 自旋的方式竞争</li><li><strong>重量级锁</strong>：使用monitor对象，阻塞</li></ul><h2 id="4-什么是锁消除？"><a href="#4-什么是锁消除？" class="headerlink" title="4.什么是锁消除？"></a>4.什么是锁消除？</h2><p>前文可知，线程安全问题条件之一是存在共享数据，但是当 <strong>synchronized</strong> 修饰的代码块中不存在共享数据时，JDK会通过逃逸分析判断这段代码不会有线程安全问题，自动消除这个锁</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>someMethod方法中的object是局部变量，当多个线程进入方法，会new一个新的object，不存在共享数据，所以会进行 <strong>锁消除</strong></p></blockquote><h2 id="5-什么是锁粗化？"><a href="#5-什么是锁粗化？" class="headerlink" title="5.什么是锁粗化？"></a>5.什么是锁粗化？</h2><p>将多个加锁解锁操作连接在一起，JDK会根据优化策略将其扩展成一个范围更大的锁</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 粗化前</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do some thing</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 能够很快执行完毕，且无需同步的代码</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 粗化后：</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//进行锁粗化：整合成一次锁请求、同步、释放</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do some thing</span>        <span class="token comment" spellcheck="true">// 能够很快执行完毕，且无需同步的代码</span>        <span class="token comment" spellcheck="true">// do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-synchronized都可以修饰哪些对象？"><a href="#6-synchronized都可以修饰哪些对象？" class="headerlink" title="6.synchronized都可以修饰哪些对象？"></a>6.synchronized都可以修饰哪些对象？</h2><ul><li>1.修饰实例方法：锁定的是this对象（类锁）</li><li>2.修饰静态方法：锁定的是class对象（对象内置锁）</li><li>3.修饰代码块：锁定任意指定的对象</li></ul><h2 id="7-synchronized有什么缺点呢"><a href="#7-synchronized有什么缺点呢" class="headerlink" title="7.synchronized有什么缺点呢"></a>7.synchronized有什么缺点呢</h2><ul><li>1.锁的粒度还是比较大的</li><li>2.锁竞争激烈情况下，可能发生死锁</li><li>3.锁竞争激烈时，因为串行化，多个线程排队竞争锁效率不会太高</li></ul><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/8UtdfawQ">synchronized和锁</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/e_fYFWK5Qnxjmz6Abi7uqw">由浅入深逐步了解 Synchronized</a><br>4：<a href="https://mp.weixin.qq.com/s/v1XgT2X4IuF3_WNqeUVhVA">全网最细：17张图带你秒杀synchronized关键字</a><br>5:<a href="https://mp.weixin.qq.com/s/wwGvEt_3x9oHORwuXDqX5g">【对线面试官】synchronized</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之synchronized&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之synchronized&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之synchronized&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之synchr
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="synchronized" scheme="http://xuyk.top/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之HashMap</title>
    <link href="http://xuyk.top/posts/interview-hash-map.html"/>
    <id>http://xuyk.top/posts/interview-hash-map.html</id>
    <published>2021-01-06T09:00:00.000Z</published>
    <updated>2021-01-28T01:15:03.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之HashMap"><a href="#并发编程灵魂拷问系列之HashMap" class="headerlink" title="并发编程灵魂拷问系列之HashMap"></a>并发编程灵魂拷问系列之HashMap</h1><h2 id="1-你知道hashmap底层的数据结构是什么"><a href="#1-你知道hashmap底层的数据结构是什么" class="headerlink" title="1.你知道hashmap底层的数据结构是什么"></a>1.你知道hashmap底层的数据结构是什么</h2><ol><li>JDK1.8之前：数组 + 链表</li><li>JDK1.8之后：数组 + 链表 + 红黑树</li></ol><h2 id="2-hashmap在JDK1-8前后有什么区别"><a href="#2-hashmap在JDK1-8前后有什么区别" class="headerlink" title="2.hashmap在JDK1.8前后有什么区别"></a>2.hashmap在JDK1.8前后有什么区别</h2><ol><li>JDK1.8之前数据结构为数组+链表，JDK1.8+采用数组+链表+红黑树</li></ol><blockquote><p>红黑树查询速度更快，最坏情况的时间复杂度为O(logn)</p></blockquote><ol start="2"><li>JDK1.8之前向链表插入数据时采用头插法，JDK1.8+采用尾插法</li></ol><blockquote><p>因为头插法在多线程环境下，在扩容时resize，也就是节点重新分配位置，有可能会发生A-&gt;B-&gt;A这样的环形链表，导致下次取值时会发生无限循环。尾插法则不会</p></blockquote><ol start="3"><li>JDK1.8之前计算hash值做了四次移位和四次异或，JDK1.8+只用一次异或来提升效率</li></ol><blockquote><p>可能觉得一次扰动就足够了，多了边际作用不大</p></blockquote><ol start="4"><li>JDK1.8之前扩容的时候需要对原数组中的元素进行重新hash定位在新数组的位置，JDK1.8+采用更简单的判断逻辑，位置不变或索引+旧容量大小</li></ol><blockquote><p>扩容为原来数组的两倍，在计算数组位置的二进制掩码中只是高位多了个1，效果等于加上旧数组的长度</p></blockquote><h2 id="3-jdk1-8后hashmap链表和红黑树如何切换"><a href="#3-jdk1-8后hashmap链表和红黑树如何切换" class="headerlink" title="3.jdk1.8后hashmap链表和红黑树如何切换"></a>3.jdk1.8后hashmap链表和红黑树如何切换</h2><ol><li>链表 -&gt; 红黑树： 插入数据时，当链表长度大于等于8，并且数组长度大于等于64，该链表转化为红黑树</li><li>红黑树 -&gt; 链表：长度小于等于6，该红黑树转化成链表</li></ol><h2 id="4-hashmap插入链表是怎么插入的"><a href="#4-hashmap插入链表是怎么插入的" class="headerlink" title="4.hashmap插入链表是怎么插入的"></a>4.hashmap插入链表是怎么插入的</h2><ol><li>JDK1.8之前：头插法，因为当时作者认为新插入的元素往往更可能被查找</li><li>JDK1.8之后：尾插法</li></ol><blockquote><p>【追问】那为什么要改成尾插法呢？</p></blockquote><p>因为头插法在多线程环境下，在扩容时resize，也就是节点重新分配位置，有可能会发生A-&gt;B-&gt;A这样的环形链表，导致下次取值时会发生无限循环。</p><p>尾插法在扩容时会保持链表原本的顺序，就不会出现环的问题</p><blockquote><p>【那么hashmap在JDK1.8之后还线程安全吗】</p></blockquote><p>不安全，例如多线程情况下的put操作，就无法保证上一秒put的值，与下一秒get的还是原值（里面就有很多某属性++，这些都有线程安全问题）</p><blockquote><p>【那有什么办法解决这个线程安全的问题】</p></blockquote><ol><li>可以使用 hashtable ，但是因为直接在方法上锁，导致性能低下所以不考虑</li><li>可以使用 concurrentHashMap </li></ol><h2 id="5-jdk1-8对hash算法和寻址算法是如何优化的？"><a href="#5-jdk1-8对hash算法和寻址算法是如何优化的？" class="headerlink" title="5.jdk1.8对hash算法和寻址算法是如何优化的？"></a>5.jdk1.8对hash算法和寻址算法是如何优化的？</h2><p>我们在put一个kv时，会进行(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)运算（key为null则取0），也就是<strong>拿key的hash值高16位和低16位做异或运算</strong>；</p><p>【优化】：通过对key的hashcode和hashcode右移16位做<strong>异或运算</strong>，也就是把key的hashcode的高16位和低16位做异或运算，通过这样算出的值会<strong>保留高低16位的特征</strong>，尽可能让结果的低16位值不一样，</p><blockquote><p>【hash算法优化】：hash值高低16为进行异或计算，可以同时保留高低16位的特征，减少hash冲突</p></blockquote><p>接着对异或结果进行 “取模运算” ，定位到数组中具体的某个位置上</p><p>【优化】：因为取模运算性能比较差，所以使用 <strong>(n-1) &amp; hash</strong> 来代替取模运算，这里的&amp;运算一般来讲就都是低16位的运算（因为n是数组长度，一般n-1都很小，换算成32位前16位基本为0），所以要保证hash算法后算出来的hash值要尽可能不一样</p><blockquote><p>【寻址算法优化】：同样效果，则使用性能更高的与运算也就是 (n-1)&amp;hash 来进行寻址</p></blockquote><h2 id="6-HashMap如何解决hash碰撞问题的？"><a href="#6-HashMap如何解决hash碰撞问题的？" class="headerlink" title="6.HashMap如何解决hash碰撞问题的？"></a>6.HashMap如何解决hash碰撞问题的？</h2><p>先说一下发生场景：</p><p>在put\get操作中，当两个key-value键值对通过hash算法异或和取模运算之后，定位到的数组位置还是一样时，我们称之为发生了hash碰撞\hash冲突</p><p>【解决方法】<br>hashmap通过在该数组位置挂上链表+红黑树的方式来解决hash碰撞的问题。当发生hash碰撞时，后面的kv会在定位到链表的下个空置节点</p><p>但是如果链表长度过长，极端情况下查询某个值的时间复杂度就为O(n)，性能比较差，所以hashmap在链表达到8（同时数组长度大于64）后会把链表转换成红黑树（时间复杂度为O(logn)），性能会好一些</p><blockquote><p>红黑树长度达到6或6以下后，会由红黑树转为链表</p></blockquote><h2 id="7-hashmap是如何扩容的"><a href="#7-hashmap是如何扩容的" class="headerlink" title="7.hashmap是如何扩容的"></a>7.hashmap是如何扩容的</h2><ol><li>当hashmap数组长度达到 负载因子（默认0.75）* 当前数组容量时，会进行扩容，扩容到原来的2倍，扩容过程涉及到rehash、复制数据等</li><li>当某一链表长度达到8但是数组长度小于64时，会进行扩容</li></ol><p>具体扩容：创建新的数组，将原数组重新hash并且分散到新数组中，可能 位置不变 或 索引+旧容量大小</p><blockquote><p>数组长度变化，取模（与运算）后的结果也相应发生改变。rehash过程中使用 (n-1) &amp; hash(key) 代替取模操作，提高了性能</p></blockquote><h2 id="8-HashMap的主要参数都有哪些？"><a href="#8-HashMap的主要参数都有哪些？" class="headerlink" title="8. HashMap的主要参数都有哪些？"></a>8. HashMap的主要参数都有哪些？</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap-params.jpg" alt=""></p><blockquote><p>摘自公众号【Java3y】</p></blockquote><h2 id="9-阐述一下HashMap在JDK7的环产生原理"><a href="#9-阐述一下HashMap在JDK7的环产生原理" class="headerlink" title="9.阐述一下HashMap在JDK7的环产生原理"></a>9.阐述一下HashMap在JDK7的环产生原理</h2><p>因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；</p><p>A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap-ring.jpg" alt=""></p><blockquote><p>【参考链接】：<br>1：<a href="https:\mp.weixin.qq.com\s\0Gf2DzuzgEx0i3mHVvhKNQ">《吊打面试官》系列-HashMap</a><br>2：<a href="https:\mp.weixin.qq.com\s\ubwe-2U19Y7GQsIByYTWng">HashMap就是这么简单【源码剖析】</a><br>3：<a href="http:\xuyk.top\posts\hashmap.html">HashMap-链表散列</a><br>4：<a href="https:\zhuanlan.zhihu.com\p\125628540">一个HashMap跟面试官扯了半个小时</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之HashMap&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之HashMap&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之HashMap&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之HashMap&lt;/h1&gt;&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="HashMap" scheme="http://xuyk.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>一款自定义RPC框架 x-rpc</title>
    <link href="http://xuyk.top/posts/x-rpc.html"/>
    <id>http://xuyk.top/posts/x-rpc.html</id>
    <published>2021-01-05T01:20:00.000Z</published>
    <updated>2021-01-05T03:35:46.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x-rpc"><a href="#x-rpc" class="headerlink" title="x-rpc"></a>x-rpc</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>在微服务大行其道的2021，说到服务之间的通信，大家都会马上想到RPC（Remote Procedure Call Protocol）远程方法调用，也就是可以让我们调用远程第三方服务时能像调用本地方法一样简单快捷省事儿。其中被大家所熟知的就有SpringCloud中的Feign、Alibaba的Dubbo和谷歌的gRpc等。为了对这些框架有更深刻的了解，笔者自己尝试造了个轮子，也就是x-rpc。</p><p>x-rpc是一款基于 Netty+protostuff+Zookeeper 实现的 RPC 框架，框架大体结构参考的是dubbo：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/dubbo-architure.jpg" alt=""></p><blockquote><p>服务提供方（服务端）启动，向注册中心注册所要发布的服务列表；消费端（客户端）启动，向注册中心订阅/拉取所关心的服务，也就是进行服务发现；消费端发起请求，服务端响应。</p></blockquote><p>简单说明一下x-rpc的设计思路：</p><ol><li><strong>网络传输</strong> ：netty作为<strong>底层通信</strong>框架，能够在简化网络编程的同时压榨cpu，充分提高应用的性能，是网络通信框架的不二之选。</li><li><strong>注册中心</strong> ：天生就用来作为分布式系统下的注册中心、统一配置管理中心、命名服务中心等功能的zookeeper毋庸置疑承担了<strong>服务发现</strong>和<strong>服务注册</strong>的角色</li><li><strong>序列化</strong> ：因为JDK自带的序列化效率很低并且有安全问题，所有这里采用谷歌的protostuff负责<strong>数据包的序列化和反序列化</strong>，当然kryo、Marshalling也是不错的选择</li><li><strong>动态代理</strong> ： 使用动态代理可以屏蔽远程方法调用的细节比如网络传输。也就是说当你调用远程方法的时候，实际会通过代理对象来传输网络请求。</li><li><strong>负载均衡</strong>：这里采用的是客户端负载均衡，通过轮询对服务的每个服务端节点进行依次请求，避免单机压力过大，达到负载均衡效果。</li></ol><h2 id="2-计划列表"><a href="#2-计划列表" class="headerlink" title="2.计划列表"></a>2.计划列表</h2><p><strong>已优化列表</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 重用 Channel 避免重复连接服务端</li><li><input checked="" disabled="" type="checkbox"> 使用 zookeeper 进行服务发现与注册</li><li><input checked="" disabled="" type="checkbox"> 心跳链路检测</li><li><input checked="" disabled="" type="checkbox"> 使用 CompletableFuture 包装接收服务端返回结果</li><li><input checked="" disabled="" type="checkbox"> 客户端调用远程服务进行负载均衡，x-rpc默认使用<strong>轮询</strong>进行负载均衡</li><li><input checked="" disabled="" type="checkbox"> 集成spring</li></ul><p><strong>代办列表</strong></p><ul><li><input disabled="" type="checkbox"> 数据传输时的数据包重新设计：加入魔数（识别之用）、采用序列化方式编号等</li><li><input disabled="" type="checkbox"> 对数据包进行压缩，例如gzip压缩</li><li><input disabled="" type="checkbox"> SPI 机制<br>…</li></ul><h2 id="3-图解说明"><a href="#3-图解说明" class="headerlink" title="3.图解说明"></a>3.图解说明</h2><p>下面是整个x-rpc的代码架构，基于maven构建</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-projects-desc.png" alt=""></p><p>正常在使用过程中，遵循如下顺序：</p><p>1.服务端启动 -&gt; 2.客户端启动 -&gt; 3.客户端服务端整个请求流程（包括客户端发送请求 -&gt; 服务端响应请求 -&gt; 客户端处理响应数据）</p><p>我们就来一一剖析，进一步理解rpc底层大概都干了啥</p><h3 id="3-1-服务端启动"><a href="#3-1-服务端启动" class="headerlink" title="3.1 服务端启动"></a>3.1 服务端启动</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverStartup.jpg" alt=""></p><ol><li>【具体操作】：通过rpc自定义注解@RpcService（@RpcScan属性basePackages范围内）找到所要发布的服务列表，通过扫描注册的方式将服务实例注入到spring bean中</li><li>【具体操作】：在服务实例初始化前，每个注册在spring的实例都会通过zookeeper客户端Curator创建持久节点注册服务，保存服务名和服务端地址，并对该节点进行监听，发生变化时</li><li>【具体操作】：使用ConcurrentHashMap和Set缓存已注册的服务列表，用于后续客户端获取服务列表使用</li><li>【具体操作】：创建启动Netty服务端，异步监控启动结果，添加shutdownHook用于应用关闭释放资源，服务端pipeline用于请求/响应信息的编解码、客户端请求处理等</li></ol><h3 id="3-2-客户端启动"><a href="#3-2-客户端启动" class="headerlink" title="3.2 客户端启动"></a>3.2 客户端启动</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-clientStartup.jpg" alt=""></p><ol><li>【具体操作】：通过@RpcScan属性basePackages，把该范围内的标识spring注解的类注入至spring bean；在bean初始化后，为标识了@RpcReference的属性添加proxy代理实例，之后调用该属性方法时会调用代理类的invoke方法</li><li>pipeline用于请求/响应信息的编解码、服务端响应结果处理等</li></ol><h3 id="3-3-整个调用流程"><a href="#3-3-整个调用流程" class="headerlink" title="3.3 整个调用流程"></a>3.3 整个调用流程</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-wholeRequestProcess.jpg" alt=""></p><blockquote><p>【server/client pipeline】：netty中的调用链，用到了设计模式中的责任链模式</p></blockquote><h2 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4.运行项目"></a>4.运行项目</h2><h3 id="4-1-将项目-clone-至本地"><a href="#4-1-将项目-clone-至本地" class="headerlink" title="4.1 将项目 clone 至本地"></a>4.1 将项目 clone 至本地</h3><pre class="line-numbers language-java"><code class="language-java">git clone https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>xuyikai1<span class="token operator">/</span>x<span class="token operator">-</span>rpc<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-部署运行zookeeper-3-5-8，推荐使用docker"><a href="#4-2-部署运行zookeeper-3-5-8，推荐使用docker" class="headerlink" title="4.2 部署运行zookeeper 3.5.8，推荐使用docker"></a>4.2 部署运行zookeeper 3.5.8，推荐使用docker</h3><p>下载：</p><pre class="line-numbers language-java"><code class="language-java">docker pull zookeeper<span class="token operator">:</span><span class="token number">3.5</span><span class="token punctuation">.</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-java"><code class="language-java">docker run <span class="token operator">-</span>d <span class="token operator">--</span>name zookeeper <span class="token operator">-</span>p <span class="token number">2181</span><span class="token operator">:</span><span class="token number">2181</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>zookeeper:3.5.8</p><h3 id="4-3-使用-maven-命令-install-整个x-rpc项目"><a href="#4-3-使用-maven-命令-install-整个x-rpc项目" class="headerlink" title="4.3 使用 maven 命令 install 整个x-rpc项目"></a>4.3 使用 maven 命令 install 整个x-rpc项目</h3><p>这里使用IDEA进行操作：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-mavenInstall.png" alt=""></p><h3 id="4-4-启动服务端"><a href="#4-4-启动服务端" class="headerlink" title="4.4 启动服务端"></a>4.4 启动服务端</h3><p>运行 rpc-example-server 中的 RpcServerTest1的<code>main()</code>方法启动服务端</p><p>服务端启动成功如图：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverStartupSuccess.png" alt=""></p><p>zookeeper节点情况：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-prettyZoo.png" alt=""></p><blockquote><p>zookeeper client使用的是 <a href="https://github.com/vran-dev/PrettyZoo">prettyZoo</a></p></blockquote><h3 id="4-5-启动客户端-发送请求"><a href="#4-5-启动客户端-发送请求" class="headerlink" title="4.5 启动客户端/发送请求"></a>4.5 启动客户端/发送请求</h3><p>运行 rpc-example-client 中的 RpcServerTest1的<code>main()</code>方法启动服务端</p><p>客户端启动/发送数据情况：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-clientStartupSuccess.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverReceiveRequestSuccess.png" alt=""></p><blockquote><p>这里测试demo中客户端发送了两次请求</p></blockquote><h2 id="5-源码"><a href="#5-源码" class="headerlink" title="5.源码"></a>5.源码</h2><p><a href="https://github.com/xuyikai1/x-rpc">GitHub - xuyikai1/x-rpc</a></p><h2 id="6-感谢"><a href="#6-感谢" class="headerlink" title="6.感谢"></a>6.感谢</h2><p>项目很多细节都是参考 javaGuide 的<a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a>，在这里表示感谢</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x-rpc&quot;&gt;&lt;a href=&quot;#x-rpc&quot; class=&quot;headerlink&quot; title=&quot;x-rpc&quot;&gt;&lt;/a&gt;x-rpc&lt;/h1&gt;&lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;
      
    
    </summary>
    
    
      <category term="rpc" scheme="http://xuyk.top/categories/rpc/"/>
    
    
      <category term="rpc" scheme="http://xuyk.top/tags/rpc/"/>
    
      <category term="netty" scheme="http://xuyk.top/tags/netty/"/>
    
      <category term="protostuff" scheme="http://xuyk.top/tags/protostuff/"/>
    
      <category term="zookeeper" scheme="http://xuyk.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>ShutdownHook钩子</title>
    <link href="http://xuyk.top/posts/shutdownHook.html"/>
    <id>http://xuyk.top/posts/shutdownHook.html</id>
    <published>2021-01-01T07:40:00.000Z</published>
    <updated>2021-01-05T03:28:02.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用钩子shutdownHook优雅关闭资源"><a href="#使用钩子shutdownHook优雅关闭资源" class="headerlink" title="使用钩子shutdownHook优雅关闭资源"></a>使用钩子shutdownHook优雅关闭资源</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>这是一个笔者在造rpc轮子的时候诞生的需求，也是一个挺细节的小知识点。故写一篇blog用于记录。</p><p>这里先来简单讲一下rpc。rpc，远程方法调用，他旨在屏蔽了很多细节让我们调用远程方法和调用本地方法一样简单，目前存在的rpc框架就有<strong>dubbo</strong>、<strong>gRpc</strong>等</p><blockquote><p>想想平时对接第三方api时是不是经历http请求、序列化、拆箱校验、数据标准化装箱等操作呢</p></blockquote><p>而rpc在使用时也涉及道诸多系统资源的使用，例如线程池、注册中心（zookeeper等）等，当rpc服务端（服务提供方）停止服务时，是否也应该释放这些资源呢？</p><p>结果是必然的。想到这一层，需求就诞生了，经过多方寻找，类似于git + jenkins上的webHook，也就是shutdownHook钩子浮出水面</p><h2 id="2-shutdownHook"><a href="#2-shutdownHook" class="headerlink" title="2.shutdownHook"></a>2.shutdownHook</h2><p>这是JVM本身提供的功能，当 JVM 接受到系统的关闭通知之后，调用 ShutdownHook 内的方法，用以完成清理操作，从而平滑的退出应用，下面是示例代码：</p><p><strong>CustomShutdownHook.class</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomShutdownHook</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> CustomShutdownHook CUSTOM_SHUTDOWN_HOOK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CustomShutdownHook <span class="token function">getCustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> CUSTOM_SHUTDOWN_HOOK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">releaseResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"addShutdownHook for clearAll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addShutdownHook</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 1.删除服务端注册信息</span>            ZookeeperClient<span class="token punctuation">.</span><span class="token function">clearRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 2.关闭所有线程池</span>            ThreadPoolExecutorUtils<span class="token punctuation">.</span><span class="token function">shutDownAllThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>自定义的shutdownHook，用于关闭服务端在zookeeper上注册的信息以及线程池资源</p></blockquote><p><strong>RpcServer.class</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 校验</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 添加JVM钩子 用于应用关闭时 自动释放资源</span>        CustomShutdownHook<span class="token punctuation">.</span><span class="token function">getCustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">releaseResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 启动服务端</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>服务端启动时add自定义的ShutDownHook</p></blockquote><p><strong>关闭应用</strong></p><p>此方式支持在以下几种场景优雅停机:</p><ul><li><p>1.程序正常退出</p></li><li><p>2.使用System.exit()</p></li><li><p>3.终端使用Ctrl+C</p></li><li><p>4.使用Kill pid干掉进程</p></li></ul><h2 id="3-Tips"><a href="#3-Tips" class="headerlink" title="3.Tips"></a>3.Tips</h2><blockquote><p>摘自：<a href="https://zhuanlan.zhihu.com/p/82350423">Java中使用shutdownHook的一些注意事项</a></p></blockquote><p><strong>1. 不要使用kill -9来结束你的应用程序</strong></p><p>kill -9是操作系统的终极杀器，如果你使用kill -9的话，应用程序是没有任何发言权的，它只能选择默默退出，几乎可以肯定，shutdownHook不会被调用。</p><p><strong>2. shutdownHook涉及的方法应该尽量的短</strong></p><p>这个可能和操作系统有关系，不同的操作系统可能有不同的差异：</p><blockquote><p>When a computer shuts down, the final stage of the shutdown process sends every remaining process a SIGTERM, gives those processes a few seconds grace, then sends them a SIGKILL.</p></blockquote><p>也就是说，如果shutdownHook过长，可能方法还没执行完，进程就被操作系统强制杀掉了，这一点在addShutdownHook()的文档上也有提及:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">*</span> <span class="token operator">&lt;</span>p<span class="token operator">></span> Shutdown hooks should also finish their work quickly<span class="token punctuation">.</span>  When a<span class="token operator">*</span> program invokes <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> #exit exit<span class="token punctuation">}</span> the expectation is<span class="token operator">*</span> that the virtual machine will promptly shut down and exit<span class="token punctuation">.</span>  When the<span class="token operator">*</span> virtual machine is terminated due to user logoff or system shutdown the<span class="token operator">*</span> underlying operating system may only allow a fixed amount of time in<span class="token operator">*</span> which to shut down and exit<span class="token punctuation">.</span>  It is therefore inadvisable to attempt any<span class="token operator">*</span> user interaction or to perform a <span class="token keyword">long</span><span class="token operator">-</span>running computation in a shutdown<span class="token operator">*</span> hook<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. shutdownHook的方法应该是线程安全的</strong></p><p>这是因为，用户可能多次发送信号导致方法被不同的线程被多次调用，关于这一点文档也有说明：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">*</span> They should<span class="token punctuation">,</span> in<span class="token operator">*</span> particular<span class="token punctuation">,</span> be written to be thread<span class="token operator">-</span>safe and to avoid deadlocks insofar<span class="token operator">*</span> as possible<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>4. 关于shutdownHook方法的异常</strong></p><p>shutdownHook调用过程中产生的所有异常都会被忽略掉并且可能不会输出任何提示信息，因此程序可能蕴含了一个久久不能被发现的BUG导致你的shutdownHook无法被执行，在调用shutdownHook的过程中，一定要仔细检查你的代码，保证正确性。</p><p><strong>5. 某些场景下要提供at most once的保证</strong></p><p>这点其实是接第三点说的，就是你的shutdownHook可能被调用多次，但其实关闭一次就够了，多次调用可能会引发一些意想不到的异常。比如KafkaStream的close方法，就提供了这样的保证：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit timeUnit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Stopping Streams client with timeoutMillis = {} ms."</span><span class="token punctuation">,</span> timeUnit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>KafkaStreams<span class="token punctuation">.</span>State<span class="token punctuation">.</span>PENDING_SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Already in the pending shutdown state, wait to complete shutdown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ....</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用CAS操作来做这样的检查：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>ACTIVE<span class="token punctuation">,</span> CLOSED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// close here</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>【参考链接】：<br>1：<a href="https://zhuanlan.zhihu.com/p/340284353">微服务项目优雅上线、下线小技巧，你学废了吗</a><br>2：<a href="https://zhuanlan.zhihu.com/p/82350423">Java中使用shutdownHook的一些注意事项</a><br>3：<a href="https://zhuanlan.zhihu.com/p/86392065">ShutdownHook- Java 优雅停机解决方案</a><br>4：<a href="https://zhuanlan.zhihu.com/p/159298442">SpringBoot 2.3.0正式发布：优雅停机，配置文件位置新特性一览</a><br>5：<a href="https://zhuanlan.zhihu.com/p/265806389">Spring Boot 系列：最新版优雅停机详解</a><br>6：<a href="https://zhuanlan.zhihu.com/p/336252174">回调方法？钩子方法？模板模式？</a><br>7：<a href="https://mp.weixin.qq.com/s/EgbqwZ6BL-IJubr_Co4ZEg">拒绝 kill -9， SpringBoot 优雅停机详解！</a><br>8：<a href="https://blog.csdn.net/caide3/article/details/108782865">Java程序优雅关闭的两种方法</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用钩子shutdownHook优雅关闭资源&quot;&gt;&lt;a href=&quot;#使用钩子shutdownHook优雅关闭资源&quot; class=&quot;headerlink&quot; title=&quot;使用钩子shutdownHook优雅关闭资源&quot;&gt;&lt;/a&gt;使用钩子shutdownHook优雅关闭
      
    
    </summary>
    
    
      <category term="日常工作应用" scheme="http://xuyk.top/categories/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="shutdownHook" scheme="http://xuyk.top/tags/shutdownHook/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之自动配置原理</title>
    <link href="http://xuyk.top/posts/SpringBoot-autoConfiguration.html"/>
    <id>http://xuyk.top/posts/SpringBoot-autoConfiguration.html</id>
    <published>2020-12-08T09:24:00.000Z</published>
    <updated>2021-01-05T01:15:24.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot之自动配置原理"><a href="#SpringBoot之自动配置原理" class="headerlink" title="SpringBoot之自动配置原理"></a>SpringBoot之自动配置原理</h1><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h2><p>创建SpringBoot项目时，都会默认创建一个Application启动类，并且标注着<code>@SpringBootApplication</code>注解。深入探究会发现<code>@SpringBootApplication</code>注解除了自定义注解经常出现的元注解外，主要还有三个注解标注：<code>@SpringBootConfiguration</code>、<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>，这三个注解可以说就是入口前的三把钥匙了，但是钥匙只有一把，所以我们不妨跟着其中的注释一一整理一番</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/SpringBootApplication.png" alt="SpringBootApplication"></p><blockquote><p><code>@SpringBootConfiguration</code>：再进入一层会发现就是我们配置类常用注解<code>@Configuration</code>，目的是<strong>使用JavaConfig的配置方式来代替XML的繁琐配置</strong></p></blockquote><blockquote><p><code>@ComponentScan</code>：扫描注解，默认是扫描当前类下的package。将Spring一些例如<code>@Controller</code>/<code>@Service</code>/<code>@Component</code>/<code>@Repository</code>等注解加载到IOC容器中。（备注：<code>@EnableAutoConfiguration</code>中的<code>@AutoConfigurationPackage</code>则是用来扫描一些其他组件注解的，比如Spring Data Jpa中的<code>@Entity</code>注解等）</p></blockquote><blockquote><p><code>@EnableAutoConfiguration</code>：自动配置核心注解，下文详细分析</p></blockquote><h2 id="2-EnableAutoConfiguration实现自动配置"><a href="#2-EnableAutoConfiguration实现自动配置" class="headerlink" title="2.@EnableAutoConfiguration实现自动配置"></a>2.<code>@EnableAutoConfiguration</code>实现自动配置</h2><blockquote><p>我们通过代码一步步抽丝剥茧</p></blockquote><h3 id="2-1-EnableAutoConfiguration注解"><a href="#2-1-EnableAutoConfiguration注解" class="headerlink" title="2.1 EnableAutoConfiguration注解"></a>2.1 EnableAutoConfiguration注解</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/EnableAutoConfiguration-annotation.png" alt="EnableAutoConfiguration"></p><blockquote><p>排除元注解和前面我们解释过的<code>@AutoConfigurationPackage</code>注解，可以看出，重点在于<code>@Import(AutoConfigurationImportSelector.class)</code>上。</p></blockquote><h3 id="2-2-自动配置链路分析"><a href="#2-2-自动配置链路分析" class="headerlink" title="2.2 自动配置链路分析"></a>2.2 自动配置链路分析</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/selectImports.png" alt="AutoConfigurationImportSelector.selectImports"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/getAutoConfigurationEntry.png" alt="getAutoConfigurationEntry"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/getCandidateConfigurations.png" alt="getCandidateConfigurations"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/loadFactoryNames.png" alt="SpringFactoriesLoader.loadFactoryNames"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring.factories.path.png" alt="/spring.factories.path"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring.factories.content.png" alt="spring.factories.content"></p><p>从上图和备注我们大致就可以理清自动配置的思路了，通过<strong>自动装配导入选择器</strong><code>AutoConfigurationImportSelector.class</code>来获取候选的一些自动配置项列表，这些自动配置项（127项）都以key为EnableAutoConfiguration统一存储在<strong>spring-boot-autoconfigure-x.x.x.x.jar的META-INF/spring.fatocies中</strong>。</p><h3 id="2-3-配置自动装配加载"><a href="#2-3-配置自动装配加载" class="headerlink" title="2.3 配置自动装配加载"></a>2.3 配置自动装配加载</h3><p>当然这些配置并不是全部127项都加载进去，而是按需分配，开发人员可以通过<code>@SpringBootApplication</code>的<strong>exclude属性</strong>来排除指定的配置项，再根据默认配置的<code>getConfigurationClassFilter()</code>方法获取到的过滤器过滤掉了，最后剩下23个默认配置项</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/Application-scanPackages-exclude.png" alt=""></p><blockquote><p><code>scanBasePackages</code>：扫描注解，默认是扫描当前类下的package。将Spring一些例如@Controller/@Service/@Component/@Repository等注解加载到IOC容器中。<br><code>exclude</code>：排除特定的自动配置类</p></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><ul><li>自动配置的核心是<code>@EnableAutoConfiguration</code>，SpringBoot在启动时会用SPI机制来加载spring.factories中的自动配置项，然后根据开发者的配置和默认配置筛选保留对应的配置进行加载。</li><li>自动配置功能保证了SpringBoot开箱即用的特点，省心省事</li></ul><blockquote><p>【参考链接】：<br>1：<a href="https://zhuanlan.zhihu.com/p/163685081">面试高频题：springboot自动装配的原理你能说出来吗？</a><br>2：<a href="https://zhuanlan.zhihu.com/p/55637237">SpringBoot自动配置原理</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot之自动配置原理&quot;&gt;&lt;a href=&quot;#SpringBoot之自动配置原理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot之自动配置原理&quot;&gt;&lt;/a&gt;SpringBoot之自动配置原理&lt;/h1&gt;&lt;h2 id=&quot;1-分析&quot;
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://xuyk.top/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://xuyk.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>你真的了解线程池吗</title>
    <link href="http://xuyk.top/posts/threadPool.html"/>
    <id>http://xuyk.top/posts/threadPool.html</id>
    <published>2020-11-27T09:25:00.000Z</published>
    <updated>2021-01-10T03:49:18.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你真的了解线程池吗"><a href="#你真的了解线程池吗" class="headerlink" title="你真的了解线程池吗"></a>你真的了解线程池吗</h1><h2 id="1-new-Thread的弊端"><a href="#1-new-Thread的弊端" class="headerlink" title="1.new Thread的弊端"></a>1.new Thread的弊端</h2><ul><li>1：每次new Thread新建对象，性能差</li><li>2：线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或者OOM</li><li>3：缺少更多功能，如更多执行、定期执行、线程中断</li></ul><h2 id="2-线程池的意义"><a href="#2-线程池的意义" class="headerlink" title="2.线程池的意义"></a>2.线程池的意义</h2><ul><li>1：重用存在的线程，减少对象创建、消亡的的开销，性能佳</li><li>2：可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li><li>3：提供定时执行、定期执行、单线程、并发控制等功能</li><li>4：让线程一定程度上可管理</li></ul><h2 id="3-线程池参数"><a href="#3-线程池参数" class="headerlink" title="3.线程池参数"></a>3.线程池参数</h2><p>线程池类：<strong>ThreadPoolExecutor</strong>，参数最完整的构造方法如下图</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-params.png" alt=""></p><ul><li><strong>【coreThreadSize】</strong>：核心线程数量。类似公司的正式员工，在线程池公司中常年工作，除非设置了<strong>executor.allowCoreThreadTimeOut=true</strong>，否则线程一直运行着</li><li><strong>【maximumPoolSize】</strong>：最大线程数=核心线程数 + 非核心线程数</li><li><strong>【workQueue】</strong>：阻塞队列，当（很重要，会对线程池运行过程产生重大影响）</li><li><strong>【keepAliveTime】</strong>：线程空闲时，最多保持多久时间后终止，默认情况下，指的是非核心线程的空闲时间，如果设置executor.allowCoreThreadTimeOut为true也表示核心线程的空闲时间</li><li><strong>【unit】</strong>：keepAliveTime的时间单位</li><li><strong>【threadFactory】</strong>：线程工厂，用于创建线程</li><li><strong>【rejectHandler】</strong>：当拒绝处理任务时采用的策略</li></ul><blockquote><p><strong>1.非核心线程数</strong>：被临时抽调来的线程池以外的系统线程。满足以下条件时：（1）当线程池的核心线程都在工作时（2）阻塞队列满了或者阻塞队列为SynchronousQueue缓存队列（3）最大线程数&gt;核心数<br>当满足以上三个条件时，就会抽调池外线程（系统线程）来帮忙完成任务。任务完成后就会被回收<br><strong>2.executor.allowCoreThreadTimeOut=true</strong>：表示核心线程也会像非核心线程一样，在保持多久keepAliveTime空闲后，该线程消亡被回收</p></blockquote><p><strong>阻塞队列</strong>如下：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/blockingQueue.png" alt=""></p><blockquote><p><strong>【LinkedBlockingQueue】</strong>：不初始化容量则为无界队列。当线程池开始使用时，最开始会创建核心线程，当线程数达到设置的核心线程数时，会进入排队，因为属于无界队列，所以不会创建非核心线程。缺点：系统消耗高，因为任务可以无限排队，当流量非常大时，就会占用很多的内存，严重时可能会导致内存溢出</p></blockquote><blockquote><p><strong>【synchronousQueue】</strong>：无存储能力，一旦达到核心线程数之后，如果依然有比较多的任务进来，那么会尝试非核心线程，这时候maximumPoolSize要设置成比核心线程数更大的值才能生效</p></blockquote><p>日常工作的时候，上述这些参数中，我们需要着重注意以下三个参数：<strong>coreThreadSize</strong>、<strong>maximumPoolSize</strong>、<strong>workQueue</strong>，为什么呢？看看线程池任务调度执行流程吧</p><h2 id="4-线程池任务调度执行流程"><a href="#4-线程池任务调度执行流程" class="headerlink" title="4.线程池任务调度执行流程"></a>4.线程池任务调度执行流程</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-process.png" alt="执行流程"></p><p>执行过程如下：首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</p><ul><li><p>1.如果 <strong>当前活跃线程数 &lt; 核心线程数</strong> ，则创建并启动一个线程来执行新提交的任务。</p></li><li><p>2.如果 <strong>当前活跃线程数 &gt;= 核心线程数 且 线程池内的阻塞队列未满</strong> ，则将任务添加到该阻塞队列中。</p></li><li><p>3.如果 <strong>当前活跃线程数 &gt;= 核心线程数 且 当前活跃线程数 &lt; 最大线程数 且 线程池内的阻塞队列已满</strong> ，则创建并启动一个池外线程来执行新提交的任务。</p></li><li><p>4.如果 <strong>当前活跃线程数 &gt;= 最大线程数 且 线程池内的阻塞队列已满</strong> , 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</p></li></ul><blockquote><p>可以看出，线程池任务调度执行流程中，息息相关的就是核心线程数、最大线程数、以及阻塞队列这三个参数，他们的配置很大程度上影响着线程池处理任务的性能</p></blockquote><h2 id="5-线程池拒绝策略"><a href="#5-线程池拒绝策略" class="headerlink" title="5.线程池拒绝策略"></a>5.线程池拒绝策略</h2><p>当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-rejectHandler.png" alt="线程池拒绝策略"></p><p>日常开发中，一般有两种使用拒绝策略的方式</p><ol><li>采用 <strong>默认的拒绝策略AbortPolicy</strong> ，默认的拒绝策略可以及时的让系统抛出异常从而帮助开发人员定位问题</li><li>采用 <strong>自定义拒绝策略</strong> ，通过持久化磁盘或者消息队列的方式，把被拒绝的任务交给负载相对较低的服务器处理，保证 <strong>任务能100%被处理</strong></li></ol><h2 id="6-线程池使用场景"><a href="#6-线程池使用场景" class="headerlink" title="6 线程池使用场景"></a>6 线程池使用场景</h2><h3 id="6-1-场景一：侧重于高吞吐能力"><a href="#6-1-场景一：侧重于高吞吐能力" class="headerlink" title="6.1 场景一：侧重于高吞吐能力"></a>6.1 场景一：侧重于高吞吐能力</h3><p>当我们需要统计报表时，比如统计汇总各区域数据之后进行处理、生成报表。这种场景相对于相应数据，我们更关注于如何使用系统有限的资源，尽可能在一定的时间内完成更多的任务，也就是<strong>保证充分利用且不浪费系统资源</strong>。</p><p>这时候我们应该设置一定容量的阻塞队列，并且根据系统参数配置核心线程数和最大线程数，减少线程间切换开销</p><p><strong>阻塞队列</strong>：LinkedBlockingQueue（指定容量），有界的阻塞队列<br><strong>线程数</strong>：最大线程数 = 核心线程数 ，一般设置为CPU核数+1，+1的目的是防止CPU空跑</p><p><strong>【例子】</strong>：CPU为6核心6线程，则核心线程数为7，最大线程数为7，LinkedBlockingQueue阻塞队列容量为100</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *【线程池常用场景一】： * 阻塞队列为LinkedBlockingDeque有界阻塞队列（指定容量了），一般最大线程数和核心线程数相等 * 比如以下例子中，核心线程数为6，最大线程数为6 * 所以需要执行10个线程时，6个核心线程都在运行，会把接下来需要执行的任务存放到阻塞队列中 * 等线程执行完毕后，再去队列中获取任务继续执行 *【结果】：2个3s后 10个任务执行完毕 *【工作应用】： * 适用于实时性不会很强的业务解耦场景、比如异步发送通知、短信、异步生成报表等 *【优点】：吞吐量高 *【缺点】：在系统繁忙时，不保证实时性 * @param args */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span>            <span class="token number">6</span><span class="token punctuation">,</span>            <span class="token number">5</span><span class="token punctuation">,</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">NamedThreadFactory</span><span class="token punctuation">(</span><span class="token string">"demo-threadPool-"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提交10个任务给线程池执行 每个任务sleep 3秒</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 每1秒循环一次 已完成任务达到10时 跳出循环线程池关闭</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【--------------------场景一--------------------】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前活跃线程数】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前已经完成的任务数量】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前池中的线程数量】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> queue <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【阻塞队列包含任务数量】:{}"</span><span class="token punctuation">,</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行10个线程时，核心线程都在运行，会把接下来需要执行的任务存放到阻塞队列中，等线程任务执行完毕后再去队列中获取新的任务继续执行</p><h3 id="6-2-场景二：侧重于实时性-快速响应"><a href="#6-2-场景二：侧重于实时性-快速响应" class="headerlink" title="6.2 场景二：侧重于实时性 快速响应"></a>6.2 场景二：侧重于实时性 快速响应</h3><p>当用户进入一个页面时，页面聚合了多个服务的功能，可能开发会为了缩短响应时间，使用线程池去并行执行任务。这时候线程池就不应该设置阻塞队列来影响响应速度了，相对应的，建议提高核心线程数和最大线程数来增加并行线程的数量</p><p><strong>阻塞队列</strong>：SynchoronousQueue<br><strong>线程数</strong>：最大线程数 &gt; 核心线程数 </p><p>【例子】：CPU为6核心6线程，则核心线程数为1，最大线程数为10，阻塞队列为SynchoronousQueue也（队列容量为0）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 【线程池常用场景二】： *  阻塞队列为同步队列SynchronousQueue，不存储任务，一般与最大线程数搭配使用 *  比如以下例子中，核心线程数为1，最大线程数为10，最大线程数=核心线程数+非核心线程数 *  所以执行10个线程时，1个核心线程都在运行，会向系统借调线程（9个线程）来执行任务 * 【结果】：3s后 10个任务执行完毕 * 【工作应用】： *  适用于不影响主流程快速返回结果，但是也需要线程能快速处理好任务的场景 *  比如我司的支付回调后启动设备 * 【优点】：能更快速的处理完任务 * 【缺点】：系统性能和线程池吞吐量会受到一定影响 * @param args */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>            <span class="token number">10</span><span class="token punctuation">,</span>            <span class="token number">5</span><span class="token punctuation">,</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">NamedThreadFactory</span><span class="token punctuation">(</span><span class="token string">"demo-threadPool-"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提交10个任务给线程池执行 每个任务sleep 3秒</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 每1秒循环一次 已完成任务达到10时 跳出循环线程池关闭</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【--------------------场景二--------------------】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前活跃线程数】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前已经完成的任务数量】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前池中的线程数量】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> queue <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【阻塞队列包含任务数量】:{}"</span><span class="token punctuation">,</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要执行10个任务，此时1个核心线程在运行，会从池外（系统）抽调线程来运行剩余任务</p><h3 id="6-3-Spring-TaskExecutor快速实现自定义线程池"><a href="#6-3-Spring-TaskExecutor快速实现自定义线程池" class="headerlink" title="6.3 Spring TaskExecutor快速实现自定义线程池"></a>6.3 Spring TaskExecutor快速实现自定义线程池</h3><p>Spring集成了一个开箱即用的线程池接口以及多种实现类，这里我们举例其中的<strong>ThreadPoolTaskExecutor</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-taskExecutor-impl.png" alt=""></p><p><strong>配置类：TaskExecutorConfig.java</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskExecutorConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 构建一个demo线程池     * 测试类在 TaskExecutorTest     * @return     */</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"demoTaskExecutor"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> TaskExecutor <span class="token function">buildDemoExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置核心线程数</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置最大线程数</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"taskExecutor-demo-thread-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置队列容量 默认容量为Integer.MAX_VALUE 不建议设置为默认值 极端场景会导致OOM</span>        <span class="token comment" spellcheck="true">// 容量大于0：LinkedBlockingQueue 等于0：SynchronousQueue</span>        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试/使用类：TaskExecutorTest</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes<span class="token operator">=</span><span class="token punctuation">{</span>ThreadPoolDemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskExecutorTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"demoTaskExecutor"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> TaskExecutor taskExecutor<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        taskExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程开始休眠"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程休眠结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【测试异步线程池】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以看到，前面介绍的三个重要参数，我们都可以在配置类中指定，并且可以为线程池命名，可以说是非常方便了</p></blockquote><h2 id="7-JUC之Executors类（强烈不推荐使用）"><a href="#7-JUC之Executors类（强烈不推荐使用）" class="headerlink" title="7.JUC之Executors类（强烈不推荐使用）"></a>7.JUC之Executors类（强烈不推荐使用）</h2><p>java.util.concurrent包中为开发者提供了快速创建线程池的方法，如图：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-Executors.png" alt=""></p><blockquote><p>使用这种快速创建线程池的方法虽然极为省事快捷，但是不利于开发人员进一步了解线程池相关知识，也带来了隐患。</p></blockquote><ul><li>1：<strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li>2：<strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul><h2 id="8-线程池技巧与调优"><a href="#8-线程池技巧与调优" class="headerlink" title="8.线程池技巧与调优"></a>8.线程池技巧与调优</h2><h3 id="8-1-任务类型合理配置线程个数"><a href="#8-1-任务类型合理配置线程个数" class="headerlink" title="8.1 任务类型合理配置线程个数"></a>8.1 任务类型合理配置线程个数</h3><p><strong>（1）CPU 密集型任务 = N（CPU 核心数） + 1</strong></p><blockquote><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。<br>【适用场景】：数字计算、排序、挖矿等等</p></blockquote><p><strong>（2）IO 密集型任务 = 2N（CPU核心数）</strong> </p><blockquote><p>这种任务应用起来，系统会用大部分的时间来处理 I\O 交互，而线程在处理 I\O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I\O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。<br>【适用场景】：操作数据库、文件等</p></blockquote><p><strong>（3）混合型任务</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-mixedTask.png" alt=""></p><blockquote><p>详细计算可查看这篇博客：<a href="https://blog.csdn.net/feilang00/article/details/95940059">如何合理地估算线程池大小？</a></p></blockquote><h3 id="8-2-调优小技巧与Tips"><a href="#8-2-调优小技巧与Tips" class="headerlink" title="8.2 调优小技巧与Tips"></a>8.2 调优小技巧与Tips</h3><p><strong>线程池抉择</strong></p><ol><li><p>如果想要<strong>降低系统资源的消耗</strong>（cpu使用率，操作系统资源消耗，上下文切换开销），那么可以设置一个比较大的队列容量和一个比较小的线程池容量</p></li><li><p>如果<strong>队列经常堆积比较多的任务</strong>，并且业务方面需要加快处理速度时，可以适当加大maximumPoolSize，找一些池外线程（临时工）帮忙</p></li></ol><p><strong>Timer与ScheduledThreadPoolExecutor的区别</strong></p><p>  timer是单线程的，如果一个线程执行时间很长，会影响下一个执行线程，实际项目中尽可能用ScheduledThreadPoolExecutor，慎用Timer</p><p><strong>线程池自定义命名小技巧</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// guava</span><span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">"my-thread-pool-%d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// hutoolnew NamedThreadFactory("my-thread-pool-", false)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>ScheduledThreadPoolExecutor</strong></p><p>继承了ThreadPoolExecutor，一般被用来当做延迟队列线程池使用，但是仔细查看他的构造函数可以发现，<strong>最大线程数maximumPoolSize都被设置成默认的Integer.MAX_VALUE</strong>，生产环境上容易造成OOM或者导致服务器性能下降，建议使用消息队列中的延迟队列代替</p><h3 id="8-3-线程池参数动态化"><a href="#8-3-线程池参数动态化" class="headerlink" title="8.3 线程池参数动态化"></a>8.3 线程池参数动态化</h3><p>业务与流量不会总是一成不变的，当初合理的配置可能也会在突发的巨大流量面前兵败如山倒，固定的线程池配置亦是如此，满足当时，却可能顶不住未来。为此，美团团队在博客中提到了<strong>线程池参数动态化</strong>的思路，非常值得精读！</p><p><a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">Java线程池实现原理及其在美团业务中的实践</a></p><h2 id="9-线程池灵魂拷问"><a href="#9-线程池灵魂拷问" class="headerlink" title="9.线程池灵魂拷问"></a>9.线程池灵魂拷问</h2><h3 id="9-1-当线程池里的线程执行异常会发生什么？"><a href="#9-1-当线程池里的线程执行异常会发生什么？" class="headerlink" title="9.1 当线程池里的线程执行异常会发生什么？"></a>9.1 当线程池里的线程执行异常会发生什么？</h3><p>一个线程出现异常不会影响线程池里面其他线程的正常执行，该异常线程不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。</p><p><strong>异常线程是否会打印异常信息</strong></p><ol><li>调用方法为 <strong>execute()</strong> ，会打印出堆栈异常日志</li><li>调用方法为 <strong>submit()</strong> ，堆栈异常没有输出。但是如果业务需要获取线程返回值，调用了<strong>Future.get()方法</strong>时，可以捕获打印出堆栈异常信息。而很多时候我们可能并不需要获取执行结果，导致异常“被吃”，进而不触发告警信息酿成大祸，<strong>所以个人不建议使用</strong><code>submit()</code>。</li></ol><blockquote><p>两者在使用日志工具打印自定义日志都比较困难，所以个人更推荐结合<strong>jdk8的新特性CompletableFuture</strong>，搭配线程池一起使用，详情可以查看这篇文章：<a href="http://xuyk.top/posts/async.html">如何优雅地异步编程 </a></p></blockquote><h3 id="9-2-如果线上突然宕机，阻塞队列中的任务怎么办？"><a href="#9-2-如果线上突然宕机，阻塞队列中的任务怎么办？" class="headerlink" title="9.2 如果线上突然宕机，阻塞队列中的任务怎么办？"></a>9.2 如果线上突然宕机，阻塞队列中的任务怎么办？</h3><p><strong>阻塞队列中的所有任务会丢失</strong></p><p><strong>保证任务不丢失的思路</strong></p><ol><li>我们可以在提交任务前先进行落库处理，当宕机重启后，再拿出待处理的任务继续执行。</li><li>使用消息队列</li></ol><h3 id="9-3-你知道如果线程池的队列满了之后会发生什么事情吗？"><a href="#9-3-你知道如果线程池的队列满了之后会发生什么事情吗？" class="headerlink" title="9.3 你知道如果线程池的队列满了之后会发生什么事情吗？"></a>9.3 你知道如果线程池的队列满了之后会发生什么事情吗？</h3><p>关键在于 <strong>线程池的队列容量</strong> 与 <strong>最大线程数</strong> 的对比</p><ol><li>队列容量 &lt; 最大线程数，则线程池会抽调 池外线程（系统线程）来处理任务</li><li>队列容量 &gt;= 最大线程数，会根据线程池的拒绝策略来处理任务</li></ol><p><strong>保证任务100%被处理的思路</strong>： 自定义拒绝策略，把任务交给其他负载低的线程池进行处理，或者放入消息队列交给其他线程池处理 / 阻塞队列处理完毕后处理消息队列中的任务</p><h2 id="10-线程池demo"><a href="#10-线程池demo" class="headerlink" title="10.线程池demo"></a>10.线程池demo</h2><p>如果想快速上手的话，可以试试我github上的demo，链接如下：<br><a href="https://github.com/xuyikai1/Java-Trivia">Java-Trivia：thread-pool-demo</a></p><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答</a><br>2：<a href="https://mp.weixin.qq.com/s/wrTVGLDvhE-eb5lhygWEqQ">有的线程它死了，于是它变成一道面试题</a><br>3：<a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">Java线程池实现原理及其在美团业务中的实践</a><br>4：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/%E6%8B%BF%E6%9D%A5%E5%8D%B3%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.md">拿来即用的线程池最佳实践 JavaGuide</a><br>5：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.md">java线程池学习总结 JavaGuide</a><br>6：<a href="https://zhuanlan.zhihu.com/p/170320272">线程池的execute方法和submit方法有什么区别？</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你真的了解线程池吗&quot;&gt;&lt;a href=&quot;#你真的了解线程池吗&quot; class=&quot;headerlink&quot; title=&quot;你真的了解线程池吗&quot;&gt;&lt;/a&gt;你真的了解线程池吗&lt;/h1&gt;&lt;h2 id=&quot;1-new-Thread的弊端&quot;&gt;&lt;a href=&quot;#1-new-Thre
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="http://xuyk.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程池" scheme="http://xuyk.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅地异步编程</title>
    <link href="http://xuyk.top/posts/async.html"/>
    <id>http://xuyk.top/posts/async.html</id>
    <published>2020-11-09T11:01:00.000Z</published>
    <updated>2021-01-05T03:28:45.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何优雅地异步编程"><a href="#如何优雅地异步编程" class="headerlink" title="如何优雅地异步编程"></a>如何优雅地异步编程</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>还得到刚毕业呆的第一家公司，是做医疗软件的。大家可能有所了解，因为年代比较久远，也为了稳定长久运行，医疗软件一般都是使用以前的技术框架来做，比如整体框架SSH，部署是远程windows手动的等。我在码代码的时候，有的代码就会看到new Thread。现在想想，得亏并发不高线上没啥问题。</p><p>可能有的兄弟就有疑问了，我业务照样走，new Thread会有什么不妥？我们又应该如何正确的进行异步编程呢？以下我就用一个个demo来分析和理解（大佬有更好的意见欢迎留言建议指正）</p><blockquote><p>以下使用api + postman的方式进行demo演示</p></blockquote><h2 id="1-错误之源-new-Thread"><a href="#1-错误之源-new-Thread" class="headerlink" title="1.错误之源 new Thread"></a>1.错误之源 new Thread</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/oldAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">oldAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"古老版本的线程使用方法，浪费线程资源，线程缺乏管理，性能差，坚决不用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"thread sleep end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/new%20Thread%20disadvantages.png" alt=""></p><blockquote><p>看到这么多弊端的我们应该知道这货不能用</p></blockquote><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h2><p>平常我们在公众号文章看到的<strong>池化</strong>，大部分指的就是使用线程池来合理使用线程，完成异步编程任务。当然，线程池可不止这些好处，如下图：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadPool%20advantages.png" alt=""></p><blockquote><p>其中说的定时/定期执行涉及 ScheduledThreadPoolExecutor，大家也可以查询了解一下 </p></blockquote><h3 id="2-1-Executors类快速创建线程池"><a href="#2-1-Executors类快速创建线程池" class="headerlink" title="2.1 Executors类快速创建线程池"></a>2.1 Executors类快速创建线程池</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/executors"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executors</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        Executors.newCachedThreadPool();</span><span class="token comment" spellcheck="true">//        Executors.newFixedThreadPool(2);</span>    executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【不关心返回值】，不推荐使用Executors的方式创建线程池"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"thread sleep end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>很多时候，为了方便，会使用Executors类来快速创建线程池，但是在重点业务或者高并发的场景下，这样创建出来的线程池就会有很大的隐患，这里并不推荐这样的方式创建线程池。</p></blockquote><p><strong>不推荐Executors创建线程池的理由</strong> ：</p><ul><li>1：<strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li>2：<strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li><li>3：无法根据业务需求来自定义线程池参数，无法为线程池命名，定位问题困难</li></ul><h3 id="2-2-自定义线程池"><a href="#2-2-自定义线程池" class="headerlink" title="2.2 自定义线程池"></a>2.2 自定义线程池</h3><blockquote><p>建议在不同的业务线上使用不同的自定义线程池</p></blockquote><h4 id="2-2-1-自定义线程池配置类-ThreadPoolConfig-class"><a href="#2-2-1-自定义线程池配置类-ThreadPoolConfig-class" class="headerlink" title="2.2.1 自定义线程池配置类 ThreadPoolConfig.class"></a>2.2.1 自定义线程池配置类 ThreadPoolConfig.class</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolConfig</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String THREAD_POOL_NAME_PREFIX <span class="token operator">=</span> <span class="token string">"demo-thread-pool"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_POOL_CORE_THREAD_SIZE <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_POOL_MAX_THREAD_SIZE <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_POOL_KEEP_ALIVE_TIME <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_POOL_QUEUE_CAPACITY <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ExecutorService <span class="token function">createThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span>THREAD_POOL_NAME_PREFIX <span class="token operator">+</span> <span class="token string">"-%d"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                THREAD_POOL_CORE_THREAD_SIZE<span class="token punctuation">,</span>                THREAD_POOL_MAX_THREAD_SIZE<span class="token punctuation">,</span>                THREAD_POOL_KEEP_ALIVE_TIME<span class="token punctuation">,</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>THREAD_POOL_QUEUE_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">,</span>                factory<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyAbortPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>        <span class="token function">MyAbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span>                    <span class="token string">"【线程默认饱和策略】:"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"线程被"</span> <span class="token operator">+</span> executor<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"线程执行器拒绝"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们一般是通过 <strong>ThreadPoolExecutor</strong> 的构造函数来创建线程池，然后提交任务给线程池执行就可以了。</p><p><strong>ThreadPoolExecutor</strong> 构造函数如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池的核心线程数量</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池的最大线程数</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>                          TimeUnit unit<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//时间单位</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//任务队列，用来储存等待执行任务的队列</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程工厂，用来创建线程，一般默认即可</span>                          RejectedExecutionHandler handler<span class="token comment" spellcheck="true">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>                           <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-线程池使用"><a href="#2-2-2-线程池使用" class="headerlink" title="2.2.2 线程池使用"></a>2.2.2 线程池使用</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> ExecutorService executorService<span class="token punctuation">;</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/threadPoolAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">threadPoolAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【不关心返回值】，日常使用注意合理配置线程池参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"thread sleep end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>线程池在配置时需要结合业务点进行参数配置，但使用起来还是很方便的。<br>线程池时常可以应用于单应用或者业务解耦的场景，例如，支付成功在第三方支付回调流程中异步发送短信通知服务告知消费者等，减少主流程花费时间</p></blockquote><h3 id="2-3-线程池实践知识点"><a href="#2-3-线程池实践知识点" class="headerlink" title="2.3 线程池实践知识点"></a>2.3 线程池实践知识点</h3><p>实际使用中需要根据自己机器的性能、业务场景来<strong>手动配置线程池的参数</strong>比如核心线程数、使用的任务队列、饱和策略等等。</p><p><strong>线程数设置</strong></p><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)</strong>： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)</strong>： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><p><strong>线程池命名</strong></p><p>每个业务线需要线程池时最好都各自使用对应的线程池，防止互相影响，线程池命名可根据业务进行命名，方便调试定位问题</p><h3 id="2-4-线程池获取结果"><a href="#2-4-线程池获取结果" class="headerlink" title="2.4 线程池获取结果"></a>2.4 线程池获取结果</h3><p>线程池在使用<code>submit()</code>方法时,会返回<code>Future</code>类型（实际为<code>FutureTask</code>类型）的结果</p><p><strong>获取线程执行方法的返回结果</strong></p><p>当我们需要获取线程执行结束返回的结果时，就可以通过Future来获取，实际使用如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/threadPoolFutureAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">threadPoolFutureAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    Future<span class="token operator">&lt;</span>String<span class="token operator">></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【关心返回值】，日常使用注意合理配置线程池参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"returnVal"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        String result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Future同步阻塞当前线程来获取返回值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"缺点：需要catch异常处理，代码不够优雅，当前线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Future result:{}"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> ExecutionException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"线程异常:{}"</span><span class="token punctuation">,</span>ExceptionUtil<span class="token punctuation">.</span><span class="token function">stacktraceToString</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上述代码，当我们使用postman调用此api时，主线程会通过<strong>同步阻塞</strong>的方式来等待获取异步线程返回结果（这种方式被经常成为假异步），当笔者第一次使用这种方式获取结果时，着实很困惑，既然还会阻塞我还不如直接同步进行，还省个线程..无法忍受之后就去找解决办法了（就是等会之后介绍的思路用法）<br><strong>当我们需要获取异步线程的返回值时，不建议使用Future来获取</strong></p></blockquote><h2 id="3-Spring-Async"><a href="#3-Spring-Async" class="headerlink" title="3.Spring @Async"></a>3.Spring <code>@Async</code></h2><p>异步编程，大名鼎鼎的Spring当然也来掺一脚，我们先来看下示例：</p><p><strong>AnnotationAsyncService.java</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@EnableAsync</span> <span class="token comment" spellcheck="true">// @Async注解需要先使用该注解来开启功能</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationAsyncService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Async</span><span class="token punctuation">(</span><span class="token string">"testThreadPool"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 指定线程池，若无指定则使用默认创建的线程池执行</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAnnotationMethod</span><span class="token punctuation">(</span>String param<span class="token punctuation">,</span>Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【关心返回值】，日常使用注意合理配置线程池参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为了灵活测试使用的参数param</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"测试异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>AsyncController.java</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> AnnotationAsyncService asyncService<span class="token punctuation">;</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/annotationAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">annotationAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"param"</span><span class="token punctuation">)</span> String param<span class="token punctuation">,</span>                            <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    asyncService<span class="token punctuation">.</span><span class="token function">testAnnotationMethod</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span> sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"annotationAsync Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用<code>@Async</code>要点</strong></p><ul><li><code>@Async</code>也是通过AOP（切面）实现的，与<code>@Transactional</code>相同</li><li>添加<code>@Async</code>注释的方法必须是<strong>public</strong>。因为AOP的本质是动态代理，动态代理要求方法必须是public</li><li><code>@Async</code>必须是<strong>跨类调用</strong>，原因也是同类直接调用无法被动态代理（导致会调用对象本身的方法而不是代理类的方法）</li><li>需要添加@EnableAsync注解</li><li>使用<code>@Async</code>的类需要被Spring所管理，即需要标注<code>@Component</code></li><li><code>@Async</code>标注的方法必须返回void或者Future</li><li>建议设置BlockingQueue的大小，默认设置容量为Integer.MAX_VALUE，也就是无界队列，可能会任务堆积导致内存溢出（容量大于0时<code>@Async</code>绑定的线程池队列为LinkedBlockingQueue，否则为SynchrousQueue），</li></ul><blockquote><p>其实<code>@Async</code>也有获取返回值的功能，但是因为同样是同步阻塞式获取，这里就不展示了。<br>代码上看，注解用起来还是很爽的。当异步方法出现异常时，我们可以配置来捕获异常友好输出到日志，这里需要进行额外配置，配置如下</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncExceptionConfig</span> <span class="token keyword">implements</span> <span class="token class-name">AsyncConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> AsyncUncaughtExceptionHandler <span class="token function">getAsyncUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringAsyncExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">SpringAsyncExceptionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">AsyncUncaughtExceptionHandler</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleUncaughtException</span><span class="token punctuation">(</span>Throwable throwable<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> objects<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"------我是Async无返回方法的异常处理方法---------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Guava-ListenableFuture"><a href="#4-Guava-ListenableFuture" class="headerlink" title="4.Guava ListenableFuture"></a>4.Guava ListenableFuture</h2><p>他来了她来了，他迈着大步走来了。前面我们提到，jdk为我们留下的疑难杂症：<strong>Future同步阻塞来获取异步线程返回值</strong>。</p><p>谷歌的开发人员给出了他们的答案 – <strong>Guava ListenableFuture</strong>，看到这个名称，大伙应该心里有了个想法，没错，就是常用的<strong>监听、回调</strong>的思路，如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/threadPoolGuavaAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">threadPoolGuavaFutureAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"param"</span><span class="token punctuation">)</span> String param<span class="token punctuation">,</span>                                       <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    <span class="token comment" spellcheck="true">// guava在线程池上包装一层监听器</span>    ListeningExecutorService listenServicePool <span class="token operator">=</span> MoreExecutors<span class="token punctuation">.</span><span class="token function">listeningDecorator</span><span class="token punctuation">(</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListenableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> listenableFuture <span class="token operator">=</span> listenServicePool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【关心返回值】，日常使用注意合理配置线程池参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为了灵活测试使用的参数param</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"测试异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"returnVal"</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为指定线程池线程 新增回调函数</span>    Futures<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>listenableFuture<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FutureCallback</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> String result<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 成功</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Guava result:{}"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFailure</span><span class="token punctuation">(</span>Throwable t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 异常</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"系统异常:{}"</span><span class="token punctuation">,</span>ExceptionUtil<span class="token punctuation">.</span><span class="token function">stacktraceToString</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>listenServicePool<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这一做法完美地解决了同步阻塞获取结果的问题，我们可以使用<br>不过单单从代码量角度，下面<strong>jdk1.8</strong>的<code>completableFuture</code>则更胜一筹</p></blockquote><h2 id="5-JDK1-8-CompletableFuture"><a href="#5-JDK1-8-CompletableFuture" class="headerlink" title="5.JDK1.8 CompletableFuture"></a>5.JDK1.8 CompletableFuture</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/completableFutureAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">completableFuture</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"param"</span><span class="token punctuation">)</span> String param<span class="token punctuation">,</span>                              <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> future <span class="token operator">=</span> CompletableFuture            <span class="token comment" spellcheck="true">// 异步发起话费充值</span>            <span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">completableTest</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span> sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">,</span>executorService<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 记录异常</span>            <span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>throwable <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"【系统异常】:{}"</span><span class="token punctuation">,</span>ExceptionUtil<span class="token punctuation">.</span><span class="token function">stacktraceToString</span><span class="token punctuation">(</span>throwable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token string">"error"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> String <span class="token function">completableTest</span><span class="token punctuation">(</span>String param<span class="token punctuation">,</span>Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【关心返回值】，日常使用注意合理配置线程池参数，线程池名称:{}"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为了灵活测试使用的参数param</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"测试异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"CompletableFuture result"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码优雅，可读性高，还不知道选啥嘛！<br>两个字，舒服！</p></blockquote><h2 id="6-demo代码"><a href="#6-demo代码" class="headerlink" title="6.demo代码"></a>6.demo代码</h2><p><a href="https://github.com/xuyikai1/JavaDemo">JavaDemo：async-demo</a></p><blockquote><p>【参考链接】：<br>1：<a href="https://zhuanlan.zhihu.com/p/42682411">浅谈Java Future - 知乎</a><br>2：<a href="https://zhuanlan.zhihu.com/p/101716685">CompletableFuture：让你的代码免受阻塞之苦</a><br>3：<a href="https://zhuanlan.zhihu.com/p/146336940">你还在写同步程序？Java异步编程了解一下</a><br>4：<a href="https://zhuanlan.zhihu.com/p/42470582">浅谈Java异步编程 - 知乎</a><br>5：<a href="https://mp.weixin.qq.com/s/RZqv0jkq644KcGBHaz7lUA">笑了，面试官问我知不知道异步编程的Future</a><br>6：<a href="https://segmentfault.com/a/1190000022069911">guava并发工具</a><br>7：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/%E6%8B%BF%E6%9D%A5%E5%8D%B3%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.md">拿来即用的线程池最佳实践</a><br>8：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a><br>9：<a href="https://mp.weixin.qq.com/s/RcPWPkbiuKZsjbhAMS8Ppw">异步线程CompletableFuture让你的代码速度快到飞起</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何优雅地异步编程&quot;&gt;&lt;a href=&quot;#如何优雅地异步编程&quot; class=&quot;headerlink&quot; title=&quot;如何优雅地异步编程&quot;&gt;&lt;/a&gt;如何优雅地异步编程&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="http://xuyk.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="async" scheme="http://xuyk.top/tags/async/"/>
    
  </entry>
  
  <entry>
    <title>Aop切面与自定义注解的日常应用</title>
    <link href="http://xuyk.top/posts/aop.html"/>
    <id>http://xuyk.top/posts/aop.html</id>
    <published>2020-10-22T12:52:00.000Z</published>
    <updated>2021-01-05T03:36:02.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Aop切面与自定义注解的日常应用"><a href="#Aop切面与自定义注解的日常应用" class="headerlink" title="Aop切面与自定义注解的日常应用"></a>Aop切面与自定义注解的日常应用</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>众所周知，AOP真的是面试里老生常谈的技术点..想当年毕业找工作时，10场面试里7.8场都问AOP。大学毕业前，你肯定怎么都想不到，这辈子会被三个字母搞的晕头转向，脑瓜子嗡嗡的。而如今混了几年的我，决定手撕了他..的表皮，拿来做灵活的日常开发小助手。</p><h2 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2.AOP"></a>2.AOP</h2><p>我们先来聊聊AOP这个知识点。AOP，面向切面编程，我们可以把例如<strong>日志管理、事务处理、权限控制</strong>等这样的公用模块封装起来，通过切面的方式嵌入到业务代码中，降<strong>低系统耦合度，也提升了系统的可扩展性和可维护性</strong>。</p><blockquote><p>日常使用中，大家可以想到<code>@Transaction</code>事务注解。<br>框架源码里，也有很多例子。例如<strong>Alibaba Sentinel</strong>有代码形式的限流和注解形式的限流，其中注解形式的限流就是用到AOP切面的思想，Around环绕来实现<strong>限流</strong></p></blockquote><p>AOP是基于<strong>动态代理</strong>的：</p><p><strong>JDK Proxy</strong>：如果要代理的对象，实现了某个接口，那么Spring AOP会使用 <strong>JDK Proxy</strong>，去创建代理对象;</p><p><strong>Cglib</strong>：对于没有实现接口的对象，就无法使用JDK Proxy 去进行代理了，这时候Spring AOP会使用 <strong>Cglib</strong>，Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：</p><blockquote><p>【面试题】：Spring AOP的实现原理是什么？<br>你可以首先用一句话回答，“Spring AOP是通过JDK的动态代理和CGLIB框架实现的”；然后进一步展开，讲述JDK动态代理和CGLIB的实现原理，“JDK动态代理的实现原理是在运行期目标类加载后，为接口动态生成代理类，将切面植入到代理类中；CGLIB的实现原理是在运行期动态生成一个要代理类的子类，将切面逻辑加入到子类中，子类重写要代理的类的所有不是final的方法。”</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-proxy.jpg" alt=""></p><p>使用AOP的选择有两种：<strong>Spring AOP</strong> 和 <strong>AspectJ AOP</strong>，Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>一般情况下，<strong>我们选择AspectJ AOP即可，他在切面多的情况下性能更高</strong>。</p><h2 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3.自定义注解"></a>3.自定义注解</h2><p>我们从业务角度想想，既然不是每个接口都打上log，而是通过AOP切面的方式来记录，那么肯定有一个<strong>通用模版或者说通用标识</strong>对吧？比如前面提到的<code>@Transaction</code>事务注解，我们要实现自己的业务，当然也搞个自己喜欢的注解，这里就用<code>@RequestLog</code>表示<strong>系统需要对请求打Log</strong>。</p><p>命名完了，我们是不是需要打Log这个动作做一些限制呢？比如我只让他在方法级别上打Log，这里就用到了元注解（注解的注解）<code>@Target(ElementType.METHOD)</code>。</p><p>限制完了，我们是不是可以打Log这个动作做一些备注或者记录呢？比如打Log的方法作用描述，让日志更友好，这里就用到了<strong>我们平时写实体类中的属性一样的东西</strong>（只不过换了种表现形式，这里用的是方法）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 描述 默认空字符串</span>String <span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>备注记录完了，那么如何把日志打上呢？我们就需要在这个方法执行的前后做点手脚，比如获取到被我们注解标注的方法啦，请求的参数、花费的时间啥的，拿到这些信息后打印记录下来。这里应运而生的就是切面类 <strong>RequestLogAop</strong> 了。</p><blockquote><p>自定义注解的小（冷）知识挺多也挺细节的，我这里就简单介绍一下我们即将用到的。实战搞定后，大家可以查看底部的参考链接来了解自定义注解</p></blockquote><h2 id="4-实战"><a href="#4-实战" class="headerlink" title="4.实战"></a>4.实战</h2><h3 id="4-1-依赖"><a href="#4-1-依赖" class="headerlink" title="4.1 依赖"></a>4.1 依赖</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>aop<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">2.3</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>projectlombok<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>lombok<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.18</span><span class="token punctuation">.</span><span class="token number">12</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>cn<span class="token punctuation">.</span>hutool<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>hutool<span class="token operator">-</span>all<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">5.4</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>redisson<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>redisson<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">3.13</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-入参日志Log"><a href="#4-2-入参日志Log" class="headerlink" title="4.2 入参日志Log"></a>4.2 入参日志Log</h3><h4 id="1-自定义注解-RequestLog"><a href="#1-自定义注解-RequestLog" class="headerlink" title="1.自定义注解@RequestLog"></a>1.自定义注解<code>@RequestLog</code></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">RequestLog</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 描述     * @return     */</span>    String <span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>1：<code>@Retention(RetentionPolicy.RUNTIME)</code>：运行时可以使用该注解标识目标（这里具体指方法）<br>2：<code>@Target(ElementType.METHOD)</code>：此注解标识在方法上<br>3：<code>@Documented</code>：用于制作文档<br>4：<code>@interface</code>：用来定义注解，类似于interface用于定义接口<br>5：<strong>desc()</strong>：可以理解为该注解的属性</p></blockquote><h4 id="2-日志封装类-RequestLogInfo"><a href="#2-日志封装类-RequestLogInfo" class="headerlink" title="2.日志封装类 RequestLogInfo"></a>2.日志封装类 RequestLogInfo</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Builder</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestLogInfo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 请求链接     */</span>    <span class="token keyword">private</span> String requestUri<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 接口描述     */</span>    <span class="token keyword">private</span> String apiDesc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求类型     */</span>    <span class="token keyword">private</span> String requestType<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * HTTP请求方法     */</span>    <span class="token keyword">private</span> String httpMethod<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Class路径方法     */</span>    <span class="token keyword">private</span> String classMethod<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求IP     */</span>    <span class="token keyword">private</span> String requestIp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求参数     */</span>    <span class="token keyword">private</span> String requestParams<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 花费时间 单位毫秒(ms)     */</span>    <span class="token keyword">private</span> Long costTimeMillis<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 接口返回结果     */</span>    <span class="token keyword">private</span> String result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>用于记录信息用的封装类</p></blockquote><h4 id="3-日志切面类-RequestLogAop"><a href="#3-日志切面类-RequestLogAop" class="headerlink" title="3.日志切面类 RequestLogAop"></a>3.日志切面类 RequestLogAop</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span> <span class="token comment" spellcheck="true">// 标识这是一个切面</span><span class="token annotation punctuation">@Slf4j</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestLogAop</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 被 @requestLog 所注解的切点     * @param requestLog     */</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(requestLog)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestLogPointcut</span><span class="token punctuation">(</span>RequestLog requestLog<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 环绕增强     * @param pjp     * @param requestLog     */</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"requestLogPointcut(requestLog)"</span><span class="token punctuation">,</span> argNames <span class="token operator">=</span> <span class="token string">"pjp,requestLog"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">around</span><span class="token punctuation">(</span>ProceedingJoinPoint pjp<span class="token punctuation">,</span> RequestLog requestLog<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 请求信息</span>        ServletRequestAttributes requestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span>ServletRequestAttributes<span class="token punctuation">)</span> RequestContextHolder<span class="token punctuation">.</span><span class="token function">currentRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpServletRequest request <span class="token operator">=</span> requestAttributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用包装类目的为了减少多请求情况下 日志串行的问题</span>        RequestLogInfo info <span class="token operator">=</span> RequestLogInfo<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestUri</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiDesc</span><span class="token punctuation">(</span>requestLog<span class="token punctuation">.</span><span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">httpMethod</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span>pjp<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaringTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span>pjp<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestIp</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getRemoteHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestParams</span><span class="token punctuation">(</span>JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>pjp<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        log.info("【请求链接】:{}",request.getRequestURI());</span><span class="token comment" spellcheck="true">//        log.info("【接口描述】:{}",requestLog.desc());</span><span class="token comment" spellcheck="true">//        log.info("【请求类型】:{}",request.getMethod());</span><span class="token comment" spellcheck="true">//        log.info("【请求方法】:{}.{}",pjp.getSignature().getDeclaringTypeName(),pjp.getSignature().getName());</span><span class="token comment" spellcheck="true">//        log.info("【请求IP】:{},{}:{}",request.getRemoteAddr(),request.getRemoteHost(),request.getRemotePort());</span><span class="token comment" spellcheck="true">//        log.info("【请求参数】:{}", JSONUtil.toJsonStr(pjp.getArgs()));</span>        <span class="token comment" spellcheck="true">// 执行原方法逻辑</span>        Object result <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        info<span class="token punctuation">.</span><span class="token function">setCostTimeMillis</span><span class="token punctuation">(</span>stopWatch<span class="token punctuation">.</span><span class="token function">getTotalTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        info<span class="token punctuation">.</span><span class="token function">setResult</span><span class="token punctuation">(</span>JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【requestLog】:{}"</span><span class="token punctuation">,</span>JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        log.info("【接口花费时间统计】:{} 秒",stopWatch.getTotalTimeSeconds());</span><span class="token comment" spellcheck="true">//        log.info("【接口花费时间调度】:{}",stopWatch.prettyPrint());</span><span class="token comment" spellcheck="true">//        log.info("【请求返回结果】:{}",JSONUtil.toJsonStr(result));</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>@Aspect</code>：声明该类为一个注解类<br><code>@Pointcut</code>：定义一个切点，后面跟随一个表达式，表达式可以定义为切某个注解，也可以切某个 package 下的方法<br><code>@Before</code>: 在切点之前，织入相关代码<br><code>@After</code>: 在切点之后，织入相关代码<br><code>@AfterReturning</code>: 在切点返回内容后，织入相关代码，一般用于<strong>对返回值做些加工处理的场景</strong><br><code>@AfterThrowing</code>: 用来处理当织入的代码抛出异常后的逻辑处理<br><code>@Around</code>: 环绕，可以在切入点前后织入代码，并且可以自由的控制何时执行切点</p></blockquote><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestLog</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/requestLog/test"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">requestLog</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> String param<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试Controller类方法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-request-log-post.png" alt="Postman请求示例"></p><p><strong>postman请求示例</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-request-log-log.png" alt="打印Log"></p><h3 id="4-3-分布式锁（本文基于Redisson）"><a href="#4-3-分布式锁（本文基于Redisson）" class="headerlink" title="4.3 分布式锁（本文基于Redisson）"></a>4.3 分布式锁（本文基于Redisson）</h3><blockquote><p>关于Redisson分布式锁相关，可以查看笔者的另一篇文章<br><a href="http://xuyk.top/posts/redisson.html">浅谈Redis客户端Redisson | 寒暄</a></p></blockquote><h4 id="1-相关配置类"><a href="#1-相关配置类" class="headerlink" title="1.相关配置类"></a>1.相关配置类</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1.application.yml配置</span># 应用端口号server<span class="token operator">:</span>  port<span class="token operator">:</span> <span class="token number">10086</span># redis配置redisson<span class="token operator">:</span>  address<span class="token operator">:</span> redis<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span>  database<span class="token operator">:</span> <span class="token number">0</span># password<span class="token operator">:</span> foobared<span class="token comment" spellcheck="true">// 2.redisson配置参数(yml)</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"redisson"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedissonProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer database<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3.redisson配置类</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span>RedissonProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedissonConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Primary</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"defaultRedisClient"</span><span class="token punctuation">,</span>destroyMethod <span class="token operator">=</span> <span class="token string">"shutdown"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> RedissonClient <span class="token function">redissonClient</span><span class="token punctuation">(</span>RedissonProperties redissonProperties<span class="token punctuation">)</span><span class="token punctuation">{</span>        Config config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>redissonProperties<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setDatabase</span><span class="token punctuation">(</span>redissonProperties<span class="token punctuation">.</span><span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 连接最小初始化的个数</span>                <span class="token punctuation">.</span><span class="token function">setConnectionMinimumIdleSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>redissonProperties<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Redisson<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-自定义注解-DistributedLock"><a href="#2-自定义注解-DistributedLock" class="headerlink" title="2.自定义注解@DistributedLock"></a>2.自定义注解<code>@DistributedLock</code></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">DistributedLock</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 锁时间 默认2000毫秒     * @return     */</span>    <span class="token keyword">long</span> <span class="token function">lockTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> 2000L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-切面类-DistributedLockAop"><a href="#3-切面类-DistributedLockAop" class="headerlink" title="3.切面类 DistributedLockAop"></a>3.切面类 DistributedLockAop</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DistributedLockAop</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * redisson客户端     */</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedissonClient redissonClient<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(distributedLock)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">distributeLockPointcut</span><span class="token punctuation">(</span>DistributedLock distributedLock<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 环绕增强     * @param pjp     * @param distributedLock     */</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"distributeLockPointcut(distributedLock)"</span><span class="token punctuation">,</span> argNames <span class="token operator">=</span> <span class="token string">"pjp,distributedLock"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">around</span><span class="token punctuation">(</span>ProceedingJoinPoint pjp<span class="token punctuation">,</span> DistributedLock distributedLock<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        ServletRequestAttributes requestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span>ServletRequestAttributes<span class="token punctuation">)</span> RequestContextHolder<span class="token punctuation">.</span><span class="token function">currentRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpServletRequest request <span class="token operator">=</span> requestAttributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 请求路径</span>        String servletPath <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getServletPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用户ID 应该从token或者threadLocal中获取</span>        String userId <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 锁命名的密度可以根据具体业务再次细分 这里只根据用户和请求路径进行加锁处理</span>        String lockKey <span class="token operator">=</span> userId <span class="token operator">+</span> <span class="token string">" | "</span> <span class="token operator">+</span> servletPath<span class="token punctuation">;</span>        RLock lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> waitTime <span class="token operator">=</span> distributedLock<span class="token punctuation">.</span><span class="token function">waitTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> leaseTime <span class="token operator">=</span> distributedLock<span class="token punctuation">.</span><span class="token function">leaseTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 尝试加锁，最多等待lockTime毫秒，上锁以后leaseTime毫秒自动解锁</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span>leaseTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"lockKey = {}，重复提交！"</span><span class="token punctuation">,</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">,</span><span class="token string">"请勿重复提交！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 真正执行的方法</span>            <span class="token keyword">return</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"lockKey = {} ,  重复提交！"</span><span class="token punctuation">,</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">,</span> <span class="token string">"请勿重复提交！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 解锁(当前线程持有该锁才可进行解锁操作)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> lock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【分布式锁-解锁】lockKey:{}"</span><span class="token punctuation">,</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>解锁时的注意事项</strong>：<br>lock.isHeldByCurrentThread()表示锁是否被当前线程所持有<br>如果少了lock.isHeldByCurrentThread()这一判断，在有异步操作时会出现下面这样的异常，提示当前线程并不持有我们需要解的锁，无法尝试去解锁</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-lock-exception.png" alt="异常堆栈"></p><h4 id="4-测试-1"><a href="#4-测试-1" class="headerlink" title="4.测试"></a>4.测试</h4><p><strong>测试Controller类方法</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DistributedLock</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/distributedLock/test"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">distributedLock</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepTime"</span><span class="token punctuation">)</span> Integer sleepTime<span class="token punctuation">,</span>                                  <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"isError"</span><span class="token punctuation">)</span> Boolean isError<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isError<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token string">"出现异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>postman请求示例</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-request-log-postman-lock.png" alt="Postman请求示例"></p><h3 id="4-4-异常日志"><a href="#4-4-异常日志" class="headerlink" title="4.4 异常日志"></a>4.4 异常日志</h3><h4 id="1-自定义注解-ExceptionLog"><a href="#1-自定义注解-ExceptionLog" class="headerlink" title="1.自定义注解@ExceptionLog"></a>1.自定义注解<code>@ExceptionLog</code></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 运行时使用该注解</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 作用于方法</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ExceptionLog</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-mysql异常日志记录表"><a href="#2-mysql异常日志记录表" class="headerlink" title="2.mysql异常日志记录表"></a>2.mysql异常日志记录表</h4><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/aop-exceptionLogInfo.png" alt=""></p><h4 id="3-表对应异常日志类-ExceptionLogInfo"><a href="#3-表对应异常日志类-ExceptionLogInfo" class="headerlink" title="3.表对应异常日志类 ExceptionLogInfo"></a>3.表对应异常日志类 ExceptionLogInfo</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Builder</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"exception_log"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionLogInfo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * api请求路径     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"api_path"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String apiPath<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * api方法     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"api_method"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String apiMethod<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求路径     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"uri_path"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String uriPath<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求参数     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"request_param"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String requestParam<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 异常堆栈信息     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"ex_message"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String exMessage<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 创建时间     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"create_time"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date createTime<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-日志切面类-ExceptionLogAop"><a href="#4-日志切面类-ExceptionLogAop" class="headerlink" title="4.日志切面类 ExceptionLogAop"></a>4.日志切面类 ExceptionLogAop</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionLogAop</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ExceptionLogMapper exceptionLogMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token function">ExceptionLogAop</span><span class="token punctuation">(</span>ExceptionLogMapper exceptionLogMapper<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>exceptionLogMapper <span class="token operator">=</span> exceptionLogMapper<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 被 @exceptionLog 所注解的切点     * @param exceptionLog     */</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(exceptionLog)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionLogPointcut</span><span class="token punctuation">(</span>ExceptionLog exceptionLog<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 异常记录处理     * @param joinPoint     * @param exceptionLog     * @param e     */</span>    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"exceptionLogPointcut(exceptionLog)"</span><span class="token punctuation">,</span> throwing <span class="token operator">=</span> <span class="token string">"e"</span><span class="token punctuation">,</span> argNames <span class="token operator">=</span> <span class="token string">"joinPoint,exceptionLog,e"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saveExceptionLog</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">,</span>ExceptionLog exceptionLog<span class="token punctuation">,</span> Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 请求信息</span>        ServletRequestAttributes requestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span>ServletRequestAttributes<span class="token punctuation">)</span> RequestContextHolder<span class="token punctuation">.</span><span class="token function">currentRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpServletRequest request <span class="token operator">=</span> requestAttributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Signature signature <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 持久化异常相关信息到数据库</span>        ExceptionLogInfo log <span class="token operator">=</span> ExceptionLogInfo<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiPath</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getServletPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiMethod</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">uriPath</span><span class="token punctuation">(</span>signature<span class="token punctuation">.</span><span class="token function">getDeclaringTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> signature<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestParam</span><span class="token punctuation">(</span><span class="token function">convertMap</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">exMessage</span><span class="token punctuation">(</span>ExceptionUtil<span class="token punctuation">.</span><span class="token function">stacktraceToOneLineString</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">createTime</span><span class="token punctuation">(</span>DateUtil<span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        exceptionLogMapper<span class="token punctuation">.</span><span class="token function">insertSelective</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 请求参数格式转换     * Map&lt;String,String[]> -> Map&lt;String,String>的json字符串     * @param paramMap     * @return     */</span>    <span class="token keyword">private</span> String <span class="token function">convertMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> paramMap<span class="token punctuation">)</span><span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> entries <span class="token operator">=</span> paramMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>entries<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> entry <span class="token operator">:</span> entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>记录异常日志信息主要使用到的是<code>@AfterThrowing</code>注解和切面。再结合切点和request/反射等方式获取到请求和异常等信息，汇总记录持久化下来</p></blockquote><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h4><p><strong>测试Controller类方法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/aop-async-exception-controller.png" alt=""></p><p><strong>postman请求示例</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/aop-exception-postman.png" alt=""></p><p><strong>数据库记录</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/aop-exception-mysql.png" alt=""></p><h3 id="4-5-demo代码"><a href="#4-5-demo代码" class="headerlink" title="4.5 demo代码"></a>4.5 demo代码</h3><p><a href="https://github.com/xuyikai1/JavaDemo">JavaDemo：aop-demo</a></p><blockquote><p>参考链接：<br>1：<a href="https:\zhuanlan.zhihu.com\p\60730622">自定义注解（Annontation）</a><br>2：<a href="https:\zhuanlan.zhihu.com\p\143434806">厉害了！老大利用AOP实现自定义注解，半小时完成我三天工作量</a><br>3：<a href="https:\zhuanlan.zhihu.com\p\82539232">如何优雅地在 Spring Boot 中使用自定义注解，AOP 切面统一打印出入参日志</a><br>4：<a href="https:\zhuanlan.zhihu.com\p\81420343">Spring 自定义注解从入门到精通</a><br>5：<a href="https:\zhuanlan.zhihu.com\p\202586806">9000字，通俗易懂的讲解下Java注解</a><br>6：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.md">JavaGuide/Spring常见问题总结</a><br>7：<a href="https://mp.weixin.qq.com/s/1ol0ewxckG06V-NqMFib4g">写了个牛逼的日志切面，甩锅更方便了</a><br>8：<a href="https://mp.weixin.qq.com/s/BXwjFpEGBLqqqivpMqfZPA">使用 SpringBoot AOP 记录操作日志、异常日志</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Aop切面与自定义注解的日常应用&quot;&gt;&lt;a href=&quot;#Aop切面与自定义注解的日常应用&quot; class=&quot;headerlink&quot; title=&quot;Aop切面与自定义注解的日常应用&quot;&gt;&lt;/a&gt;Aop切面与自定义注解的日常应用&lt;/h1&gt;&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="日常工作应用" scheme="http://xuyk.top/categories/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="aop" scheme="http://xuyk.top/tags/aop/"/>
    
      <category term="自定义注解" scheme="http://xuyk.top/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Ribbon负载均衡策略总结</title>
    <link href="http://xuyk.top/posts/ribbon-load-balance.html"/>
    <id>http://xuyk.top/posts/ribbon-load-balance.html</id>
    <published>2020-10-02T04:24:00.000Z</published>
    <updated>2021-01-05T03:32:08.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ribbon负载均衡策略总结"><a href="#Ribbon负载均衡策略总结" class="headerlink" title="Ribbon负载均衡策略总结"></a>Ribbon负载均衡策略总结</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  学过Spring Cloud/Spring Boot的可能都或多或少的听过用过Ribbon，而正是这个短小而又精悍的组件，因为本身可插拔的独特与便捷性，与Eureka、feign、gateway、zuul、hystrix甚至自定义SpringBoot都能完美融合使用。而今天，我们将抛砖引玉，从Ribbon中总结出他的核心：<strong>负载均衡策略</strong>。</p><h2 id="1-RandomRule-随机"><a href="#1-RandomRule-随机" class="headerlink" title="1. RandomRule - 随机"></a>1. RandomRule - 随机</h2><p>从可用服务节点中，随机挑选一个节点进行访问。</p><blockquote><p>yield+自旋的方式做重试，采用了严格的防御型编程</p></blockquote><p>拓展：<strong>防御型编程</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>server <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>防御型编程：基本可以确定list中的server不会为null，但是也会判空并且为空时进行线程出让，到下一个循环<br>yield：Thread.yield方法，表示当前线程发生退让，其他线程可以优先获得当前资源</p></blockquote><h2 id="2-RoundRobinRule-轮询（Ribbon默认负载均衡策略）"><a href="#2-RoundRobinRule-轮询（Ribbon默认负载均衡策略）" class="headerlink" title="2. RoundRobinRule - 轮询（Ribbon默认负载均衡策略）"></a>2. RoundRobinRule - 轮询（Ribbon默认负载均衡策略）</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/RoundRobinRule.png" alt="轮询"></p><p>很实在，就是采用轮询的机制把列表中的节点一个个的分发过去</p><blockquote><p>Q：那么如何保证多线程安全（多个请求到来如何保证顺序）？<br>A：根据CAS + 自旋锁的方式来进行同步操作，防止多线程请求的情况下按照顺序下发到节点</p></blockquote><h2 id="3-RetryRule-重试机制"><a href="#3-RetryRule-重试机制" class="headerlink" title="3. RetryRule - 重试机制"></a>3. RetryRule - 重试机制</h2><p>Ribbon里的这一策略秉承了23种经典设计模式之一的装饰模式，直白的理解就是<strong>为其他负载均衡策略加上重试的功能</strong></p><blockquote><p>可以类比Java IO流中的InputStream下有ObjectInputStream/FileInputStream/ByteInputStream等等，为输入流提供转化成对象/文件/字节等功能</p></blockquote><h2 id="4-WeightedResponseTimeRule-权重"><a href="#4-WeightedResponseTimeRule-权重" class="headerlink" title="4. WeightedResponseTimeRule - 权重"></a>4. WeightedResponseTimeRule - 权重</h2><p>Ribbon中这一负载均衡策略，会根据服务节点的响应时间计算权重，<strong>响应时间越长权重越低，此机器被选中的概率也越低</strong></p><blockquote><p>当然，在初期采样不足时，聪明的Ribbon也想到了，他们决定先采用轮询才收集样本，积累足够后会自动切换成权重机制</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/WeightedResponseTimeRule.png" alt="权重"></p><h2 id="5-BestAvailableRule-最少连接数-并发"><a href="#5-BestAvailableRule-最少连接数-并发" class="headerlink" title="5. BestAvailableRule - 最少连接数/并发"></a>5. BestAvailableRule - 最少连接数/并发</h2><p>Ribbon在<strong>过滤掉故障服务</strong>后，对基于<strong>过去30分钟</strong>的统计结果来选取当前并发量最小的服务节点，也就是最闲的节点来下发请求。相同的，采样不足时先使用备胎..不，轮询来负责。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/BestAvailableRule.png" alt="最少连接数"></p><h2 id="6-AvailabilityFilteringRule-条件-要求"><a href="#6-AvailabilityFilteringRule-条件-要求" class="headerlink" title="6. AvailabilityFilteringRule - 条件/要求"></a>6. AvailabilityFilteringRule - 条件/要求</h2><p>顾名思义，节点列表中需要满足一定条件的节点才可能被初步选中，并且这个节点不能处于<strong>熔断状态</strong>，还有请求数也不能超过特定阈值，才可被选中下发（选中后不幸宕机，则会发起重试，失败则再选择下一个节点）</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AvailabilityFilteringRule.png" alt="条件"></p><h2 id="7-ZoneAvoidanceRule-组合过滤"><a href="#7-ZoneAvoidanceRule-组合过滤" class="headerlink" title="7. ZoneAvoidanceRule - 组合过滤"></a>7. ZoneAvoidanceRule - 组合过滤</h2><p>1.每个在Eureka注册的节点都有三个身份信息：Zone、Region和URL，Zone可以理解为机房大区，这个策略会对每个节点的Zone做健康检查，筛选返回健康的节点列表<br>2.对筛选出来的列表做可用性过滤（如AvailabilityFilteringRule一样排除处于熔断状态的节点以及并发压力大（超过阈值）的结点）</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/ZoneAvoidanceRule.png" alt="组合过滤"></p><h2 id="8-加餐：LVS的负载均衡"><a href="#8-加餐：LVS的负载均衡" class="headerlink" title="8.  加餐：LVS的负载均衡"></a>8.  加餐：LVS的负载均衡</h2><p>LVS，全称为Linux Virtual Server，本质上就是一个负载均衡器，是linux上的虚拟服务，属于四层负载均衡（IP+端口），<strong>只负责转发请求</strong>。业界一般使用 <strong>keepalived+Lvs+Nginx</strong> 来搭建高可用集群负载均衡</p><blockquote><p>【四层负载均衡】：基于IP+端口的负载均衡，只负责转发并且记录当前链接由哪个服务器处理，后续这个链接的请求也会由这一台服务器去处理（相当于浏览器的长连接（keep-alive）），一般使用LVS，F5（F5成本很高）<br>【七层负载均衡】：不仅可以转发，也可以处理JS，CSS或者压缩等，一般使用Nginx，Apache（apache远不如nginx，百万级别性能降低）</p></blockquote><p><strong>LVS的源地址散列</strong>：等同于Nginx的ip-hash负载均衡算法，通俗地讲，就是LVS/Nginx通过把IP做hash之后对当前服务器总数取模分配到特定服务器，目的：<strong>确保同一个用户的请求能落到同一个服务器上</strong></p><blockquote><p>LVS的负载均衡算法有很多，这里来简单介绍以下源地址散列，具体其他的可参考笔者之前的笔记：<a href="http://note.youdao.com/s/M3DftIYr">LVS的负载均衡算法-有道云笔记</a></p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/hash.png" alt="hash算法"></p><blockquote><p>【%】表示求模<br>【node_counts】表示服务器的数量<br>【7 % 3 = 1】表示 7除以3余1 所以等于1<br>ip-hash负载均衡算法其实也有比较明显的缺点，例如对于ip动态变化的用户不太友好，新增/减少服务器都会与原来计算结果背道而驰，这时候可以考虑一致性hash算法（<a href="http://note.youdao.com/s/B3obmiGK">一致性hash算法-有道云笔记</a>）</p></blockquote><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>当然，除了以上的负载均衡策略，其实还有很多没列举出来的，例如Nginx中的最少连接策略、加权轮询等各种加权组合策略等，我们主要还是从中学习理解思想。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ribbon负载均衡策略总结&quot;&gt;&lt;a href=&quot;#Ribbon负载均衡策略总结&quot; class=&quot;headerlink&quot; title=&quot;Ribbon负载均衡策略总结&quot;&gt;&lt;/a&gt;Ribbon负载均衡策略总结&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot;
      
    
    </summary>
    
    
      <category term="负载均衡" scheme="http://xuyk.top/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://xuyk.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群搭建</title>
    <link href="http://xuyk.top/posts/redis-cluster.html"/>
    <id>http://xuyk.top/posts/redis-cluster.html</id>
    <published>2020-09-28T09:04:00.000Z</published>
    <updated>2020-09-28T09:20:51.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h1><h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><table><thead><tr><th align="center">实例</th><th align="center">角色</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">192.168.10.139</td><td align="center">Master</td><td align="center">主节点</td></tr><tr><td align="center">192.168.10.142</td><td align="center">Slave</td><td align="center">从节点,对应139</td></tr><tr><td align="center">192.168.10.140</td><td align="center">Master</td><td align="center">主节点</td></tr><tr><td align="center">192.168.10.143</td><td align="center">Slave</td><td align="center">从节点,对应140</td></tr><tr><td align="center">192.168.10.141</td><td align="center">Master</td><td align="center">主节点</td></tr><tr><td align="center">192.168.10.144</td><td align="center">Slave</td><td align="center">从节点,对应141</td></tr></tbody></table><p>每个redis节点的配置(redis.conf)：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>conf文件中搜索cluster# <span class="token number">2</span><span class="token punctuation">.</span>开启集群cluster<span class="token operator">-</span>enabled yes# <span class="token number">3</span><span class="token punctuation">.</span>每个节点之间的关系<span class="token punctuation">,</span>注释开放即可cluster<span class="token operator">-</span>config<span class="token operator">-</span>file nodes<span class="token operator">-</span><span class="token number">6379</span><span class="token punctuation">.</span>conf# <span class="token number">4</span><span class="token punctuation">.</span>节点超时切换cluster<span class="token operator">-</span>node<span class="token operator">-</span>timeout <span class="token number">5000</span># <span class="token number">5</span><span class="token punctuation">.</span>默认关闭<span class="token punctuation">,</span>yes开启AOFappendonly yes# <span class="token number">6</span><span class="token punctuation">.</span>进入working目录<span class="token punctuation">,</span>删除rdb和aof备份文件<span class="token punctuation">,</span>否则搭建集群会报错# <span class="token number">7</span><span class="token punctuation">.</span>其中如果master有设置密码，则节点配置都需要加上masterauth password# PS：一般不需要密码，生产环境上端口一般配置为不对外开放的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-构建集群"><a href="#2-构建集群" class="headerlink" title="2. 构建集群"></a>2. 构建集群</h2><pre class="line-numbers language-java"><code class="language-java">redis<span class="token operator">-</span>cli <span class="token operator">-</span>a pwd <span class="token operator">--</span>cluster create ip1<span class="token operator">:</span>port1  ip2<span class="token operator">:</span>port2  ip3<span class="token operator">:</span>port3  ip4<span class="token operator">:</span>port4  ip5<span class="token operator">:</span>port5  ip6<span class="token operator">:</span>port6 <span class="token operator">--</span>cluster<span class="token operator">-</span>replicas <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-验证集群"><a href="#3-验证集群" class="headerlink" title="3. 验证集群"></a>3. 验证集群</h2><h3 id="1-随机登陆一台redis客户端"><a href="#1-随机登陆一台redis客户端" class="headerlink" title="(1) 随机登陆一台redis客户端"></a>(1) 随机登陆一台redis客户端</h3><pre class="line-numbers language-java"><code class="language-java">redis<span class="token operator">-</span>cli <span class="token operator">-</span>c <span class="token operator">-</span>a <span class="token number">123456</span> <span class="token operator">-</span>h <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">10.140</span> <span class="token operator">-</span>p <span class="token number">6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>-c：表示采用集群模式<br>-h：表示host<br>-p：端口</p></blockquote><h3 id="2-查看集群"><a href="#2-查看集群" class="headerlink" title="(2) 查看集群"></a>(2) 查看集群</h3><pre class="line-numbers language-java"><code class="language-java">cluster info：集群信息cluster nodes：集群节点信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/cluster%20info.png" alt="cluster-info"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/cluster%20nodes.png" alt="cluster-nodes"></p><h3 id="3-故障转移"><a href="#3-故障转移" class="headerlink" title="(3) 故障转移"></a>(3) 故障转移</h3><p>使用kill命令强制关闭一个redis master节点进程,此时集群状态<br>依旧为ok，在经过n秒(conf配置参数cluster-node-timeout)，<br>此宕机master节点的从节点会升级为master节点。之后原master节点恢复会自动降为slave节点</p><h2 id="4-redis-manager搭建"><a href="#4-redis-manager搭建" class="headerlink" title="4. redis-manager搭建"></a>4. redis-manager搭建</h2><p><a href="https://github.com/ngbdf/redis-manager/wiki/2.x-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8">redis-manager搭建</a></p><h3 id="搭建说明"><a href="#搭建说明" class="headerlink" title="搭建说明"></a>搭建说明</h3><h4 id="1-创建项目所需目录"><a href="#1-创建项目所需目录" class="headerlink" title="(1) 创建项目所需目录"></a>(1) 创建项目所需目录</h4><pre class="line-numbers language-java"><code class="language-java">mkdir <span class="token operator">-</span>p <span class="token operator">/</span>opt<span class="token operator">/</span>tool<span class="token operator">/</span>redis<span class="token operator">-</span>manager<span class="token operator">/</span>data<span class="token operator">/</span>avatarmkdir <span class="token operator">-</span>p <span class="token operator">/</span>opt<span class="token operator">/</span>tool<span class="token operator">/</span>redis<span class="token operator">-</span>manager<span class="token operator">/</span>data<span class="token operator">/</span>confmkdir <span class="token operator">-</span>p <span class="token operator">/</span>opt<span class="token operator">/</span>tool<span class="token operator">/</span>redis<span class="token operator">-</span>manager<span class="token operator">/</span>data<span class="token operator">/</span>machine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-添加到开机自启动"><a href="#2-添加到开机自启动" class="headerlink" title="(2) 添加到开机自启动"></a>(2) 添加到开机自启动</h4><pre class="line-numbers language-java"><code class="language-java"># <span class="token number">1</span><span class="token punctuation">.</span>编辑rc<span class="token punctuation">.</span>local文件vim <span class="token operator">/</span>etc<span class="token operator">/</span>rc<span class="token punctuation">.</span>d<span class="token operator">/</span>rc<span class="token punctuation">.</span>local# <span class="token number">2</span><span class="token punctuation">.</span>加入需要执行的脚本命令sh <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>redis<span class="token operator">-</span>manager<span class="token operator">/</span>bin<span class="token operator">/</span>start<span class="token punctuation">.</span>sh# <span class="token number">3</span><span class="token punctuation">.</span>设置rc<span class="token punctuation">.</span>local可执行权限<span class="token punctuation">(</span>centos7下rc<span class="token punctuation">.</span>local的权限被降低，需要手动为其赋予可执行权限<span class="token punctuation">)</span>chmod u<span class="token operator">+</span>x <span class="token operator">/</span>etc<span class="token operator">/</span>rc<span class="token punctuation">.</span>d<span class="token operator">/</span>rc<span class="token punctuation">.</span>local# <span class="token number">4</span><span class="token punctuation">.</span>重启服务器查看效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-redis-manager添加集群"><a href="#3-redis-manager添加集群" class="headerlink" title="(3) redis-manager添加集群"></a>(3) redis-manager添加集群</h4><p>1.通过<a href="http://192.168.10.139:8182"></a><a href="http://192.168.10.139:8182">http://192.168.10.139:8182</a>访问redis-manager管理端(ip为部署该项目的ip，默认端口为8182)，用户名密码默认皆为admin</p><p>2.Import Cluster导入已部署的集群<br><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/import%20cluster.png" alt="import cluster"></p><p>3.查看集群状态信息<br><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/rediss-manager%20cluster%20info.png" alt="rediss-manager cluster info"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis集群搭建&quot;&gt;&lt;a href=&quot;#Redis集群搭建&quot; class=&quot;headerlink&quot; title=&quot;Redis集群搭建&quot;&gt;&lt;/a&gt;Redis集群搭建&lt;/h1&gt;&lt;h2 id=&quot;1-配置&quot;&gt;&lt;a href=&quot;#1-配置&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://xuyk.top/categories/Redis/"/>
    
    
      <category term="redis cluster" scheme="http://xuyk.top/tags/redis-cluster/"/>
    
  </entry>
  
  <entry>
    <title>Mysql主从配置</title>
    <link href="http://xuyk.top/posts/mysql-configure.html"/>
    <id>http://xuyk.top/posts/mysql-configure.html</id>
    <published>2020-09-15T12:16:00.000Z</published>
    <updated>2020-10-26T06:57:06.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql配置"><a href="#Mysql配置" class="headerlink" title="Mysql配置"></a>Mysql配置</h1><h2 id="0-整体思路"><a href="#0-整体思路" class="headerlink" title="0.整体思路"></a>0.整体思路</h2><ul><li>1.主节点和从节点配置my.cnf配置文件</li><li>2.锁住主节点数据库，将主节点数据库转化成dumpdb文件加载入从节点数据库</li><li>3.从节点设置主从配置，开启主从</li><li>4.同步失效排查</li></ul><blockquote><p>当前Mysql版本为8.0</p></blockquote><h2 id="1-节点说明"><a href="#1-节点说明" class="headerlink" title="1.节点说明"></a>1.节点说明</h2><table><thead><tr><th align="center">节点</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">192.168.10.155</td><td align="center">主节点</td></tr><tr><td align="center">192.168.10.166</td><td align="center">从节点</td></tr></tbody></table><blockquote><p>MYSQL8.0安装可在我的有道云笔记中查看：<br><a href="http:\note.youdao.com\s\mHRa5u3">MYSQL8.0安装概要笔记</a></p></blockquote><h2 id="2-主从节点配置配置"><a href="#2-主从节点配置配置" class="headerlink" title="2.主从节点配置配置"></a>2.主从节点配置配置</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1.155</span>主节点编辑mysql配置文件，在<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>标签下加入如下信息：# 编辑my<span class="token punctuation">.</span>cnf文件vim \etc\my<span class="token punctuation">.</span>cnflog<span class="token operator">-</span>bin<span class="token operator">=</span>my_mysql# server<span class="token operator">-</span>id要与从节点的server<span class="token operator">-</span>id不一致server<span class="token operator">-</span>id<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token number">2.156</span>从节点编辑mysql配置文件（vim \etc\my<span class="token punctuation">.</span>cnf），在<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>标签下加入如下信息：# server<span class="token operator">-</span>id要与主节点的server<span class="token operator">-</span>id不一致server<span class="token operator">-</span>id<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token number">3.155</span>主节点进入mysql客户端新增用于主从间同步的用户并且授权<span class="token punctuation">,</span>后刷新配置# 创建user用户create user <span class="token string">'repl'</span>@<span class="token string">'%'</span> identified by <span class="token string">'Xyk@950807'</span><span class="token punctuation">;</span># 赋予user用户权限grant replication slave on <span class="token operator">*</span><span class="token punctuation">.</span>* to <span class="token string">'repl'</span>@<span class="token string">'%'</span><span class="token punctuation">;</span># 刷新配置flush privileges<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token number">4.155</span>主节点使用命令进行锁表，而后主库备份数据到从库# 锁表，无法插入数据flush tables with read lock<span class="token punctuation">;</span># 查看当前主节点存储数据的文件File和存储位置position，并且记录下来show master status<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5Cmaster%20status.png" alt=""></p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">5</span><span class="token punctuation">.</span>新建一个<span class="token number">155</span>的会话，输入命令将锁之前的数据下载下来mysqldump <span class="token operator">--</span>all<span class="token operator">-</span>databases <span class="token operator">--</span>master<span class="token operator">-</span>data <span class="token operator">></span> dbdump<span class="token punctuation">.</span>db <span class="token operator">-</span>uroot <span class="token operator">-</span>p<span class="token number">6.156</span>节点使用scp命令将<span class="token number">155</span>的文件获取过来（在<span class="token number">156</span>节点输入命令）scp root<span class="token annotation punctuation">@192</span><span class="token punctuation">.</span><span class="token number">168.10</span><span class="token punctuation">.</span><span class="token number">155</span><span class="token operator">:</span><span class="token operator">~</span>\dbdump<span class="token punctuation">.</span>db <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5Cdumpdb.png" alt=""></p><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5Cscp%20dumpdb.png" alt=""></p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">7</span><span class="token punctuation">.</span>把dump<span class="token punctuation">.</span>db文件加载入<span class="token number">156</span>从库中（<span class="token number">156</span>从库执行）mysql <span class="token operator">&lt;</span> dbdump<span class="token punctuation">.</span>db <span class="token operator">-</span>uroot <span class="token operator">-</span>p输入密码<span class="token number">8.155</span>节点释放锁unlock tables<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token number">9.156</span>从节点上配置主从配置信息（mysql客户端）mysql<span class="token operator">></span> change master to    <span class="token operator">-</span><span class="token operator">></span> master_host<span class="token operator">=</span><span class="token string">'192.168.10.155'</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span> master_user<span class="token operator">=</span><span class="token string">'repl'</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span> master_password<span class="token operator">=</span><span class="token string">'Xyk@950807'</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span> master_log_file<span class="token operator">=</span><span class="token string">'my_mysql.000001'</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span> master_log_pos<span class="token operator">=</span><span class="token number">984</span><span class="token punctuation">;</span><span class="token number">10</span><span class="token punctuation">.</span>开启主从start slave<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5Cchange%20master%20to.png" alt=""></p><h2 id="3-同步无效思路"><a href="#3-同步无效思路" class="headerlink" title="3.同步无效思路"></a>3.同步无效思路</h2><p>1.从库mysql 命令【show slave status】</p><p>查看Slave_IO_Running和Slave_SQL_Running是否两个都是yes</p><p>2.有No的情况，则根据Last_IO_Errno的错误码和错误报错排查问题谷歌或者百度解决</p><blockquote><p>【无效参考链接】<br>1.<a href="https:\www.cnblogs.com\ryxiong-blog\p\12516875.html">[mysql] [主从同步错误] Last_IO_Errno: 2061</a><br>2.<a href="https:\blog.csdn.net\qq_42395490\article\details\107451996">Last_IO_Errno: 13114(mysql主从复制)</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql配置&quot;&gt;&lt;a href=&quot;#Mysql配置&quot; class=&quot;headerlink&quot; title=&quot;Mysql配置&quot;&gt;&lt;/a&gt;Mysql配置&lt;/h1&gt;&lt;h2 id=&quot;0-整体思路&quot;&gt;&lt;a href=&quot;#0-整体思路&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://xuyk.top/categories/MySQL/"/>
    
    
      <category term="configure" scheme="http://xuyk.top/tags/configure/"/>
    
  </entry>
  
  <entry>
    <title>HashMap-链表散列</title>
    <link href="http://xuyk.top/posts/hash-map.html"/>
    <id>http://xuyk.top/posts/hash-map.html</id>
    <published>2020-09-09T14:14:00.000Z</published>
    <updated>2021-01-28T01:14:57.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap-链表散列"><a href="#HashMap-链表散列" class="headerlink" title="HashMap-链表散列"></a>HashMap-链表散列</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>  大家在码代码或者面试的过程中，或多或少都肯定用过HashMap或者被问到过。事实上，大部分人包括笔者自己都会把他当作临时内存存储一些对象使用，方便快捷。那么，在这个简单易用的HashMap背后又是什么牛鬼蛇神呢？让我们一探究竟。</p><p>  我们来一个问题抛砖引玉：在刚接触Java的时候，不管是刚学习还是面试题中，都会有这个问题：数组和单链表的特点和不同点有哪些？在这里笔者才疏学浅地脱口而出：</p><ul><li><strong>数组</strong>：连续的内存。根据游标（index）查询快，时间复杂度O(1)；增删慢，时间复杂度O(n)</li><li><strong>单链表</strong>：查询慢，时间复杂度O(n)；增删快，时间复杂度O(1)</li><li>两者查询指定内容的时间复杂度为O(n)</li></ul><p>他们的特点也是由他们本身的数据结构息息相关的，如下图：</p><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E7%BB%84.png" alt="1"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A51.png" alt="2"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A52.png" alt="3"></p><p>如图：<br>（1）<strong>说明</strong>：数组是一段连续的内存，创建时必须定义好长度，创建后无法修改<br>（2）<strong>查询</strong>：在这个Int array[8]的数组中，如果想要查询下标为1的数据，则直接可以使用array[1]来获取<br>（3）<strong>插入</strong>：270需要插入到268和289中，先让289和320向后移动一位，然后插入。由此看出插入过程繁杂</p><h3 id="1-2-单链表"><a href="#1-2-单链表" class="headerlink" title="1.2 单链表"></a>1.2 单链表</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9.png" alt="单链表"></p><p>如图：<br>（1）<strong>说明</strong>：单链表只存储头结点和尾结点的信息，链表中的每个节点都保存了一个指向下一个节点的指针<br>（2）<strong>查询</strong>：从头结点根据指针向下遍历查询，过程繁杂<br>（3）<strong>插入</strong>：上图可看出，270插入到268和289之间，只需要两步：a.270的指针指向289 b.268的指针指向270</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/hashmap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="数据结构"></p><blockquote><p>备注：当<strong>链表长度大于8</strong> 并且 <strong>数组长度大于64时</strong> 链表才转换为红黑树</p></blockquote><p>  HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。<br>  <strong>HashMap融合了数组与单链表，数组用来定位键（key）存储的位置</strong>（单链表，jdk1.8后优化增加红黑树），<strong>如果有其他键值对存储在这个位置上，则从单链表/红黑树中遍历插入进去</strong>（jdk1.7采用头插法，1.8优化为尾插法）</p><h2 id="3-属性说明"><a href="#3-属性说明" class="headerlink" title="3. 属性说明"></a>3. 属性说明</h2><h3 id="3-1-默认初始容量"><a href="#3-1-默认初始容量" class="headerlink" title="3.1 默认初始容量"></a>3.1 默认初始容量</h3><p>HashMap的数组初始容量（DEFAULT_INITIAL_CAPACITY）为16，当我们使用Map map = new HashMap();时，如果指定了初始容量A，则HashMap内部会初始化为该容量<strong>最近的2的幂方的值（大于等于A）</strong>，例如我们初始化容量为10，则HashMap会为我们新建一个容量为16的数组</p><h3 id="3-2-最大容量"><a href="#3-2-最大容量" class="headerlink" title="3.2 最大容量"></a>3.2 最大容量</h3><p>HashMap的数组最大容量（MAXIMUM_CAPACITY）为 1&lt;&lt; 30，也就是1073741824，当我们创建时指定容量比此值大时，HashMap则会使用此值为容量</p><h3 id="3-3-负载因子"><a href="#3-3-负载因子" class="headerlink" title="3.3 负载因子"></a>3.3 负载因子</h3><p>HashMap的负载因子（DEFAULT_LOAD_FACTOR）默认值为0.75，标识数组存放数据的疏密程度。loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，反之就越稀疏</p><p>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。<strong>loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。</strong></p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，<strong>当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容</strong>，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><h3 id="3-4-转换阈值"><a href="#3-4-转换阈值" class="headerlink" title="3.4 转换阈值"></a>3.4 转换阈值</h3><ul><li>链表转换红黑树时，链表长度的阈值（TREEIFY_THRESHOLD）：8</li><li>链表转换红黑树时，数组长度的阈值（MIN_TREEIFY_CAPACITY）：64</li><li>红黑树恢复成链表的阈值（UNTREEIFY_THRESHOLD）：6</li></ul><p>对应HashMap数据插入或者删除时会有以下三种情况（<strong>jdk1.8版本</strong>）：<br>（1）插入数据后，单链表长度&gt;=8，数组长度小于64，则调用resize方法进行数组扩容<br>（2）插入数据后，单链表长度&gt;=8，数组长度大于等于64，则单链表转换为红黑树<br>（3）删除数据后，单链表长度&lt;=6，当前红黑树恢复回单链表</p><h2 id="4-核心方法"><a href="#4-核心方法" class="headerlink" title="4. 核心方法"></a>4. 核心方法</h2><h3 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h3><p>（1）默认构造函数：只初始化了负载因子</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0.75</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）带参构造函数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>   <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断table是否已经初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>            <span class="token comment" spellcheck="true">// 未初始化，s为m的实际元素个数</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>                    <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算得到的t大于阈值，则初始化阈值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将m中的所有元素添加至HashMap中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）指定容量的构造函数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（4）指定容量和负载因子的构造函数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>       initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-扩容机制"><a href="#4-2-扩容机制" class="headerlink" title="4.2 扩容机制"></a>4.2 扩容机制</h3><p>  HashMap在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容。</p><p>  扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，<strong>方法是使用一个新的数组代替已有的容量小的数组</strong>，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>  进行扩容，会伴随着一次<strong>重新hash分配（rehash）</strong>，并且会遍历hash表中所有的元素，是非常耗时的。<strong>我们在编写程序中，要尽量避免resize</strong>。</p><h3 id="4-3-扰动函数（hash方法）"><a href="#4-3-扰动函数（hash方法）" class="headerlink" title="4.3 扰动函数（hash方法）"></a>4.3 扰动函数（hash方法）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>作用：<br>1.尽可能降低hash碰撞，通俗来说就是减少通过hash方法之后得到相同值也就是定位到同个位置的可能性<br>2.高效，因为属于高频操作，使用位运算使得性能更高</p><blockquote><p>问：jdk 1.7做了四次移位和四次异或，为什么jdk 1.8只用一次异或？<br>答：做1次扰动效率更高，并且两者实际效果差距不大</p></blockquote><h3 id="4-4-插入方法"><a href="#4-4-插入方法" class="headerlink" title="4.4 插入方法"></a>4.4 插入方法</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap-put.png" alt="插入原理"></p><ul><li>（1）对key做hash操作（扰动函数）：如果key为null则返回0，不为null时，key的hashCode对自身无符号向右移后的hashCode做^操作，也就是按位异或，返回值假设为i</li><li>（2）判断键值对数组table是否为空或为null，否则执行resize()进行扩容（对应前方的无参构造函数）；</li><li>（3）查找数组i位置上是否存在节点（table[i] == null），不存在则直接新增此节点直接到（7）</li><li>（4）如果存在（table[i] != null），判断当前key和节点key是否相同，相同则覆盖原来的value</li><li>（5）两者key不相同，则判断当前结构是否已转换为红黑树，已转换则直接在插入到树中</li><li>（6）当前结构不为红黑树为链表时，遍历链表插入节点，然后判断当前长度是否大于等于8时，链表转换为红黑树；否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li><li>（7）插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ul><blockquote><p>【问】：为什么从jdk 1.7的数组+单链表 -&gt; jdk 1.8 数组+单链表/红黑树？<br>【答】：单链表查询的时间复杂度为O(n)，而红黑树的时间复杂度为O(logn)，提升效率</p></blockquote><blockquote><p>【问】：为什么jdk 1.7插入链表采用头插法，而jdk 1.8采用尾插法？<br>【答】：<br>jdk 1.7：作者认为最新插入的往往是查询中最希望被找到的<br>jdk 1.8：在1.7版本中，多线程环境下，A、B线程同时插入，A线程插入后，B线程扩容后重新hash，导致形成环</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BC%8A%E7%AB%AF.jpg" alt="环"></p><h2 id="5-线程安全性"><a href="#5-线程安全性" class="headerlink" title="5. 线程安全性"></a>5. 线程安全性</h2><p>  HashMap是<strong>线程不安全</strong>的，举个数据覆盖的例子：当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；还有++size这个地方也会造成多线程同时扩容等问题。</p><p>  可以使用<strong>ConcurrentHashMap</strong>保证线程安全性（分段锁）</p><blockquote><p>ConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。</p></blockquote><h2 id="6-使用常识与小结"><a href="#6-使用常识与小结" class="headerlink" title="6. 使用常识与小结"></a>6. 使用常识与小结</h2><p>（1）创建HashMap时尽可能预估存储容量，从而调用指定容量的构造参数方法，尽量减少扩容（扩容涉及到rehash、复制数据等，小号性能）</p><p>（2）HashMap的key可传null，但是只能存储1个，value则不限制</p><p>（3）存取遍历HashMap时，优先使用entrySet()方法，可以同时获取到Key和对应的Value；而使用keySet()方法再map.get(key)的话，内部会进行两次遍历，消耗性能</p><pre class="line-numbers language-java"><code class="language-java"> Set<span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entrys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entrys<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（4）负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p><p>（5）HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p><p>（6）JDK1.8引入红黑树大程度优化了HashMap的性能。</p><blockquote><p>【参考链接】<br>1：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md">JavaGuide HashMap</a><br>2：<a href="https://zhuanlan.zhihu.com/p/125628540">一个HashMap跟面试官扯了半个小时</a><br>3：<a href="https://zhuanlan.zhihu.com/p/21673805">Java 8系列之重新认识HashMap</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap-链表散列&quot;&gt;&lt;a href=&quot;#HashMap-链表散列&quot; class=&quot;headerlink&quot; title=&quot;HashMap-链表散列&quot;&gt;&lt;/a&gt;HashMap-链表散列&lt;/h1&gt;&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; cla
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="http://xuyk.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="HashMap" scheme="http://xuyk.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>初涉自动化部署</title>
    <link href="http://xuyk.top/posts/operation.html"/>
    <id>http://xuyk.top/posts/operation.html</id>
    <published>2020-08-03T13:31:00.000Z</published>
    <updated>2021-01-05T03:40:05.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动化部署与持续交付"><a href="#自动化部署与持续交付" class="headerlink" title="自动化部署与持续交付"></a>自动化部署与持续交付</h1><p>日常工作中，每个程序员都会经历<strong>项目部署</strong>，而很多人在这时大多会经历以下环节：</p><ul><li><strong>Git</strong> ：分布式版本控制系统，负责项目代码的分支拉取与分支更新等；</li><li><strong>Maven</strong> ：项目管理工具，负责项目打包；</li><li><strong>项目部署</strong> ：日常可能使用ftp方式传输项目包，Shell相关脚本部署，或者使用IDEA Alibaba Cloud Toolkit相关插件的部署功能等。</li></ul><p>而以上内容中比较传统的方式有一个缺点，就是需要人为的衔接每一步，稍微掉以轻心，则部署就比较容易出问题。</p><p>而如今更需要一个自动化部署与持续交付的组合拳来分担压力，更为准确和系统化的实现项目部署。接下来介绍一下Git\Maven + Jenkins + Ansible三剑客，能轻松解决这一难题，实现自动化部署。</p><p>简单分析图：</p><hr><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-1.png" alt=""></p><p>Git\Maven + Jenkins + Ansible自动化部署三剑客分工：</p><ul><li><strong>Git</strong> ：分布式版本控制系统，负责项目代码的分支拉取与分支更新等工作；</li><li><strong>Maven</strong> ：项目管理工具，负责项目打包工作；</li><li><strong>Ansible</strong> ：自动化运维工具，实现了批量系统配置、批量程序部署、批量运行命令等功能；</li><li><strong>Jenkins</strong> ：持续集成工具，用于监控持续重复的工作，通过插件管理来集成Git、Maven、Ansible来实现对应功能；</li></ul><h2 id="1-版本清单"><a href="#1-版本清单" class="headerlink" title="1. 版本清单"></a>1. 版本清单</h2><table><thead><tr><th align="left">Item</th><th align="left">Version</th></tr></thead><tbody><tr><td align="left">CentOS</td><td align="left">7</td></tr><tr><td align="left">JDK</td><td align="left">1.8</td></tr><tr><td align="left">Python</td><td align="left">3.6.5</td></tr><tr><td align="left">Jenkins</td><td align="left">2.204.1</td></tr><tr><td align="left">Maven</td><td align="left">3.6.3</td></tr><tr><td align="left">Ansible</td><td align="left">2.9.2</td></tr></tbody></table><h2 id="2-安装与部署"><a href="#2-安装与部署" class="headerlink" title="2. 安装与部署"></a>2. 安装与部署</h2><h3 id="2-1-Jenkins安装前的环境部署"><a href="#2-1-Jenkins安装前的环境部署" class="headerlink" title="2.1 Jenkins安装前的环境部署"></a>2.1 Jenkins安装前的环境部署</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-2.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-3.png" alt=""></p><blockquote><p>生产环境中防火墙可能不能关闭，那么则需要放行相关程序所需要的端口(jenkins默认为8080)</p></blockquote><p><strong>下载jenkins rpm包：</strong></p><blockquote><p>https:\pkg.jenkins.io\redhat-stable\</p></blockquote><h4 id="2-1-1-jdk1-8安装"><a href="#2-1-1-jdk1-8安装" class="headerlink" title="2.1.1 jdk1.8安装"></a>2.1.1 jdk1.8安装</h4><blockquote><p>参考链接中安装jdk1.8的部分：<br>https:\blog.csdn.net\qq_26368081\article\details\78984316    </p></blockquote><h4 id="2-1-2-maven安装"><a href="#2-1-2-maven安装" class="headerlink" title="2.1.2 maven安装"></a>2.1.2 maven安装</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>下载maven压缩包wget http<span class="token operator">:</span>\\mirror<span class="token punctuation">.</span>bit<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn\apache\maven\maven<span class="token operator">-</span><span class="token number">3</span>\<span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">3</span>\binaries\apache<span class="token operator">-</span>maven<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">-</span>bin<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz<span class="token number">2</span><span class="token punctuation">.</span>解压mavan压缩包tar  <span class="token operator">-</span>zxvf apache<span class="token operator">-</span>maven<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">-</span>bin<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz<span class="token number">3</span><span class="token punctuation">.</span>查看maven版本号进入maven目录<span class="token punctuation">.</span>\mvn <span class="token operator">--</span>version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Jenkins安装与部署"><a href="#2-2-Jenkins安装与部署" class="headerlink" title="2.2 Jenkins安装与部署"></a>2.2 Jenkins安装与部署</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-4.png" alt=""></p><blockquote><p>JENKINS_USER = deploy表示jenkins的用户<br>JENKINS_PORT = 8080表示jenkins的端口</p></blockquote><pre class="line-numbers language-java"><code class="language-java">启动jenkins服务：systemctl start jenkins开机自启动jenkins服务： systemctl enable jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-登陆jenkins管理平台"><a href="#2-2-1-登陆jenkins管理平台" class="headerlink" title="2.2.1 登陆jenkins管理平台"></a>2.2.1 登陆jenkins管理平台</h4><p>接下来使用可以访问到该服务器jenkins端口的电脑登陆：服务器ip + jenkins端口号<br>例如：http:\192.168.10.132:8080</p><h4 id="2-2-2-复制输入初始密码登陆"><a href="#2-2-2-复制输入初始密码登陆" class="headerlink" title="2.2.2 复制输入初始密码登陆"></a>2.2.2 复制输入初始密码登陆</h4><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-5.png" alt=""></p><pre class="line-numbers language-java"><code class="language-java">复制文件中的密码vi \var\lib\jenkins\secrets\initialAdminPassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-3-安装插件"><a href="#2-2-3-安装插件" class="headerlink" title="2.2.3 安装插件"></a>2.2.3 安装插件</h4><p>选择推荐安装的插件即可</p><h4 id="2-2-4-创建管理员帐户"><a href="#2-2-4-创建管理员帐户" class="headerlink" title="2.2.4 创建管理员帐户"></a>2.2.4 创建管理员帐户</h4><p>创建平台管理员帐户</p><h4 id="2-2-5-角色权限部署"><a href="#2-2-5-角色权限部署" class="headerlink" title="2.2.5 角色权限部署"></a>2.2.5 角色权限部署</h4><p>0.目的：<strong>每个用户只管理属于自己的自动化部署项目</strong><br>路径：<strong>Manage Jenkins - Manage Plugins - 可选插件</strong></p><p>1.安装所需插件：<br><strong>Role-based Authorization Strategy - 直接安装</strong><br><strong>Authorize Project - 直接安装</strong></p><p>2.部署路径：<strong>Manage Jenkins - Configure Global Security</strong><br>按图示开启用户登陆和选择Role-Based Strategy策略</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-6.png" alt=""></p><p>3.路径：<strong>Manage Jenkins - Manage and Assign Roles</strong></p><p>4.配置：</p><p><strong>帐号准备</strong><br>新建三个帐号prod、test、abc分别表示生产环境帐号、测试环境帐号、未知帐号<br>路径：<strong>管理平台页面 - 注销 - 创建一个用户帐号</strong></p><p><strong>配置Manage Roles</strong><br>在Manage Roles中有两种角色<br><strong>Global roles</strong>：分配全局策略<br><strong>Project roles</strong>：根据项目环境来分配项目权限</p><p><strong>Global roles栏</strong><br>可添加guest游客的角色，只赋予read权限（Overrall - Read），可查看全局的面板</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-7.png" alt=""></p><p><strong>Item roles栏</strong><br>可根据环境（例如生产环境、测试环境等）来进行项目分类</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-8.png" alt=""></p><p><strong>Role</strong>：分类名<br><strong>Pattern</strong>：正则表达式匹配</p><blockquote><p>例子：<br><strong>.*test</strong>    ：匹配所有以test结尾的项目，并分配图上的权限。注意使用通配符‘’时，需要在’’前添加’.’,否则无法保存并会报错。例如：.*plat</p></blockquote><p><strong>配置Assign Roles</strong><br>把具体用户（prod、test）与<strong>Manage Roles</strong>中配置的角色权限关联起来</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-9.png" alt=""></p><blockquote><p>注意：<br>Anonymous User不分配权限，只需要给admin分配管理员权限</p></blockquote><p><strong>验证权限</strong><br>新建Item：a.test和a.prod<br>路径：<strong>管理平台 - 新建Item - a.test - Freestyle project - 确定 - 返回管理平台页面</strong></p><blockquote><p>因为是测试Item，所以没有继续创建具体Item内容</p></blockquote><p><strong>admin管理用户的管理界面</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-10.png" alt=""></p><p><strong>test用户的管理界面</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-11.png" alt=""></p><p><strong>prod用户的管理界面</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-12.png" alt=""></p><blockquote><p>具体的权限在前面的<strong>Manage Roles - Item roles</strong>里根据需要进行设置</p></blockquote><p><strong>关闭用户注册入口</strong><br>路径：<strong>Manage Jenkins - Configure Global Security - 访问控制 - Jenkins’ own user database - 允许用户注册</strong><br>取消√即可</p><h3 id="2-3-Ansible安装与部署"><a href="#2-3-Ansible安装与部署" class="headerlink" title="2.3 Ansible安装与部署"></a>2.3 Ansible安装与部署</h3><h4 id="2-3-1-Ansible安装前的环境部署"><a href="#2-3-1-Ansible安装前的环境部署" class="headerlink" title="2.3.1 Ansible安装前的环境部署"></a>2.3.1 Ansible安装前的环境部署</h4><p><strong>python安装与部署</strong></p><p>1.在安装Python之前，需要先安装一些后面遇到的依赖问题（如果有依赖问题，按照提示安装）：</p><pre class="line-numbers language-java"><code class="language-java">yum <span class="token operator">-</span>y install zlib<span class="token operator">-</span>devel bzip2<span class="token operator">-</span>devel openssl<span class="token operator">-</span>devel ncurses<span class="token operator">-</span>devel sqlite<span class="token operator">-</span>devel readline<span class="token operator">-</span>devel tk<span class="token operator">-</span>devel gdbm<span class="token operator">-</span>devel db4<span class="token operator">-</span>devel libpcap<span class="token operator">-</span>devel xz<span class="token operator">-</span>devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.python压缩包下载</p><p><strong>使用命令</strong></p><pre class="line-numbers language-java"><code class="language-java">wget https<span class="token operator">:</span>\\www<span class="token punctuation">.</span>python<span class="token punctuation">.</span>org\ftp\python\<span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">5</span>\Python<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>or</p><p>*<em>进入该网址直接本地下载然后ftp方式传输至服务器上 *</em></p><blockquote><p>https:\<a href="http://www.python.org\ftp\python\">www.python.org\ftp\python\</a></p></blockquote><p>3.解压、配置与编译安装</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>解压文件tar <span class="token operator">-</span>xvf Python<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>tgz<span class="token number">2</span><span class="token punctuation">.</span>包安装在\usr\local\Python3（具体安装位置看个人喜好）mkdir <span class="token operator">-</span>p \usr\local\Python3<span class="token number">3</span><span class="token punctuation">.</span>配置cd Python<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>\configure <span class="token operator">--</span>prefix<span class="token operator">=</span>\usr\local\python3<span class="token number">4</span><span class="token punctuation">.</span>编译安装makemake install<span class="token number">5</span><span class="token punctuation">.</span>做软链接ln <span class="token operator">-</span>s \usr\local\python3\bin\python3<span class="token number">.6</span> \usr\bin\python3设置pip软连接ln <span class="token operator">-</span>s \usr\local\python3\bin\pip3<span class="token number">.6</span> \usr\bin\pip3<span class="token number">6</span><span class="token punctuation">.</span>测试是否安装成功python3 <span class="token operator">-</span>V<span class="token number">7</span><span class="token punctuation">.</span>因为yum源使用的Python2，替换为Python3以后，会导致其无法正常工作。需要修改以下信息：修改yum配置文件：vi \usr\bin\yum第一行修改为#<span class="token operator">!</span>\usr\bin\python2<span class="token number">.7</span><span class="token number">8</span><span class="token punctuation">.</span>验证yum源正常使用yum <span class="token operator">-</span>y install vim 执行两次测试安装与校验<span class="token number">9</span><span class="token punctuation">.</span>用pip安装PyQuery包pip3 install PyQuery<span class="token number">10</span><span class="token punctuation">.</span>升级pippip3 install <span class="token operator">--</span>upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-Ansible安装部署"><a href="#2-3-2-Ansible安装部署" class="headerlink" title="2.3.2 Ansible安装部署"></a>2.3.2 Ansible安装部署</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>sudo yum install epel<span class="token operator">-</span>release<span class="token number">2</span><span class="token punctuation">.</span>sudo yum install ansible<span class="token number">3</span><span class="token punctuation">.</span>pip install <span class="token operator">--</span>upgrade pip<span class="token number">4</span><span class="token punctuation">.</span>pip install paramiko PyYAML Jinja2 httplib2 six<span class="token number">5</span><span class="token punctuation">.</span>pip install ansible        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ssh免密码\密钥认证</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>本地机器上使用ssh<span class="token operator">-</span>keygen产生公钥私钥对ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa （一路回车）<span class="token number">2</span><span class="token punctuation">.</span>用ssh<span class="token operator">-</span>copy<span class="token operator">-</span>id将公钥复制到远程机器（<span class="token operator">~</span>\ <span class="token punctuation">.</span>ssh\authorized_key<span class="token punctuation">.</span>文件）中ssh<span class="token operator">-</span>copy<span class="token operator">-</span>id <span class="token operator">-</span>i \root\<span class="token punctuation">.</span>ssh\id_rsa<span class="token punctuation">.</span>pub 用户名<span class="token annotation punctuation">@192</span><span class="token punctuation">.</span><span class="token number">168</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span>xxx（\root\<span class="token punctuation">.</span>ssh\id_rsa<span class="token punctuation">.</span>pub这个路径有可能不同，以自身具体路径准，详见下方截图）<span class="token number">3</span><span class="token punctuation">.</span>输入yes继续连接，输入远程服务器的密码<span class="token punctuation">(</span>密钥文件的形式不需要输入密码，但<span class="token punctuation">)</span><span class="token number">4</span><span class="token punctuation">.</span>ssh方式登录远程服务器验证免密是否生效<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>密码方式：ssh 用户名<span class="token annotation punctuation">@192</span><span class="token punctuation">.</span><span class="token number">168</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>密钥方式：需要对密钥文件权限进行修改<span class="token operator">-</span>禁止文件的访问权限，否则系统会判断该文件可能被篡改而无法使用该密钥进行登录chmod <span class="token number">700</span> filenamessh <span class="token operator">-</span>i 密钥文件路径 用户名<span class="token annotation punctuation">@192</span><span class="token punctuation">.</span><span class="token number">168</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span>xxx<span class="token number">5</span><span class="token punctuation">.</span>完成ssh免密码\密钥认证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-13.png" alt=""></p><p><strong>Jenkins ansible插件安装</strong></p><p>路径：*<em>Manage Jenkins - Manage Plugins - 可选插件 *</em></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-14.png" alt=""></p><blockquote><p>未找到可能是因为已经安装了，在已安装里寻找</p></blockquote><h3 id="2-4-其他补充部署"><a href="#2-4-其他补充部署" class="headerlink" title="2.4 其他补充部署"></a>2.4 其他补充部署</h3><h4 id="2-4-1-Jenkins关于jdk的部署"><a href="#2-4-1-Jenkins关于jdk的部署" class="headerlink" title="2.4.1 Jenkins关于jdk的部署"></a>2.4.1 Jenkins关于jdk的部署</h4><p>路径：<strong>Manage Jenkins - Global Tool Configuration - JDK</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-15.png" alt=""></p><p>JAVA_HOME填写jre路径（以自己实际路径为准）</p><blockquote><p>红色警告无伤大雅，配置是正确的</p></blockquote><h4 id="2-4-2-Jenkins关于maven的部署"><a href="#2-4-2-Jenkins关于maven的部署" class="headerlink" title="2.4.2 Jenkins关于maven的部署"></a>2.4.2 Jenkins关于maven的部署</h4><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-16.png" alt=""></p><h2 id="3-新建Item完成自动化部署"><a href="#3-新建Item完成自动化部署" class="headerlink" title="3. 新建Item完成自动化部署"></a>3. 新建Item完成自动化部署</h2><h3 id="3-1-新建Item"><a href="#3-1-新建Item" class="headerlink" title="3.1 新建Item"></a>3.1 新建Item</h3><p>1.路径：<strong>Jenkins工作台 - 新建Item - 输入任务名称(例：abc.test) - 选择Freestyle project - 确定</strong></p><blockquote><p>Freestyle在普通集成中一般足够使用，如果现实业务中有复杂的逻辑而Freestyle无法满足时，建议可以使用Jenkins 流水线(pipeline)编写pipeline脚本来实现自定义逻辑。<br>流水线写法可参考：<strong>ip地址:port端口号\job\pipeline.test\pipeline-syntax\</strong>(例：http:\192.168.10.132:8080\job\pipeline.test\pipeline-syntax)<br><strong>流水线example</strong>：https:\jenkins.io\doc\pipeline\examples\</p></blockquote><p>2.<strong>This project is parameterized</strong>（项目参数配置）</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-17.png" alt=""></p><p>(1) <strong>添加git分支选择参数 - Git Parameter</strong></p><blockquote><p>添加该参数的作用是在部署该Item时，部署人员可以动态选择git remote branchs中的任意分支，实现灵活部署</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-18.png" alt=""></p><p>(2) <strong>源码管理 - Git\Multiple SCMs</strong></p><p>预备：<strong>添加Git凭据</strong><br>路径：<strong>工作台 - 凭据 - Stores scoped to Jenkins - Jenkins -     全局凭据 (unrestricted) - 添加一些凭据</strong><br>填写用户名密码保存即可</p><blockquote><p>需要从git\svn拉取多个项目情况需要安装<strong>Multiple SCMs plugin</strong>插件</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-19.png" alt=""></p><p>$ + 前面设置的参数名(例如：$playbookBranch)<br>实现动态选择远程分支的作用</p><p>(3) <strong>构建 - Maven</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-20.png" alt=""></p><p>Maven构建模块可以用来对项目进行install\package等操作</p><p>(4) <strong>构建  - Ansible playbook</strong></p><p>Ansible Playbooks常用模块介绍：</p><blockquote><p>http:\note.youdao.com\noteshare?id=0bfc53f1b967f11d8f7e26ce38cbb6d8</p></blockquote><p>Playbooks框架与格式介绍：</p><blockquote><p>http:\note.youdao.com\noteshare?id=d0d98975bc335c3e12fa73274e62c41f</p></blockquote><p>简单的ansible task脚本例子：</p><pre class="line-numbers language-java"><code class="language-java">  # 上传jar包到远程服务器指定目录下  # <span class="token punctuation">{</span><span class="token punctuation">{</span>appPkgSrcDir<span class="token punctuation">}</span><span class="token punctuation">}</span> 这些参数在inventory文件中定义  <span class="token operator">-</span> name<span class="token operator">:</span> upload jar file to server    tags<span class="token operator">:</span>     <span class="token operator">-</span> upload     <span class="token operator">-</span> test    copy<span class="token operator">:</span>     src<span class="token operator">:</span> <span class="token string">"{{ appPkgSrcDir }}\{{appName}}"</span>     dest<span class="token operator">:</span> <span class="token string">"{{appDeployDest}}"</span>  # 得到指定应用的pid  <span class="token operator">-</span> name<span class="token operator">:</span> get pid of service    shell<span class="token operator">:</span> <span class="token string">"ps -ef | grep -v grep | grep {{serviceName}} | awk '{print $2}'"</span>    register<span class="token operator">:</span> pid  # 展示pid  <span class="token operator">-</span> name<span class="token operator">:</span> display pid    debug<span class="token operator">:</span> msg<span class="token operator">=</span><span class="token string">"{{pid.stdout}}"</span>  <span class="token operator">-</span> name<span class="token operator">:</span> source profile    shell<span class="token operator">:</span> <span class="token string">"source \etc\profile"</span>  # 强制kill进程<span class="token punctuation">(</span>生产环境不建议直接这样操作<span class="token punctuation">)</span>  <span class="token operator">-</span> name<span class="token operator">:</span> Force kill stuck processes    shell<span class="token operator">:</span> <span class="token string">"kill -9 {{ pid.stdout }}"</span>  <span class="token operator">-</span> name<span class="token operator">:</span> sleep 2s     command<span class="token operator">:</span> sleep 2s  # 开启服务  <span class="token operator">-</span> name<span class="token operator">:</span> start <span class="token punctuation">{</span><span class="token punctuation">{</span>serviceName<span class="token punctuation">}</span><span class="token punctuation">}</span>    shell<span class="token operator">:</span> <span class="token string">"cd \data\mbApp\pay-mgt;nohup \home\jdk\jdk1.8.0_152\bin\java -jar {{appName}} --spring.profiles.active=test > nohup.out 2>&amp;1 &amp;"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这个例子比较简单，只适合在开发\测试环境进行测试时为了便捷而使用</p></blockquote><p><strong>Jenkins Ansible配置</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-21.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-22.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动化部署与持续交付&quot;&gt;&lt;a href=&quot;#自动化部署与持续交付&quot; class=&quot;headerlink&quot; title=&quot;自动化部署与持续交付&quot;&gt;&lt;/a&gt;自动化部署与持续交付&lt;/h1&gt;&lt;p&gt;日常工作中，每个程序员都会经历&lt;strong&gt;项目部署&lt;/strong&gt;，而
      
    
    </summary>
    
    
      <category term="运维部署" scheme="http://xuyk.top/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="operation" scheme="http://xuyk.top/tags/operation/"/>
    
  </entry>
  
</feed>
