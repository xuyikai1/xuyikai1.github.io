<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寒暄</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xuyk.top/"/>
  <updated>2021-03-09T02:55:22.096Z</updated>
  <id>http://xuyk.top/</id>
  
  <author>
    <name>Xuyk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis灵魂拷问系列之如何保证数据库和缓存双写一致性</title>
    <link href="http://xuyk.top/posts/interview-redis-database-writeConsistency.html"/>
    <id>http://xuyk.top/posts/interview-redis-database-writeConsistency.html</id>
    <published>2021-03-09T02:55:00.000Z</published>
    <updated>2021-03-09T02:55:22.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis灵魂拷问系列之如何保证数据库和缓存双写一致性"><a href="#redis灵魂拷问系列之如何保证数据库和缓存双写一致性" class="headerlink" title="redis灵魂拷问系列之如何保证数据库和缓存双写一致性"></a>redis灵魂拷问系列之如何保证数据库和缓存双写一致性</h1><h2 id="1-什么是数据库缓存双写一致性呢？"><a href="#1-什么是数据库缓存双写一致性呢？" class="headerlink" title="1.什么是数据库缓存双写一致性呢？"></a>1.什么是数据库缓存双写一致性呢？</h2><p>一般为了加快查询响应速度等，我们通过加缓存来提高接口的QPS，例如redis缓存、JVM缓存等。</p><p>数据是 <strong>缓存和数据库共享的</strong>。在 <strong>高并发场景下更新数据</strong> 时，因为数据库和缓存都要更新，就很可能会有数据一致性问题，其实也是分布式场景下数据一致性的问题</p><blockquote><p>什么时候会发生数据库缓存双写不一致的情况呢？</p></blockquote><p>例如：高并发场景下，先更新数据库，再删除缓存之后，另外一个线程把旧数据存入缓存</p><h2 id="2-选择更新缓存还是删除缓存？"><a href="#2-选择更新缓存还是删除缓存？" class="headerlink" title="2.选择更新缓存还是删除缓存？"></a>2.选择更新缓存还是删除缓存？</h2><p>这里就需要提到<strong>Cache Aside Pattern</strong>，也是我们日常编码中一般会采取的策略 </p><ol><li>读取数据时，先读缓存，缓存不存在再读数据库，然后把结果存入缓存</li><li>更新数据时，先更新数据库，再删除缓存</li></ol><p><strong>为什么是删除缓存不是更新缓存呢？</strong></p><p>假如为 <strong>更新缓存</strong></p><ul><li>如果数据更新频繁，则每一次都需要更新缓存，如果加上还是联表查询，则更新缓存的代价就很大</li><li>如果数据不会被频繁查询到（冷数据），这时候频繁更新缓存则是在浪费资源（例如数据A一分钟内被更新20次，但是只查询了一次）</li><li>还可能存在更新缓存失败的情况</li></ul><p>假如为 <strong>删除缓存</strong></p><ul><li>数据在删除后，第一次被访问时，会从数据库读取（类似懒加载方式），保证了只有被用到才去操作，减少了资源浪费</li></ul><blockquote><p>所以当之无愧，选择 <strong>删除缓存</strong></p></blockquote><h2 id="3-先更新数据库，还是先删除缓存？"><a href="#3-先更新数据库，还是先删除缓存？" class="headerlink" title="3.先更新数据库，还是先删除缓存？"></a>3.先更新数据库，还是先删除缓存？</h2><ol><li><strong>先删除缓存，删除成功后去更新数据库</strong>。会出现问题：高并发场景下，删除成功后，可能另外一个请求查询后又把旧数据存入缓存中。这时候要么采用 <strong>延迟双删</strong>，也就是睡眠一定时间后再次删除一次，要么选择下一种做法</li><li><strong>先更新数据库，再删除缓存</strong>。会出现问题：高并发下，在删除成功后，可能其他线程把旧数据再存入缓存中的问题。也会出现数据不一致的情况（影响相对较小所以可以接受）</li></ol><h2 id="4-具体落地的解决策略有哪些？"><a href="#4-具体落地的解决策略有哪些？" class="headerlink" title="4.具体落地的解决策略有哪些？"></a>4.具体落地的解决策略有哪些？</h2><p><strong>（1）延时双删策略</strong></p><ul><li>a. 删除缓存 </li><li>b. 更新数据库 </li><li>c. 睡眠一段时间，具体多长有业务决定（mysql读写分离的话还需要加上主从同步时间）</li><li>d. 再删除缓存（吞吐量降低的话使用 <strong>异步</strong>）</li></ul><p><strong>（2）更新数据库、后删缓存</strong></p><p><strong>（3）串行化思维保证两者的最终一致性</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-binlog-mq.jpg" alt=""></p><p>利用binlog天然的顺序性用来做同步操作，顺序删除缓存，删除缓存失败则使用消息队列的同步性重试删除缓存</p><p><strong>（4）强一致性</strong></p><blockquote><p>如果需要保证强一致性，那么是否还有添加缓存的必要（没有海量qps的情况下）？</p></blockquote><p>可以参考这篇文章：<a href="https://blog.kido.site/2018/12/09/db-and-cache-04/">缓存与数据库一致性系列-04 - Kido的博客 | Kido’s Blog</a></p><blockquote><p>【参考链接】<br>1：<a href="https://zhuanlan.zhihu.com/p/59167071">Redis与Mysql双写一致性方案解析</a><br>2：<a href="https://blog.kido.site/2018/12/08/db-and-cache-03/">缓存与数据库一致性系列-03</a><br>3：<a href="https://blog.kido.site/2018/12/09/db-and-cache-04/">缓存与数据库一致性系列-04</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;redis灵魂拷问系列之如何保证数据库和缓存双写一致性&quot;&gt;&lt;a href=&quot;#redis灵魂拷问系列之如何保证数据库和缓存双写一致性&quot; class=&quot;headerlink&quot; title=&quot;redis灵魂拷问系列之如何保证数据库和缓存双写一致性&quot;&gt;&lt;/a&gt;redis
      
    
    </summary>
    
    
      <category term="Redis灵魂拷问系列" scheme="http://xuyk.top/categories/Redis%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="数据库和缓存双写一致性" scheme="http://xuyk.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Redis灵魂拷问系列之过期策略与数据持久化</title>
    <link href="http://xuyk.top/posts/interview-redis-data-expireAndStore.html"/>
    <id>http://xuyk.top/posts/interview-redis-data-expireAndStore.html</id>
    <published>2021-03-02T06:52:00.000Z</published>
    <updated>2021-03-02T06:53:08.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis灵魂拷问系列之过期策略与数据持久化"><a href="#Redis灵魂拷问系列之过期策略与数据持久化" class="headerlink" title="Redis灵魂拷问系列之过期策略与数据持久化"></a>Redis灵魂拷问系列之过期策略与数据持久化</h1><h2 id="1-redis过期策略能说一下吗"><a href="#1-redis过期策略能说一下吗" class="headerlink" title="1.redis过期策略能说一下吗"></a>1.redis过期策略能说一下吗</h2><h3 id="1-1-redis为什么需要过期策略"><a href="#1-1-redis为什么需要过期策略" class="headerlink" title="1.1 redis为什么需要过期策略"></a>1.1 redis为什么需要过期策略</h3><p>我们平常用 redis 做缓存时，可能会有一些问题：为什么有的key塞入之后就会消失，如果真的发现这样的情况，说明可能 redis 没有用对。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-stageTime.png" alt="图量化系统的各种延时时间图"></p><p>redis 本质上属于 <strong>内存数据库</strong>，把内存当作缓存使用，可以从图中看出，内存属于 ns 级别，可见速度是很快的。但是内存也是宝贵的，可以从几千的电脑只有 那么16、32G的内存，而可以有1T的硬盘中看出。</p><p>当内存被你不断塞入的数据给塞满，那么 redis 就会在你再次塞入数据时根据一些算法（LRU、LFU等）给你淘汰一些数据，才能保证你能存入数据</p><h3 id="1-2-定期删除、惰性删除"><a href="#1-2-定期删除、惰性删除" class="headerlink" title="1.2 定期删除、惰性删除"></a>1.2 定期删除、惰性删除</h3><p>redis使用 <strong>定期删除 + 惰性删除</strong> 的方式淘汰过期数据</p><ul><li><strong>定期删除</strong>：redis在定期删除（比如100ms）时，不会每次都把过期的key全部删除，而是随机抽取一些过期数据进行删除</li><li><strong>惰性删除</strong>：当过期数据被访问时，redis 会进行检查，如果过期则进行删除</li></ul><p>但是这样还是会有一些问题，如果过期数据定期删除时一直未被删除，又一直未被查询导致不走惰性删除，那么还是会一直占据着内存空间，最终导致内存占满。redis 使用 <strong>内存淘汰机制</strong> 来处理这一问题。</p><h3 id="1-3-内存淘汰机制"><a href="#1-3-内存淘汰机制" class="headerlink" title="1.3 内存淘汰机制"></a>1.3 内存淘汰机制</h3><p>redis在内存占用过多时，会自行使用一些淘汰算法，淘汰一些数据</p><ul><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）</li><li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</li><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错（很少用）</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key（很少用）</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key（很少用）</li></ul><h3 id="1-4-可以手写一个LRU算法吗"><a href="#1-4-可以手写一个LRU算法吗" class="headerlink" title="1.4 可以手写一个LRU算法吗"></a>1.4 可以手写一个LRU算法吗</h3><p>我们可以基于Java的数据结构 <strong>LinkedHashMap</strong> 来写一个</p><p>大致思路：创建LRUCache类，继承LinkedHashMap类，定义一个存放数据数量的阈值，编写构造器方法，使用LinkedHashMap类的构造器方法，设置初始容量、负载因子以及按访问顺序排序（true），重写<code>removeEldestEntry()</code>方法，设置当容量超过阈值时，会把最少访问的数据删除</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CACHE_SIZE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 传递进来最多能缓存多少数据     *     * @param cacheSize 缓存大小     */</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>cacheSize <span class="token operator">/</span> <span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CACHE_SIZE <span class="token operator">=</span> cacheSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> CACHE_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-redis持久化RDB和AOF"><a href="#2-redis持久化RDB和AOF" class="headerlink" title="2.redis持久化RDB和AOF"></a>2.redis持久化RDB和AOF</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-RDB-AOF.png" alt=""></p><blockquote><p>也不妨瞧瞧官方怎么说的：<a href="http://www.redis.cn/topics/persistence.html">REDIS persistence</a></p></blockquote><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/8HN1PqqU57Kdz9ERwDY2cw">Redis 核心篇：唯快不破的秘密</a><br>2：<a href="https://www.cnblogs.com/madashu/p/12832766.html">Redis 6.0 新特性-多线程连环13问！</a><br>3：<a href="http://www.redis.cn/">redis中文官方网站</a><br>4：<a href="http://www.redis.cn/topics/persistence.html">redis 数据持久化-官方网站</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis灵魂拷问系列之过期策略与数据持久化&quot;&gt;&lt;a href=&quot;#Redis灵魂拷问系列之过期策略与数据持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis灵魂拷问系列之过期策略与数据持久化&quot;&gt;&lt;/a&gt;Redis灵魂拷问系列之过期策略与数据持
      
    
    </summary>
    
    
      <category term="Redis灵魂拷问系列" scheme="http://xuyk.top/categories/Redis%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Redis过期策略" scheme="http://xuyk.top/tags/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/"/>
    
      <category term="Redis数据持久化" scheme="http://xuyk.top/tags/Redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Redis灵魂拷问系列之数据结构和单线程模型</title>
    <link href="http://xuyk.top/posts/interview-redis-structure.html"/>
    <id>http://xuyk.top/posts/interview-redis-structure.html</id>
    <published>2021-02-27T11:29:00.000Z</published>
    <updated>2021-03-02T06:53:32.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis灵魂拷问系列之数据结构和单线程模型"><a href="#Redis灵魂拷问系列之数据结构和单线程模型" class="headerlink" title="Redis灵魂拷问系列之数据结构和单线程模型"></a>Redis灵魂拷问系列之数据结构和单线程模型</h1><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/8HN1PqqU57Kdz9ERwDY2cw">Redis 核心篇：唯快不破的秘密</a><br>2：<a href="https://www.cnblogs.com/madashu/p/12832766.html">Redis 6.0 新特性-多线程连环13问！</a><br>3：<a href="http://www.redis.cn/">redis中文官方网站</a><br>4：<a href="https://mp.weixin.qq.com/s/DC-xgcOyX3lBb1pwm---ZA">redis三种高级数据结构</a><br>5：<a href="https://www.jianshu.com/p/4c8e119f35db">redis 学习（13）– BitMap</a><br>6：<a href="https://zhuanlan.zhihu.com/p/92538808">Redis 到底是怎么实现“附近的人”这个功能的呢？</a></p></blockquote><p>[TOC]</p><h2 id="1-说说Redis单线程模型，为什么单线程还有很高的效率"><a href="#1-说说Redis单线程模型，为什么单线程还有很高的效率" class="headerlink" title="1.说说Redis单线程模型，为什么单线程还有很高的效率"></a>1.说说Redis单线程模型，为什么单线程还有很高的效率</h2><p>我们要明确的是：<strong>Redis 的单线程指的是 Redis 的网络 IO 以及键值对指令读写是由一个线程来执行的</strong>，对于 Redis 的持久化、集群数据同步、异步删除等都是 <strong>其他线程</strong> 执行。</p><blockquote><p>根据官方数据，Redis 的 QPS 可以达到约 100000（每秒请求数），有兴趣的可以参考官方的基准程序测试《How fast is Redis？》，地址：<a href="https://redis.io/topics/benchmarks">https://redis.io/topics/benchmarks</a></p></blockquote><p>一般的网络IO流程大致有以下事件</p><ul><li>listen 监听客户端请求</li><li>accept 建立客户端连接</li><li>receive 读取客户端请求</li><li>write 写入/响应数据</li></ul><p>如果是传统同步阻塞IO的话，在上述各操作未处理完毕时都会处于阻塞等待状态；而redis采用IO多路复用，不会阻塞在某一个特定的处理上，借此可以同时处理多个客户端的请求，提升并发性</p><p><strong>IO多路复用</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-io-multiplexing.png" alt=""></p><p>redis采用IO多路复用的方式，通过复用一个线程，来同时监听多个socket连接，根据标识符判断socket是否就绪（可建立连接、可读等），已就绪就将socket放入一个阻塞队列中。</p><p>由一个 <strong>文件事件分派器</strong> 依次不断地从队列中取出socket，再针对socket需要处理的事件类型来指派给对应的处理器</p><ol><li><strong>连接应答处理器</strong>：处理客户端连接请求</li><li><strong>命令请求处理器</strong>：处理redis命令请求</li><li><strong>命令回复处理器</strong>：redis命令请求由 <strong>命令请求处理器</strong> 处理完毕后关联至 <strong>命令回复处理器</strong> 来返回命令请求相关响应</li></ol><p><strong>为什么redis单线程模型效率也能这么高？</strong></p><ol><li>纯内存操作，属于纳秒级别</li><li>高效率的核心是使用了非阻塞的IO多路复用机制</li><li>单线程反而避免了多线程频繁切换上下文耗费资源的问题</li></ol><h2 id="2-那为什么redis-6-0又引入了多线程呢"><a href="#2-那为什么redis-6-0又引入了多线程呢" class="headerlink" title="2.那为什么redis 6.0又引入了多线程呢"></a>2.那为什么redis 6.0又引入了多线程呢</h2><p>严格来讲，redis 4.0之后都是用的多线程，而网络 IO 以及键值对指令读写是由单线程处理，对于 Redis 的持久化、集群数据同步、异步删除等都是 其他线程 执行。</p><p>redis 6.0默认关闭多线程，如若要开启，需要在 redis.conf 文件中 <strong>io-threads-do-reads yes</strong>，并且设置线程数 <strong>io-threads 4</strong></p><blockquote><p>官方建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数</p></blockquote><p>开启IO多线程确实可以显著提升性能，但是如果要开启多线程，至少要4核的机器，且Redis实例已经占用相当大的CPU耗时的时候才建议采用，否则使用多线程没有意义。所以估计80%的公司开发人员看看就好</p><h2 id="3-redis都有哪些基本数据结构？分别在哪些场景下使用比较合适？"><a href="#3-redis都有哪些基本数据结构？分别在哪些场景下使用比较合适？" class="headerlink" title="3.redis都有哪些基本数据结构？分别在哪些场景下使用比较合适？"></a>3.redis都有哪些基本数据结构？分别在哪些场景下使用比较合适？</h2><h3 id="3-1-String"><a href="#3-1-String" class="headerlink" title="3.1 String"></a>3.1 String</h3><p><strong>简单的key/value结构</strong></p><ol><li>一般用来做 <strong>缓存、分布式锁</strong> 等，其中分布式锁一般涉及到的就是setnx以及expire等命令</li></ol><blockquote><p>string 命令笔记：<a href="http://note.youdao.com/s/WNOIrxPQ">redis string</a></p></blockquote><h3 id="3-2-Hash"><a href="#3-2-Hash" class="headerlink" title="3.2 Hash"></a>3.2 Hash</h3><p><strong>类似map的结构</strong></p><ol><li>一般存放一些对象，比如用户信息等，可以指定修改对象其中的某个属性</li></ol><blockquote><p>hash 命令笔记：<a href="http://note.youdao.com/s/EnT00O13">redis hash</a></p></blockquote><h3 id="3-3-List"><a href="#3-3-List" class="headerlink" title="3.3 List"></a>3.3 List</h3><p>属于 <strong>有序队列</strong></p><ol><li>一般可以用来保存 <strong>粉丝列表、评论列表</strong> 等，其中的lrange命令可以实现高性能的分页功能，很实用；</li><li>也可以用来当做 <strong>简单的消息队列</strong> （lpush、rpop命令）使用，如果你的项目没有引入第三方消息队列组件，而依赖redis，不妨用redis做一个消息队列玩玩</li></ol><blockquote><p>list 命令笔记：<a href="http://note.youdao.com/s/AUfgbHFC">redis list</a></p></blockquote><h3 id="3-4-Set"><a href="#3-4-Set" class="headerlink" title="3.4 Set"></a>3.4 Set</h3><p><strong>无需集合、自动去重</strong></p><ol><li>单机场景可以使用jvm中的HashSet去重，在多台机器上则可以直接使用redis set；</li><li>可以基于set做一些交集、并集、差集的操作，例如QQ中两人的共同好友（交集）</li></ol><blockquote><p>set 命令笔记：<a href="http://note.youdao.com/s/Sgb2Y2KA">redis set</a></p></blockquote><h3 id="3-5-Zset（sorted-set）"><a href="#3-5-Zset（sorted-set）" class="headerlink" title="3.5 Zset（sorted set）"></a>3.5 Zset（sorted set）</h3><p><strong>排序的set</strong>，既可以去重也可以排序，每个key写入时会给一个 <strong>分数score</strong> ，redis自动根据分数进行排序</p><ol><li>可以做一些  <strong>访问量/点击量排行榜</strong></li></ol><blockquote><p>zset 命令笔记：<a href="http://note.youdao.com/s/Nw7KLxLR">redis zset</a></p></blockquote><h2 id="4-那redis有没有哪些高级数据结构平常可以使用到呢？"><a href="#4-那redis有没有哪些高级数据结构平常可以使用到呢？" class="headerlink" title="4.那redis有没有哪些高级数据结构平常可以使用到呢？"></a>4.那redis有没有哪些高级数据结构平常可以使用到呢？</h2><h3 id="4-1-bitMap-位图"><a href="#4-1-bitMap-位图" class="headerlink" title="4.1 bitMap 位图"></a>4.1 bitMap 位图</h3><p>bitMaps并不是真实的数据结构，其实是个 byte 数组，用二进制表示，只有 0 和 1 两个数字</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-bitMap.png" alt=""></p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> setbit login_2019_06_17  <span class="token number">10000</span> <span class="token function">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> setbit login_2019_06_17  <span class="token number">1024</span> <span class="token function">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> setbit login_2019_06_17  <span class="token number">238</span> <span class="token function">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> setbit login_2019_06_17  <span class="token number">3434</span> <span class="token function">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> bitcount <span class="token function">login_2019_06_17</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用场景</strong></p><ol><li>用户签到、统计用户登录情况（活跃用户）、用户是否在线</li><li>实现布隆过滤器，避免推荐给用户已推荐的数据</li></ol><blockquote><p>布隆过滤器详情可以看看这篇文章：<a href="http://xuyk.top/posts/bloom-filter.html">5分钟搞懂布隆过滤器</a></p></blockquote><h3 id="4-2-HyperLogLog"><a href="#4-2-HyperLogLog" class="headerlink" title="4.2 HyperLogLog"></a>4.2 HyperLogLog</h3><p>Redis HyperLogLog 是用来做 <strong>基数统计</strong> 的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p><strong>使用场景</strong></p><ol><li>统计用户日活月活</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> pfadd login<span class="token punctuation">.</span>2019_06_17 <span class="token function">user1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span>  pfadd login<span class="token punctuation">.</span>2019_06_17 <span class="token function">user2</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span>  pfadd login<span class="token punctuation">.</span>2019_06_17 <span class="token function">user3</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span>  pfadd login<span class="token punctuation">.</span>2019_06_17 <span class="token function">user4</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> pfcount login<span class="token punctuation">.</span><span class="token function">2019_06_17</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是HyperLogLog的统计结果并不是一个精确的值，误差在0.81%左右，但是对于统计用户数这种场景来说足够了</p></blockquote><h3 id="4-3-Geo"><a href="#4-3-Geo" class="headerlink" title="4.3 Geo"></a>4.3 Geo</h3><p>这个功能可以将 <strong>用户给定的地理位置（经度和纬度）信息</strong> 储存起来，并对这些信息进行操作。</p><p><strong>使用场景</strong></p><ol><li>附近的人</li></ol><p><a href="https://zhuanlan.zhihu.com/p/92538808">Redis 到底是怎么实现“附近的人”这个功能的呢？</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis灵魂拷问系列之数据结构和单线程模型&quot;&gt;&lt;a href=&quot;#Redis灵魂拷问系列之数据结构和单线程模型&quot; class=&quot;headerlink&quot; title=&quot;Redis灵魂拷问系列之数据结构和单线程模型&quot;&gt;&lt;/a&gt;Redis灵魂拷问系列之数据结构和单线程
      
    
    </summary>
    
    
      <category term="Redis灵魂拷问系列" scheme="http://xuyk.top/categories/Redis%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Redis单线程模型" scheme="http://xuyk.top/tags/Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="Redis数据结构" scheme="http://xuyk.top/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络灵魂拷问系列之基础问答</title>
    <link href="http://xuyk.top/posts/interview-net-base.html"/>
    <id>http://xuyk.top/posts/interview-net-base.html</id>
    <published>2021-02-24T08:19:00.000Z</published>
    <updated>2021-02-24T08:31:06.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络灵魂拷问系列之基础问答"><a href="#计算机网络灵魂拷问系列之基础问答" class="headerlink" title="计算机网络灵魂拷问系列之基础问答"></a>计算机网络灵魂拷问系列之基础问答</h1><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/94sx4QID">有道云笔记-网络</a></p></blockquote><h2 id="1-浏览器请求www-baidu-com的全过程大概是怎么样的？"><a href="#1-浏览器请求www-baidu-com的全过程大概是怎么样的？" class="headerlink" title="1. 浏览器请求www.baidu.com的全过程大概是怎么样的？"></a>1. 浏览器请求<a href="http://www.baidu.com的全过程大概是怎么样的？">www.baidu.com的全过程大概是怎么样的？</a></h2><h3 id="1-1-DNS解析"><a href="#1-1-DNS解析" class="headerlink" title="1.1 DNS解析"></a>1.1 DNS解析</h3><p>根据输入的域名去当前设置的DNS服务器中查询该域名对应的ip地址</p><h3 id="1-2-封装报文"><a href="#1-2-封装报文" class="headerlink" title="1.2 封装报文"></a>1.2 封装报文</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-DataPackage.png" alt=""></p><p>根据计算机网络的四层/七层模型，从上往下依次进行操作：</p><ol><li><strong>应用层</strong>：根据 <strong>HTTP协议</strong> 封装数据包，其中包括请求类型、请求地址、请求头、请求内容、HTTP版本等信息</li><li><strong>表示层/会话层</strong>：数据加密，通过三次握手建立连接等</li><li><strong>传输层</strong>：根据 <strong>TCP协议</strong> 把应用层封装的数据包再封装一层tcp协议的相关信息，设置 <strong>发送者/接收者的端口号</strong> 等信息</li><li><strong>网络层</strong>：根据 <strong>IP协议</strong> 把网络层封装的数据包再封装一层ip协议的相关信息，设置 <strong>发送者/接收者的ip地址</strong> 等信息</li><li><strong>数据链路层/物理层等</strong>：根据 <strong>以太网协议</strong> 把网络层封装的数据包再封装一层ip协议的相关信息，设置发送者/接收者的mac地址等信息（因为通过ip地址和子网掩码与操作后192.168.1这样的二进制信息不一致，所以接收者的mac地址设置的是 <strong>网关/路由器的mac地址</strong> ，通过 <strong>广播</strong> 的方式层层网关下发送到目标服务器）</li><li><strong>服务器</strong> 接收到多个数据包，根据数据包的序号排列再拼接成一个完整的数据包，对数据包依次进行处理解析出具体请求，转发请求给对应的应用（例如tomcat）上进行处理。<strong>应用</strong> 处理后返回响应数据包，按照原链路返回给请求浏览器，<strong>浏览器</strong> 解析渲染结果到页面上，再通过<strong>四次挥手断开连接</strong></li></ol><blockquote><p>以太网默认数据包大小限制是 <strong>1500字节</strong>，如果ip数据包为5000字节，则会分为4个数据包发送（1500，1500，1500，500）</p></blockquote><h2 id="2-画一下TCP三次握手-四次挥手流程图？什么是三次握手不是两次呢？"><a href="#2-画一下TCP三次握手-四次挥手流程图？什么是三次握手不是两次呢？" class="headerlink" title="2. 画一下TCP三次握手/四次挥手流程图？什么是三次握手不是两次呢？"></a>2. 画一下TCP三次握手/四次挥手流程图？什么是三次握手不是两次呢？</h2><h3 id="2-1-三次握手-建立连接流程"><a href="#2-1-三次握手-建立连接流程" class="headerlink" title="2.1 三次握手-建立连接流程"></a>2.1 三次握手-建立连接流程</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-3Hands.png" alt=""></p><ol><li><strong>握手1</strong>：客户端发送建立连接报文，表示想与服务端建立起连接，自身进入发送状态</li><li><strong>握手2</strong>：服务端返回确认报文，表示收到客户端握手1的请求报文了，并且成功开辟好资源等待连接，自身进入接收状态</li><li><strong>握手3</strong>：客户端返回确认报文，表示收到服务端握手2的确认报文了，同时为了防止自己握手1时可能 <strong>多次发送握手1</strong> 的情况发生 <strong>会告诉服务端把其他连接的资源释放免得浪费</strong></li></ol><p>通过 <strong>传输层的tcp协议</strong> 建立网络连接的时候，其实就是走的三次握手的过程</p><p>通过根据约好的协议在 <strong>数据包请求头里设kv</strong> 来建立连接</p><p>三次握手的意义是为了 <strong>验证客户/服务端双方是否有收发数据的能力</strong> </p><p>首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。</p><p>于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。</p><p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。</p><h3 id="2-2-为什么是三次握手而不是两次呢"><a href="#2-2-为什么是三次握手而不是两次呢" class="headerlink" title="2.2 为什么是三次握手而不是两次呢"></a>2.2 为什么是三次握手而不是两次呢</h3><p>如果是 <strong>两次握手</strong> 的话，有一种情况会出现问题：</p><ol><li>客户端 <strong>第一次发起握手1</strong> ，可能由于网络抖动或者系统资源等原因 <strong>卡在半路上</strong></li><li>客户端尝试 <strong>第二次发起握手1</strong> ，这次发起成功，服务端发起第二次握手的同时会开辟资源，等待客户端发送数据。因为只有两次握手，所以这里代表此次建立连接成功</li><li>但是客户端 <strong>第一次发起的握手1</strong> 阻塞结束成功发送到了服务端，那么服务端也会继续发起握手2、开辟资源，而客户端因为 <strong>没有握手3来复位连接让服务端撤回开辟的资源</strong> ，导致服务端资源被浪费</li></ol><blockquote><p>第三次握手作用：在发送了多次握手1时，会复位连接，保证服务端的资源不被浪费</p></blockquote><h3 id="2-3-四次挥手-断开连接流程"><a href="#2-3-四次挥手-断开连接流程" class="headerlink" title="2.3 四次挥手-断开连接流程"></a>2.3 四次挥手-断开连接流程</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-4Hands.png" alt=""></p><ol><li><strong>挥手1</strong>：客户端发送断开连接的报文，表示要关闭双方之间的连接，自身进入等待关闭连接的状态1</li><li><strong>挥手2</strong>：服务端收到报文，进入等待关闭连接的状态，返回确认报文，这时客户端到服务端的连接就释放了，客户端收到报文时进入等待关闭状态2</li><li><strong>挥手3</strong>：服务端发送连接释放报文，表示释放服务端到客户端的连接，自身进入连接关闭的最后确认状态</li><li><strong>挥手4</strong>：客户端收到报文后发送应答报文，进入等待释放连接的状态，过一段时间进入连接关闭状态，</li></ol><p>第一步：客户端C和服务端S说：我要断开和你的连接（C -&gt; S）<br>第二步：服务端收到后返回表示同意，那么C -&gt; S这条线就可以断开了<br>第三步：服务端和客户端说：我也要断开和你的连接（S -&gt; C）<br>第四步：客户端收到后返回表示同意，那么等服务端这边东西全部给客户端传完之后，那么S -&gt; C这条线也就断开了</p><h2 id="3-HTTP的工作原理是什么"><a href="#3-HTTP的工作原理是什么" class="headerlink" title="3. HTTP的工作原理是什么"></a>3. HTTP的工作原理是什么</h2><p>HTTP有1.0、1.1、2.0版本，底层都是在以太网协议、TCP协议、IP协议之上封装的HTTP协议，各个版本请求报文会有些许不同，但是基本相通的就有请求头、请求体、请求方法、响应状态码等</p><ol><li><strong>HTTP1.0</strong>：在2000年之前，早期的网页只有文字，使用的是 <strong>TCP短连接</strong> ，浏览器通过三次握手建立连接与服务器进行通信，接收到响应渲染到出来后，就会四次挥手断开连接（双方之间的连接不会太频繁）</li><li><strong>HTTP1.1</strong>：在之后的互联网迅猛发展的时期，往往网页都要加载很多图片、脚本等信息（CSS、JS），如果还是像HTTP1.0一样一次请求开辟断开一次连接则非常耗费资源和时间。所以HTTP1.1版本默认支持了 <strong>TCP长连接</strong> 。当浏览器通过三次握手和服务器建立连接之后不会马上关闭连接，来支持浏览器多次的请求，等待请求完毕再释放连接。</li><li><strong>HTTP2.0</strong>：HTTP1.1对同一时间同一域名的请求有限制，所以HTTP2.0支持 <strong>多路复用</strong>，基于一个tcp连接发送多个请求以及接收响应，来实现低延迟高吞吐</li></ol><h2 id="4-HTTP里的长连接是什么"><a href="#4-HTTP里的长连接是什么" class="headerlink" title="4. HTTP里的长连接是什么"></a>4. HTTP里的长连接是什么</h2><p>HTTP本身没有长连接短连接之说，本质上是TCP的长连接和短连接，在HTTP1.0时，协议底层的TCP协议默认走的是短连接，HTTP1.1底层的TCP协议默认走的是长连接</p><ol><li><strong>短连接</strong>：每次请求响应后都会断开连接、释放资源</li><li><strong>长连接</strong>：可以看成一个网页一个长连接，这个网页的多个请求都通过一个TCP连接来收到响应、获取资源，很长时间后，没有进行通信这个链接才被释放</li></ol><p>长连接一般应用于聊天工具等这样的特殊场景</p><h2 id="5-HTTPS的工作原理是什么"><a href="#5-HTTPS的工作原理是什么" class="headerlink" title="5. HTTPS的工作原理是什么"></a>5. HTTPS的工作原理是什么</h2><p>HTTP协议是 <strong>明文传输</strong> 的，<strong>中间商就可以拦截下来插入自己的广告或者篡改信息</strong>，来达到盈利的目的，这显然是不安全的</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-https-process.png" alt=""></p><ol><li>浏览器把自己支持的加密算法发送给网站</li><li>网站从中选择一套加密算法和hash算法，然后发送 <strong>证书</strong> 给浏览器（证书里含有网站地址、加密公钥、证书颁发机构）</li><li>浏览器校验证书合法性，如果合法一般浏览器地址栏旁边会出现一把绿色的锁。接着，浏览器会生成随机数密码P1，使用证书里的 <strong>公钥</strong> 对P1加密（<strong>非对称加密</strong>）保证P1的安全性；又对整个消息进行 <strong>hash算法</strong> 算出hash值H1；再使用P1对消息进行 <strong>对称加密</strong>，发送消息给网站</li><li>网站收到数据后，先使用 <strong>私钥</strong> 对消息解密取出密码P1，再对消息进行对称解密（使用P1），对消息进行hash，比对浏览器发送的hash值H1和自己计算的hash值，一致则说明未被篡改。成功建立连接</li><li>之后两者就使用密码P1进行hash加密、使用P1对消息进行对称加密的方式来通信</li></ol><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-httpsLock.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络灵魂拷问系列之基础问答&quot;&gt;&lt;a href=&quot;#计算机网络灵魂拷问系列之基础问答&quot; class=&quot;headerlink&quot; title=&quot;计算机网络灵魂拷问系列之基础问答&quot;&gt;&lt;/a&gt;计算机网络灵魂拷问系列之基础问答&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;【
      
    
    </summary>
    
    
      <category term="计算机网络灵魂拷问系列" scheme="http://xuyk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="计算机网络基础知识" scheme="http://xuyk.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络灵魂拷问系列之计算机网络模型</title>
    <link href="http://xuyk.top/posts/interview-net-model.html"/>
    <id>http://xuyk.top/posts/interview-net-model.html</id>
    <published>2021-02-22T08:40:00.000Z</published>
    <updated>2021-02-22T08:49:10.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络灵魂拷问系列之计算机网络模型"><a href="#计算机网络灵魂拷问系列之计算机网络模型" class="headerlink" title="计算机网络灵魂拷问系列之计算机网络模型"></a>计算机网络灵魂拷问系列之计算机网络模型</h1><h2 id="0-网络通信协议的意义"><a href="#0-网络通信协议的意义" class="headerlink" title="0.网络通信协议的意义"></a>0.网络通信协议的意义</h2><p>各个电脑厂商，比如联想、苹果、华硕之类的，每个品牌的电脑之间的通信，如果通信协议不同，那么就只能品牌电脑内通信，这是不可取的。所以搞了一个国际通行的协议，大家都按照协议来，使得所有电脑都可以互相通信</p><p>OSI七层网络模型：<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-osi.png" alt=""></p><ol><li><strong>物理层</strong>：以前电脑都是通过网线来联网，传输0和1的信号。属于物理上的连接</li><li><strong>数据链路层</strong>：电脑接收到0101010001这样的电路信号怎么识别和分组，从哪个电脑传输到哪个电脑。数据链路层来解决。以太网协议就是这一层来的，以太网规定每个电脑都有一个网卡，电路信号一般从电脑1网卡传输到电脑2网卡。电脑出厂时都有一个唯一的mac地址（12个16进制，前6产商编号，后6流水号，win10中ipconfig /all可查询mac物理地址）。一组电信号就是一帧，每帧分为标头和数据，标头包含了一些发送者、接收者和数据类型之类的信息。发送者会把数据通过广播发送给所有局域网里的电脑，每个电脑网卡通过比对接收者mac地址来判断是否是发送给自己</li><li><strong>网络层</strong>：数据链路层发送方通过广播发送给局域网内所有的电脑，那么他是如何判别哪些电脑是处于同一个局域网内的呢？通过网络层判别。ip协议，一般通过4个十进制数字表示，范围从0.0.0.0到255.255.255.255。每台计算机都分配一个ip地址，各自对子网掩码（一般是255.255.255.0）做二进制与运算，得到前三段（192.168.1）一致则为同一局域网。跨局域网通信：请求头填写接收方ip和路由器mac地址，经过交换机发送给路由器/网关，路由器/网关转换成目标mac地址，而后正确发送给对方电脑。ARP：局域网内个台电脑都把自己的ip地址和对应的mac地址广播给其他电脑，最后每台电脑都会知道其他电脑的地址了。【关键】网络层最关键的就是提供了ip协议，电脑A和电脑B通信，如果两者在一个局域网，则只需要在请求头填写接收方mac地址即可通信；如果不在，在请求头填写接收方ip地址和路由器的mac地址进行通信</li><li><strong>传输层</strong>：电脑上很多应用都从网卡发送和接收数据，该如何辨别是给哪个应用的呢？传输层引入了端口的概念，例如qq监听20386端口，数据包解析到发送到20386端口，就说明是给qq的。关联端口号的就是tcp协议和udp协议（udp不可靠，只管发送数据不管对方是否接收），规定了端对端的规则，例如怎么建立连接、怎么发送和读取数据。socket基于tcp协议封装，我们可以基于socket进行网络编程（ip地址+端口号）</li><li><strong>应用层</strong>：当收到基于tcp协议发送过来的数据包后，如何将数据包进行对应解析？数据包可能用于发送邮件（STMP协议）、发送HTTP请求，用了什么格式进行封装</li></ol><blockquote><p>例如我们使用java中的nio来搭建rpc通信框架，底层过程还是走了：传输层的tcp协议、网络层的ip协议、数据链路层的以太网协议和物理层的网线传递着0101的信号 </p></blockquote><p>TCP/IP四层模型常用协议：<br>数据链路层（以太网协议）、网络层（ip协议）、传输层（tcp协议）、应用层（HTTP协议）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络灵魂拷问系列之计算机网络模型&quot;&gt;&lt;a href=&quot;#计算机网络灵魂拷问系列之计算机网络模型&quot; class=&quot;headerlink&quot; title=&quot;计算机网络灵魂拷问系列之计算机网络模型&quot;&gt;&lt;/a&gt;计算机网络灵魂拷问系列之计算机网络模型&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="计算机网络灵魂拷问系列" scheme="http://xuyk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="计算机网络模型" scheme="http://xuyk.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL灵魂拷问系列之MySQL如何优化</title>
    <link href="http://xuyk.top/posts/interview-MySQL-optimization.html"/>
    <id>http://xuyk.top/posts/interview-MySQL-optimization.html</id>
    <published>2021-02-20T09:52:00.000Z</published>
    <updated>2021-02-22T08:41:50.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问系列之MySQL如何优化"><a href="#MySQL灵魂拷问系列之MySQL如何优化" class="headerlink" title="MySQL灵魂拷问系列之MySQL如何优化"></a>MySQL灵魂拷问系列之MySQL如何优化</h1><h2 id="1-SQL语句日常优化"><a href="#1-SQL语句日常优化" class="headerlink" title="1. SQL语句日常优化"></a>1. SQL语句日常优化</h2><ol><li>通过skywalking发现慢sql、或者mysql中的慢查询日志（开启慢查询日志）</li><li>使用 <strong>explain</strong> 关键字查看sql执行计划</li><li>type一般控制在 <strong>ref</strong> 甚至更好的话，sql性能应该都不错</li><li><strong>key_len</strong>：表示索引的长度，越小越好</li><li><strong>rows</strong>：扫描行数，很重要，最少越好</li><li><strong>extra</strong>：当查询包含 <strong>using filesort</strong> 文件排序和 <strong>using temporary</strong>临时表（使用order/group by很容易出现），这样的sql必须优化</li></ol><h2 id="2-表结构优化"><a href="#2-表结构优化" class="headerlink" title="2. 表结构优化"></a>2. 表结构优化</h2><p><strong>在遵循三大范式的基础上，可以为了业务增加一定的冗余字段</strong></p><blockquote><p>个人笔记：<a href="http://note.youdao.com/s/LoTjHgzV">表结构设计优化</a></p></blockquote><h2 id="2-join优化"><a href="#2-join优化" class="headerlink" title="2. join优化"></a>2. join优化</h2><p><strong>（1）灵活使用左连接、右连接等</strong></p><ul><li><strong>left join</strong>：A表的全部数据，即使B表不包含A表的关系数据</li><li><strong>right join</strong>：B表的全部数据，即使B表不包含A表的关系数据</li><li><strong>inner join</strong>：A表和B表的交集</li><li><strong>full outer join</strong>：A表和B表并集</li><li><strong>cross join</strong>：笛卡尔连接，把A表的数据和B表的数据任意连接，结果行数 = A表行数 *B表行数；如果cross join带有on语句把两表的外键相连，则作用等于inner join</li></ul><p><strong>（2）使用join时，用数据量比较小的作为驱动表，用小表驱动大表，where条件尽量走索引，参与join的表不能超过3张</strong></p><blockquote><p>个人join优化笔记：<a href="http://note.youdao.com/s/CqwXTRyN">join优化</a></p></blockquote><h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><ol><li>遵循 <strong>最左前缀原则</strong></li><li>编写sql时避免 <strong>隐式转换</strong></li><li>必要时建议使用 <strong>组合索引、覆盖索引</strong></li></ol><blockquote><p>【个人索引优化笔记】<br>1：<a href="http://note.youdao.com/s/CVUXjziS">常见索引失效场景与解决方案</a><br>2：<a href="http://note.youdao.com/s/PBoh23ho">索引优化</a></p></blockquote><h2 id="4-limit优化"><a href="#4-limit优化" class="headerlink" title="4. limit优化"></a>4. limit优化</h2><ol><li>使用 <strong>覆盖索引 + join</strong>优化offset特别大的场景</li><li>模仿淘宝或者百度，对页面做限制（100页）</li></ol><blockquote><p>个人limit优化笔记：<a href="http://note.youdao.com/s/Fh5SAlZ1">limit优化</a></p></blockquote><h2 id="5-个人小结笔记"><a href="#5-个人小结笔记" class="headerlink" title="5. 个人小结笔记"></a>5. 个人小结笔记</h2><p>（1）表结构设计方面：首先需要遵循三大范式，字段不能再分割，非主键属性 <a href="https://zhuanlan.zhihu.com/p/259788257">https://zhuanlan.zhihu.com/p/259788257</a><br>a.字段不能再分割，比如只有一个地址字段，到时候如果按照省统计时就会非常头疼<br>b.每行记录要有唯一标识。比如学号、姓名、课程、课程分数，这一条记录就包含了学生、课程信息，主键无法保证唯一性，两个应该分开<br>c.不能存在冗余。比如学号、姓名、学院、学院电话。这里学院电话每行都有，肯定会存在冗余的情况。应该分开<br>d.适当加一些冗余字段，比如订单表记录商品金额，为的是保存当时商品信息快照，因为不同时期的商品价格可能发生变化</p><p>（2）表字段设计方面：字段尽量不允许为null，字段选择最适合的，比如性别、订单状态这样的字段可以使用tinyint，使用varchar可变的<br>字符串代替char等</p><p>（3）sql优化：通过skywalking或者mysql慢查询日志查询慢sql，通过explain关键字查询他的执行计划，保证type控制在ref，rows扫描行数<br>越少越好，extra列不出现临时表和文件排序；<br>a.join优化：遵循数据量小的表来驱动大表，where的条件尽量走索引，参与join的表最好不超过3张<br>b.索引优化：遵循最左前缀原则，避免隐式转换，否则可能造成索引失效。建议使用复合索引<br>c.limit优化：如果进行深度分页的话，比如10000，10，mysql的具体操作是查找10010条数据，然后丢弃前10000条，取后10条，性能很低。<br>这种情况，如果主键的自增类型，则直接可以让id&gt;10000，limit 10即可。如果不是自增类型，就根据主键索引查询到分页信息的主键，再<br>根据主键查询数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL灵魂拷问系列之MySQL如何优化&quot;&gt;&lt;a href=&quot;#MySQL灵魂拷问系列之MySQL如何优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL灵魂拷问系列之MySQL如何优化&quot;&gt;&lt;/a&gt;MySQL灵魂拷问系列之MySQL如何优化&lt;/
      
    
    </summary>
    
    
      <category term="MySQL灵魂拷问系列" scheme="http://xuyk.top/categories/MySQL%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MySQL" scheme="http://xuyk.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL灵魂拷问之数据库事务说说吧</title>
    <link href="http://xuyk.top/posts/interview-MySQL-transaction.html"/>
    <id>http://xuyk.top/posts/interview-MySQL-transaction.html</id>
    <published>2021-02-18T12:16:00.000Z</published>
    <updated>2021-02-22T08:42:02.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问之数据库事务说说吧"><a href="#MySQL灵魂拷问之数据库事务说说吧" class="headerlink" title="MySQL灵魂拷问之数据库事务说说吧"></a>MySQL灵魂拷问之数据库事务说说吧</h1><h2 id="1-事务的四大特性是什么-ACID"><a href="#1-事务的四大特性是什么-ACID" class="headerlink" title="1. 事务的四大特性是什么-ACID"></a>1. 事务的四大特性是什么-ACID</h2><ul><li><strong>原子性</strong>：一个事务作为一个整体，要么一起成功要么一起失败</li><li><strong>一致性</strong>：说的是数据一致性。事务执行前后，数据的执行是对的，不能存在某操作未执行的情况</li><li><strong>隔离性</strong>：各个事务之间互不干扰</li><li><strong>持久性</strong>：事务执行成功，对数据的操作是永久有效的</li></ul><h2 id="2-事务的隔离级别有哪些"><a href="#2-事务的隔离级别有哪些" class="headerlink" title="2. 事务的隔离级别有哪些"></a>2. 事务的隔离级别有哪些</h2><p>MySQL默认事务隔离级别：<strong>可重复读</strong></p><p>隔离级别依次是：读未提交、读已提交、可重复读、串行化，对应的性能从左到右依次递减</p><h3 id="2-1-事务隔离级别-读未提交"><a href="#2-1-事务隔离级别-读未提交" class="headerlink" title="2.1 事务隔离级别-读未提交"></a>2.1 事务隔离级别-读未提交</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-ReadUncommit.png" alt=""></p><p>读未提交：事务A可以查看到事务B修改的数据（事务B还未提交），也就是存在 <strong>脏读</strong> 的问题</p><h3 id="2-2-事务隔离级别-读已提交-不可重复读"><a href="#2-2-事务隔离级别-读已提交-不可重复读" class="headerlink" title="2.2 事务隔离级别-读已提交/不可重复读"></a>2.2 事务隔离级别-读已提交/不可重复读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-ReadCommitted.png" alt=""></p><p>存在 <strong>不可重复读</strong> 的问题</p><h3 id="2-3-事务隔离级别-可重复读"><a href="#2-3-事务隔离级别-可重复读" class="headerlink" title="2.3 事务隔离级别-可重复读"></a>2.3 事务隔离级别-可重复读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-RepeatableRead.png" alt=""></p><p>保证事务在运行期间，同一行数据是不会变更的</p><h3 id="2-4-可重复读的问题-幻读"><a href="#2-4-可重复读的问题-幻读" class="headerlink" title="2.4 可重复读的问题-幻读"></a>2.4 可重复读的问题-幻读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-IllusoryRead.png" alt=""></p><h3 id="2-5-事务隔离级别-串行化"><a href="#2-5-事务隔离级别-串行化" class="headerlink" title="2.5 事务隔离级别-串行化"></a>2.5 事务隔离级别-串行化</h3><p>MySQL事务隔离级别-串行化可以解决幻读的问题</p><p>事务A执行期间，事务B不允许执行，只能阻塞等待事务A执行完毕接着执行事务B</p><h2 id="3-MySQL是如何实现可重复读的（MVVC机制）？"><a href="#3-MySQL是如何实现可重复读的（MVVC机制）？" class="headerlink" title="3. MySQL是如何实现可重复读的（MVVC机制）？"></a>3. MySQL是如何实现可重复读的（MVVC机制）？</h2><p>使用 <strong>MVVC机制</strong>，也就是 <strong>多版本并发控制</strong>（Multi-Version Concurrency Control） 实现的可重复读</p><p>innodb对每一行都会追加两个隐藏列：<strong>创建这一行的事务id</strong>、<strong>删除这一行的事务id</strong>（事务id在MySQL中是 <strong>全局唯一并且递增</strong> 的）</p><p>核心规则： <strong>创建事务id &lt;= 当前事务id &lt; 删除事务id</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-mvvc-demo-one.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-mvvc-demo-two.png" alt=""></p><blockquote><p>并发场景下，多个事务对同一行进行修改，同一行就会存在多个版本<br>各个事务会对于这一行有一条创建事务id为自己id的快照</p></blockquote><blockquote><p>【参考链接】<br>1： <a href="https://mp.weixin.qq.com/s/XOBhxc_AiuUxvwBsB_JprQ">一文彻底读懂 MySQL 事务的四大隔离级别</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL灵魂拷问之数据库事务说说吧&quot;&gt;&lt;a href=&quot;#MySQL灵魂拷问之数据库事务说说吧&quot; class=&quot;headerlink&quot; title=&quot;MySQL灵魂拷问之数据库事务说说吧&quot;&gt;&lt;/a&gt;MySQL灵魂拷问之数据库事务说说吧&lt;/h1&gt;&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="MySQL灵魂拷问系列" scheme="http://xuyk.top/categories/MySQL%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MySQL" scheme="http://xuyk.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL灵魂拷问系列之MySQL基础拷问</title>
    <link href="http://xuyk.top/posts/interview-MySQL-common.html"/>
    <id>http://xuyk.top/posts/interview-MySQL-common.html</id>
    <published>2021-02-07T03:29:00.000Z</published>
    <updated>2021-02-22T08:41:25.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问系列之MySQL基础拷问"><a href="#MySQL灵魂拷问系列之MySQL基础拷问" class="headerlink" title="MySQL灵魂拷问系列之MySQL基础拷问"></a>MySQL灵魂拷问系列之MySQL基础拷问</h1><h2 id="1-MySQL有哪些存储引擎，有什么区别"><a href="#1-MySQL有哪些存储引擎，有什么区别" class="headerlink" title="1.MySQL有哪些存储引擎，有什么区别"></a>1.MySQL有哪些存储引擎，有什么区别</h2><p>mysql我们耳熟能详的就是两种存储引擎：<strong>Innodb、Myisam</strong></p><h3 id="1-1-Myisam"><a href="#1-1-Myisam" class="headerlink" title="1.1 Myisam"></a>1.1 Myisam</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-myisam.png" alt=""></p><ol><li><strong>不支持事务、外键</strong></li><li>从 <strong>物理存储角度</strong> 上看，Myisam属于 <strong>非聚簇索引</strong>，数据存在叶子结点（没有孩子的节点）上，叶子节点的data为数据的物理地址引用（索引文件和数据文件分开存储），，通过物理地址引用来找到具体的数据行。</li><li>适用于 <strong>少量插入、大量查询</strong> 的场景，以前做 <strong>大数据报表系统</strong> 的时候会用到，一次性大批量插入，接下来只是纯查询.不过现在基本已经不用myisam了（mysql扛不住，单表一般控制在500w）</li></ol><h3 id="1-2-Innodb"><a href="#1-2-Innodb" class="headerlink" title="1.2 Innodb"></a>1.2 Innodb</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-innodb.png" alt=""></p><ol><li>支持事务、外键</li><li>从 <strong>物理存储角度</strong> 上看，Innodb属于 <strong>聚簇索引</strong>，数据存在叶子结点（没有孩子的节点）上。如果是二级索引，则叶子结点存储的是主键，如果不止查询索引列，则需要再根据主键回表查询一次</li><li>目前来说，适用于大多数业务场景，无脑选即可</li></ol><blockquote><p>二级索引查找流程：先到二级索引的B+ Tree中根据name找到具体的叶子节点的data，data中存储的主键，根据主键再到聚簇索引（主键索引）中找到具体的数据行</p></blockquote><h3 id="1-3-Myisam和Innodb汇总比对图"><a href="#1-3-Myisam和Innodb汇总比对图" class="headerlink" title="1.3 Myisam和Innodb汇总比对图"></a>1.3 Myisam和Innodb汇总比对图</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-InnodbAndMyisam.png" alt=""></p><blockquote><p>Innodb二级索引叶子结点存储的是 <strong>索引和主键</strong>，需要查询到主键后，去主键索引查询数据</p></blockquote><h2 id="2-为什么MySQL的索引要使用B-树而不是其它树形结构-比如B树？"><a href="#2-为什么MySQL的索引要使用B-树而不是其它树形结构-比如B树？" class="headerlink" title="2.为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？"></a>2.为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？</h2><blockquote><p>具体细节参考：<br><a href="https://mp.weixin.qq.com/s/IZqjGK58mRUN4YFXO_QyHw">面试官：为什么MySQL的索引要使用B+树，而不是其它树？比如B树？</a></p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysq-b-tree.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-baddtree.png" alt=""></p><p>都属于多路搜索树</p><p>因为B树不管叶子节点还是非叶子节点，都会保存数据，如果要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低</p><p>而B+树只有在叶子节点存储数据，非叶子节点只保存索引值</p><p>数据库对B+ Tree还进行了优化，让每个叶子节点末尾有一个 <strong>next指针</strong> 指向下一个叶子节点的数据，使得在做范围查询的时候效率更高</p><h2 id="3-MySQL索引的使用规则"><a href="#3-MySQL索引的使用规则" class="headerlink" title="3.MySQL索引的使用规则"></a>3.MySQL索引的使用规则</h2><p>最左前缀匹配原则</p><p>假设表中只有A,B,C这三列的联合索引（A，B，C）</p><ol><li>全列匹配</li></ol><blockquote><p>select * from table where A = 1 and B = 2 and C = 3<br>说明：完美地走这个联合索引</p></blockquote><ol start="2"><li>最左前缀匹配</li></ol><blockquote><p>select * from table where A = 1 and B = 2<br>说明：走联合索引</p></blockquote><ol start="3"><li>最左匹配了，中间的值未匹配</li></ol><blockquote><p>select * from table where A = 1 and C = 3<br>说明：A走索引，C不走索引，会当作过滤条件，因为也走索引，所以在性能上也是可以接受的</p></blockquote><ol start="4"><li>未匹配最左匹配原则</li></ol><blockquote><p>select * from table where C = 3<br>说明：全表扫描，性能低，需要优化</p></blockquote><ol start="5"><li>前缀匹配</li></ol><blockquote><p>select * from table where A = 1 and B like “2%”<br>说明：like关键字 左边不能加 <strong>%</strong></p></blockquote><ol start="6"><li>范围/函数查询</li></ol><blockquote><p>select * from table where A &gt;= 0 and B = 2 and 函数（C） = 3<br>说明：A走索引，B不走索引，B作为筛选条件，C不走索引</p></blockquote><p><strong>索引的注意事项</strong></p><blockquote><p><a href="http://note.youdao.com/s/ZZP28HXU">理想设置索引和伪哈希技巧</a></p></blockquote><ol><li>单表索引数量不宜过多</li><li>类似于status、isValid这样的经常性重复的字段，创建索引意义不大</li><li>类似于网站这样前缀大致相同的字段，可以新建一个字段使用 <strong>crc32</strong> 函数对相同部分做hash，再对新字段创建索引</li></ol><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/ZxE8XDKUa8szJ6wRc-w-rA">InnoDB和MyISAM两者的对比</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL灵魂拷问系列之MySQL基础拷问&quot;&gt;&lt;a href=&quot;#MySQL灵魂拷问系列之MySQL基础拷问&quot; class=&quot;headerlink&quot; title=&quot;MySQL灵魂拷问系列之MySQL基础拷问&quot;&gt;&lt;/a&gt;MySQL灵魂拷问系列之MySQL基础拷问&lt;/
      
    
    </summary>
    
    
      <category term="MySQL灵魂拷问系列" scheme="http://xuyk.top/categories/MySQL%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MySQL" scheme="http://xuyk.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>线上出现问题了你有思路解决吗</title>
    <link href="http://xuyk.top/posts/interview-daily-prodProblem.html"/>
    <id>http://xuyk.top/posts/interview-daily-prodProblem.html</id>
    <published>2021-02-03T06:05:00.000Z</published>
    <updated>2021-02-03T06:06:33.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线上出现问题了你有思路解决吗"><a href="#线上出现问题了你有思路解决吗" class="headerlink" title="线上出现问题了你有思路解决吗"></a>线上出现问题了你有思路解决吗</h1><h2 id="1-线上服务器CPU使用率达到100-，如何排查、定位与解决呢"><a href="#1-线上服务器CPU使用率达到100-，如何排查、定位与解决呢" class="headerlink" title="1. 线上服务器CPU使用率达到100%，如何排查、定位与解决呢"></a>1. 线上服务器CPU使用率达到100%，如何排查、定位与解决呢</h2><p>面试官通过这个问题来试探面试者，有没有真实的玩过线上的机器</p><p><strong>导致CPU过高的一般原因</strong></p><ol><li>无线循环，例如递归调用等（可以整个sleep）</li><li>频繁GC（内存分配过快，导致区域很快就满了）</li><li>频繁创建新对象（可以考虑使用单例）</li><li>错误姿势的使用序列化和反序列化类库</li><li>正则表达式</li><li>线程上下文频繁切换</li></ol><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>top</strong> 到CPU占用最高的进程A <strong>pid1</strong></li><li>再使用 <strong>top -Hp</strong> 拿到指定进程占用最高的线程 <strong>pid2</strong></li><li>使用 <strong>printf %x pid2</strong> 将10进制线程号转换成16进制 <strong>8ccc</strong></li><li>通过 <strong>jstack pid1 &gt; dump.txt</strong> 获取进程A的堆栈快照</li><li>使用 <strong>cat dump.txt | grep -A 30 8ccc</strong> 根据16进制信息筛查出有问题的代码（往下展示30行）</li><li>排查代码中的问题并修复</li></ol><h2 id="2-线上机器的一个进程使用kill命令无法杀死怎么办？"><a href="#2-线上机器的一个进程使用kill命令无法杀死怎么办？" class="headerlink" title="2. 线上机器的一个进程使用kill命令无法杀死怎么办？"></a>2. 线上机器的一个进程使用kill命令无法杀死怎么办？</h2><p>kill进程如果死活杀不死，那么这个进程会进入 <strong>zombie（僵尸）</strong> 状态，也就是一个僵尸进程，这是因为 <strong>子进程释放了资源，但是没有经过父进程的确认</strong></p><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>ps aux</strong> 查看 <strong>stat</strong> ，如果对应这一栏值是 <strong>Z</strong> ,那么说明是僵尸进程</li><li>使用 <strong>ps -ef | grep 僵尸进程id</strong> 可以找到 <strong>父进程id</strong></li><li>使用 <strong>kill</strong> 杀死父进程即可</li></ol><h2 id="3-磁盘空间快满了，不影响服务的情况下如何解决？"><a href="#3-磁盘空间快满了，不影响服务的情况下如何解决？" class="headerlink" title="3. 磁盘空间快满了，不影响服务的情况下如何解决？"></a>3. 磁盘空间快满了，不影响服务的情况下如何解决？</h2><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>df -h</strong> 查看磁盘使用率情况</li><li>可以通过删除一些年份比较久的日志文件来释放空间。（一般可以通过 <strong>crontab定时任务</strong> 来每天定时清理一些日志文件，保证空间富余）</li><li>如果不是日志文件导致，就通过 <strong>find \ -size +100M | xargs ls -lh</strong> （查询根目录下所有大于100M的文件）</li><li>如果没找到大文件，可以查询占据磁盘空间大的目录，看看各个目录里是否有大量的小文件， <strong>du -h &gt; fs_du.log</strong></li></ol><h2 id="4-线上发生-java-lang-OutOfMemoryError-Java-heap-space-堆内存溢出怎么办？"><a href="#4-线上发生-java-lang-OutOfMemoryError-Java-heap-space-堆内存溢出怎么办？" class="headerlink" title="4. 线上发生 java.lang.OutOfMemoryError Java heap space 堆内存溢出怎么办？"></a>4. 线上发生 java.lang.OutOfMemoryError Java heap space 堆内存溢出怎么办？</h2><p><strong>堆内存溢出的原因及解决思路</strong></p><ol><li><strong>内存泄漏</strong>：找到堆栈引用链，查出哪个对象没有被回收导致内存泄漏（找到泄漏对象的创建位置）</li><li><strong>非内存泄漏</strong>：考虑调大JVM参数的xms xmx最大\小堆内存，为应用分配更多的堆内存；检查代码，排除有些对象生命周期是否太长了，又或者存储结构不合理（有时换个方式存储对象可以节省很多内存）</li></ol><p><strong>现实可能发生堆内存溢出的场景</strong></p><ol><li>数据库过多数据返回给服务端，导致内存溢出：</li><li>根据某个分类搜索商品列表（分页），如果这个分类的商品特别多，并且pageSize没有设置限制，被恶意攻击时，会一下子就把内存打崩</li><li>…</li></ol><p><strong>举个🌰说明</strong></p><pre class="line-numbers language-java"><code class="language-java">\<span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">*</span> 使用该选项运行：<span class="token operator">-</span>Xms20m <span class="token operator">-</span>Xmx20m <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>HeapDumpOnOutOfMemoryError      使用最小\最大堆内存都为20m 并且在堆内存溢出时做一次堆dump <span class="token operator">*</span>\<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOMTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> oomList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HeapOOMTest oomTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeapOOMTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            oomTest<span class="token punctuation">.</span>oomList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照配置运行代码，会发生堆内存溢出。</p><p>在实际项目中，堆内存溢出可能会导致进程崩溃，极端场景下进程可能直接就挂掉了，不会打印日志</p><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5COutOfMemoryError-JavaHeapSpace.png" alt=""></p><p><strong>项目根目录中，会生成dump文件，例如 java_pid15468.hprof</strong></p><p><strong>分析dump文件</strong></p><ol><li>MAT</li><li>VisualVM</li><li>PerfMa</li></ol><p>具体操作查看本人在有道云做的笔记</p><p><a href="http:\note.youdao.com\s\Jbdk16jn">实战：堆内存溢出【java.lang.OutOfMemoryError Java heap space】</a></p><p>也可以查看以下文章</p><p><a href="https:\club.perfma.com\article\670585">实战：OOM 后我如何分析解决的 | PerfMa应用性能技术社区</a></p><blockquote><p><strong>栈内存溢出</strong>：可能由 <strong>递归创建过多栈帧</strong> 导致栈内存溢出<br><strong>方法区内存溢出</strong>：可能由 <strong>常量占据内存过多</strong> 导致元空间内存不足</p></blockquote><h2 id="5-如果一个项目越跑越慢，你觉得可能是因为什么？"><a href="#5-如果一个项目越跑越慢，你觉得可能是因为什么？" class="headerlink" title="5. 如果一个项目越跑越慢，你觉得可能是因为什么？"></a>5. 如果一个项目越跑越慢，你觉得可能是因为什么？</h2><ol><li>垃圾收集非常频繁，stop the world时间越来越长，导致项目执行越来越慢</li><li>数据库数据量变大（慢SQL优化或者分库分表来解决）</li><li>Code Cache默认的240M代码缓存区满了。未满时，代码以编译的方式执行，如果满了，代码会以解释的方式执行，执行速度上比编译执行慢了一个数量级，严重影响项目性能</li><li>线程争抢过于激烈，导致代码争抢不到CPU时间片去执行任务</li><li>操作系统问题则重启大法好</li></ol><blockquote><p>代码缓存区相关知识点：<a href="http:\note.youdao.com\s\czDaSk5r">实战：代码缓存区域满</a></p></blockquote><p>可以通过 <strong>skywalking</strong> 来预防和辅助分析问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线上出现问题了你有思路解决吗&quot;&gt;&lt;a href=&quot;#线上出现问题了你有思路解决吗&quot; class=&quot;headerlink&quot; title=&quot;线上出现问题了你有思路解决吗&quot;&gt;&lt;/a&gt;线上出现问题了你有思路解决吗&lt;/h1&gt;&lt;h2 id=&quot;1-线上服务器CPU使用率达到10
      
    
    </summary>
    
    
      <category term="日常工作应用" scheme="http://xuyk.top/categories/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="线上问题" scheme="http://xuyk.top/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM灵魂拷问系列之整点类加载机制吧</title>
    <link href="http://xuyk.top/posts/interview-jvm-classloader.html"/>
    <id>http://xuyk.top/posts/interview-jvm-classloader.html</id>
    <published>2021-01-31T13:24:00.000Z</published>
    <updated>2021-02-22T08:42:13.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之问点类加载机制吧"><a href="#JVM灵魂拷问系列之问点类加载机制吧" class="headerlink" title="JVM灵魂拷问系列之问点类加载机制吧"></a>JVM灵魂拷问系列之问点类加载机制吧</h1><h2 id="1-你知道java文件是如何被运行的吗？"><a href="#1-你知道java文件是如何被运行的吗？" class="headerlink" title="1. 你知道java文件是如何被运行的吗？"></a>1. 你知道java文件是如何被运行的吗？</h2><ol><li>Java文件经过编译后变成 <strong>.class字节码文件</strong></li><li>字节码文件通过 <strong>类加载器</strong> 被搬运加载到 JVM 虚拟机中 </li></ol><h2 id="2-那你说说类加载器的流程吧，从类被加载到释放内存"><a href="#2-那你说说类加载器的流程吧，从类被加载到释放内存" class="headerlink" title="2. 那你说说类加载器的流程吧，从类被加载到释放内存"></a>2. 那你说说类加载器的流程吧，从类被加载到释放内存</h2><p>总共有七个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中 <strong>验证，准备，解析三个部分统称为连接</strong> </p><ol><li><strong>加载</strong>：将class文件加载进内存中</li><li><strong>连接</strong>：（1）验证，做一个安全检查，保证字节码符合JVM相关规则与规范；（2）准备：设置静态变量初始值等（3）解析：将常量池的引用替换为真实地址引用</li><li><strong>初始化</strong>：赋值的过程</li><li><strong>卸载</strong>：GC释放无用对象的内存</li></ol><h2 id="3-类加载器是怎么加载一个class的（双亲委派机制）？"><a href="#3-类加载器是怎么加载一个class的（双亲委派机制）？" class="headerlink" title="3. 类加载器是怎么加载一个class的（双亲委派机制）？"></a>3. 类加载器是怎么加载一个class的（双亲委派机制）？</h2><p><strong>双亲委派加载机制</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-classLoader-pic.png" alt=""></p><p>当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的。</p><ol><li>首先由最顶层的类加载器 <strong>Bootstrap ClassLoader</strong> 试图加载</li><li>如果没加载到，则把任务转交给 <strong>Extension ClassLoader</strong> 试图加载</li><li>如果也没加载到，则转交给 <strong>App ClassLoader</strong> 进行加载</li><li>如果它也没有加载得到的话，则返回给 <strong>委托的发起者</strong>，由它到指定的文件系统或网络等URL中加载该类。</li><li>如果它们都没有加载到这个类时，则抛出 <strong>ClassNotFoundException</strong> 异常。</li></ol><p><strong>那为什么要这么做呢？</strong></p><p>比如加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到 <strong>BootStrap ClassLoader</strong> 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>例子🌰：如果我们自己写了String类，其实是会报错的，因为在加载的过程中，会先找到 <strong>rt.jar</strong> 中的String.class。</p><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/Llps6z99cpPMN2ekeQljrA">Jar 包依赖冲突排查思路和解决方法</a><br>2：<a href="https://juejin.cn/post/6844904048013869064">大白话带你认识JVM</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM灵魂拷问系列之问点类加载机制吧&quot;&gt;&lt;a href=&quot;#JVM灵魂拷问系列之问点类加载机制吧&quot; class=&quot;headerlink&quot; title=&quot;JVM灵魂拷问系列之问点类加载机制吧&quot;&gt;&lt;/a&gt;JVM灵魂拷问系列之问点类加载机制吧&lt;/h1&gt;&lt;h2 id=&quot;1
      
    
    </summary>
    
    
      <category term="JVM灵魂拷问系列" scheme="http://xuyk.top/categories/JVM%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="http://xuyk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM灵魂拷问系列之垃圾回收</title>
    <link href="http://xuyk.top/posts/interview-jvm-GarbageCollection.html"/>
    <id>http://xuyk.top/posts/interview-jvm-GarbageCollection.html</id>
    <published>2021-01-30T08:35:00.000Z</published>
    <updated>2021-02-22T08:42:22.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之垃圾回收"><a href="#JVM灵魂拷问系列之垃圾回收" class="headerlink" title="JVM灵魂拷问系列之垃圾回收"></a>JVM灵魂拷问系列之垃圾回收</h1><h2 id="1-垃圾回收发生在哪些区域？"><a href="#1-垃圾回收发生在哪些区域？" class="headerlink" title="1. 垃圾回收发生在哪些区域？"></a>1. 垃圾回收发生在哪些区域？</h2><p>JVM内存模型中， <strong>线程共享区域</strong> 会发生垃圾回收，也就是 <strong>堆内存</strong> 和 <strong>方法区</strong></p><p>线程独占区域的内存，会随着线程的消亡而销毁，不需要垃圾回收</p><h2 id="2-说说JVM在哪些情况下会进行垃圾回收？"><a href="#2-说说JVM在哪些情况下会进行垃圾回收？" class="headerlink" title="2. 说说JVM在哪些情况下会进行垃圾回收？"></a>2. 说说JVM在哪些情况下会进行垃圾回收？</h2><p>Eden区域/永久代内存满了会进行垃圾回收</p><p>一般有通过两种方式来判断：<strong>引用计数法</strong> 和 <strong>可达性分析</strong></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>通过对象的引用计数器来判断该对象是否被引用，被其他地方引用一次+1，反之-1，值为0表示没有引用可回收</p><p><strong>缺点</strong>：循环引用的情况无法解决，所以Java没用使用引用计数法</p><h3 id="2-2-可达性分析"><a href="#2-2-可达性分析" class="headerlink" title="2.2 可达性分析"></a>2.2 可达性分析</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-AccessibilityAnalysis.png" alt=""></p><p>以根对象为起点向下搜索，走过的路径为引用链，<strong>如果对象到根对象没用引用链相连</strong>，则认定这个对象不可达，是可以回收，如图Object5和Object7是可回收的 </p><p><strong>哪些对象可以作为根对象</strong></p><ol><li>虚拟机栈（栈帧中的本地变量表）引用的对象</li><li>方法区类静态属性引用的对象</li><li>方法区常量引用的对象</li><li>本地方法栈中JNI（即Native方法）引用的对象</li></ol><h2 id="3-说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？"><a href="#3-说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？" class="headerlink" title="3. 说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？"></a>3. 说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？</h2><ol><li>强引用：平时使用的引用，Object o = new Object();，只要强引用在对象就不会被回收.<strong>哪怕出现内存溢出也不回收</strong></li><li>软引用：SoftReference<string> sf = new SoftReference&lt;&gt;(“hello”);一般是描述一些有用但非必需的对象。<strong>内存不足才回收</strong><br>软引用比较适合用来实现缓存，比如网页缓存图片缓存等等</string></li><li>弱引用：WeakReference<string> sf = new WeakReference&lt;&gt;(“hello”);一般是描述一些有用但非必需的对象。<strong>不管内存是否不足都会被回收</strong></string></li><li>虚引用：任何时候都可能被回收，主要用来跟踪被回收的活动，一般跟引用引用队列配合使用</li></ol><h2 id="4-说说JVM的垃圾回收算法？对象什么时候转移到老年代？"><a href="#4-说说JVM的垃圾回收算法？对象什么时候转移到老年代？" class="headerlink" title="4.说说JVM的垃圾回收算法？对象什么时候转移到老年代？"></a>4.说说JVM的垃圾回收算法？对象什么时候转移到老年代？</h2><p>首先，我们需要了解一个原则：<strong>JVM一边运行代码一边判断和清理垃圾对象是不现实的</strong>，所以提到垃圾回收都会说一个概念： <strong>Stop The World</strong>，意思是JVM会停止工作线程的运行来进行垃圾回收 -&gt; 发生小小的卡顿</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-StopTheWorld.png" alt=""></p><blockquote><p>例子：聚会（程序运行）不断产生垃圾，清洁工清理垃圾（垃圾收集器），如果聚会不停止（程序不短暂暂停），则清洁工就没办法进入场地清理垃圾，打扫好屋子</p></blockquote><p>JVM使用 <strong>分代收集算法</strong> 来进行垃圾回收，根据不同区域使用不同垃圾回收算法，既可以有效清除垃圾对象，又提高了垃圾回收的效率</p><blockquote><p>这里省略另一种算法 <strong>增量算法</strong>：每次只收集一小片区域的垃圾（每次回收全部垃圾系统停顿更长，此算法可减小系统停顿）</p></blockquote><h3 id="4-1-年轻代垃圾回收算法-复制算法"><a href="#4-1-年轻代垃圾回收算法-复制算法" class="headerlink" title="4.1 年轻代垃圾回收算法-复制算法"></a>4.1 年轻代垃圾回收算法-复制算法</h3><p><strong>Minor/Young GC</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-youngGeneration.png" alt=""></p><p>98%的对象都会很快消亡，所以 <strong>大多数对象的生命周期都很短</strong></p><p>流程：对象在创建时，一般会先存放到Eden，Eden满了之后就会触发垃圾回收，会把Eden中存活对象拷贝到S1中，清理Eden区域的所有对象。如果Eden区域又满时，会把Eden区域和S1的存活对象复制到S2区域，再清楚所有Eden区域和S1区域的对象。如此反复..</p><blockquote><p>优点：性能好、无碎片<br>缺点：内存利用率低</p></blockquote><h3 id="4-2-老年代垃圾回收算法-标记清除-标记整理算法"><a href="#4-2-老年代垃圾回收算法-标记清除-标记整理算法" class="headerlink" title="4.2 老年代垃圾回收算法-标记清除/标记整理算法"></a>4.2 老年代垃圾回收算法-标记清除/标记整理算法</h3><p><strong>老年代的对象都是被长期引用的</strong>，老年代的垃圾回收比较慢，一般是年轻代垃圾回收的10倍以上</p><p><strong>新创建的对象也有可能直接进入老年代</strong>：</p><ol><li>对象大于JVM参数-XX:PretenureSizeThreshold的阈值时，直接分配到老年代</li><li>新生代的空间不足以存放该对象</li></ol><p>老年代的垃圾回收：<strong>Major GC</strong> </p><blockquote><p>执行Major GC时一般都伴随这Minor GC，所以老年代回收约等于Full GC。</p></blockquote><p><strong>Major GC 触发条件</strong>：</p><ol><li>老年代空间不足</li><li>元空间不足</li><li>某一对象晋升到老年代但是老年代空间不足</li><li>显式调用<code>System.gc()</code>方法，可以使用-XX:+DisableExplicitGC来忽略此调用</li></ol><p><strong>标记清除算法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-markClean.png" alt=""></p><ol><li>使用 <strong>可达性分析</strong> 标记可回收对象</li><li>清除可回收对象</li></ol><blockquote><p>优点：实现简单<br>缺点：清除后会存在内存碎片，例如图中情况下，如果想分配一个连续三个内存空间的数组，则图中的内存块无法做到</p></blockquote><p><strong>标记整理算法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-markSort.png" alt=""></p><ol><li>使用 <strong>可达性分析</strong> 标记可回收对象</li><li>把存活对象移动到一端</li><li>清除可回收对象</li></ol><blockquote><p>优点：无内存碎片<br>缺点：对比标记清除开销大</p></blockquote><h3 id="4-3-对象什么时候转移到老年代"><a href="#4-3-对象什么时候转移到老年代" class="headerlink" title="4.3 对象什么时候转移到老年代"></a>4.3 对象什么时候转移到老年代</h3><ol><li>经过 <strong>15次Young GC还存活</strong> 的对象会转移到老年代。例如<strong>Spring容器里管理的对象实例</strong>，被Spring容器引用，所以长期存活转移到老年代</li><li>新创建的大对象，如果Eden区域放不下，则会转移到老年代</li><li><strong>S区域放不下</strong> 的对象会转移到老年代</li></ol><h2 id="5-GC简单汇总图"><a href="#5-GC简单汇总图" class="headerlink" title="5. GC简单汇总图"></a>5. GC简单汇总图</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-GCList.png" alt=""></p><blockquote><p>Full GC待补充</p></blockquote><h2 id="6-常用的垃圾回收器"><a href="#6-常用的垃圾回收器" class="headerlink" title="6. 常用的垃圾回收器"></a>6. 常用的垃圾回收器</h2><p><strong>parnew + CMS</strong> </p><p>目前主流的jdk版本使用的组合</p><p>parnew： <strong>新生代垃圾回收器</strong>，使用<strong>多线程</strong>去回收垃圾对象，使用复制算法<br>CMS：<strong>老年代垃圾回收器</strong>，是一个<strong>并发收集器</strong>，使用标记清除算法</p><p><strong>G1分代垃圾回收器</strong></p><p>jdk新版本使用的垃圾回收器</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM灵魂拷问系列之垃圾回收&quot;&gt;&lt;a href=&quot;#JVM灵魂拷问系列之垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;JVM灵魂拷问系列之垃圾回收&quot;&gt;&lt;/a&gt;JVM灵魂拷问系列之垃圾回收&lt;/h1&gt;&lt;h2 id=&quot;1-垃圾回收发生在哪些区域？&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JVM灵魂拷问系列" scheme="http://xuyk.top/categories/JVM%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="http://xuyk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM灵魂拷问系列之JVM内存模型知多少</title>
    <link href="http://xuyk.top/posts/interview-jvm-model.html"/>
    <id>http://xuyk.top/posts/interview-jvm-model.html</id>
    <published>2021-01-29T07:19:00.000Z</published>
    <updated>2021-02-22T08:42:31.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之JVM内存模型知多少"><a href="#JVM灵魂拷问系列之JVM内存模型知多少" class="headerlink" title="JVM灵魂拷问系列之JVM内存模型知多少"></a>JVM灵魂拷问系列之JVM内存模型知多少</h1><h2 id="1-JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？"><a href="#1-JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？" class="headerlink" title="1.JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？"></a>1.JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？</h2><blockquote><p>前提流程分析：我们在部署项目时，无论是旧项目（SSH、SSM）还是新项目（SpringBoot内置tomcat），都会放在tomcat中的目录中部署运行的。<br>tomcat由java编写，本质上是一个JVM进程，当请求到来时，jvm通过编译后的项目字节码来执行我们的业务代码响应请求</p></blockquote><p>众所周知，不讲tomcat自带的线程池，我们平时使用的框架或者自定义的线程池都说明了一点，系统中运行着多个线程，这些线程既有自己独有的空间（栈内存），也有共同分享的空间（堆内存）</p><h3 id="1-1-堆内存（线程共享）"><a href="#1-1-堆内存（线程共享）" class="headerlink" title="1.1 堆内存（线程共享）"></a>1.1 堆内存（线程共享）</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-heap.png" alt=""></p><p>由图可知，堆分为三个部分：<strong>新生代、老年代和持久代/元空间</strong></p><blockquote><p>元空间不存放在堆中而是存放在在本地内存中，这里用作比较之用</p></blockquote><p>JVM在启动过程中，线程会创建很多对象，这些对象一般优先存放在 <strong>新生代的Eden伊甸园区域</strong> ，如果对象大于一定程度，则存放在 <strong>老年代</strong> 中</p><p>java语言的特点：一处编译，处处运行。说的就是我们写的项目代码会通过编译器编译成字节码文件，由不同系统的java虚拟机来运行他们。而这些 <strong>字节码文件（类信息等）</strong> 也是需要一个地方进行存放的，JDK8之前，存放地为 <strong>永久代</strong> ，JDK8之后为 <strong>元空间</strong></p><p>JDK8前后分代改进：</p><ul><li>JDK8以前：在 <strong>永久代</strong> 存放常量池和类信息</li><li>JDK8以后：在 <strong>metaspace元空间</strong> 存放类信息</li></ul><p><strong>为什么 JDK1.8 把永久代干掉</strong></p><ol><li>oracle收购两家公司，其中一家公司JDK1.8以前没有永久代，干脆干掉了再新增一个元空间</li><li>永久代存放一系列常量，类、方法的相关信息，但是这些都没办法确定，但是 <strong>永久代空间固定，可能导致内存溢出</strong>（内存不足以存放信息-OutOfMemoryError：PermGen）</li><li>元空间本质是本地内存，理论上 <strong>取决于操作系统可以分配的内存大小，可以解决内存不足的情况</strong></li></ol><h3 id="1-2-栈内存-虚拟机栈（线程独享）"><a href="#1-2-栈内存-虚拟机栈（线程独享）" class="headerlink" title="1.2 栈内存/虚拟机栈（线程独享）"></a>1.2 栈内存/虚拟机栈（线程独享）</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-stack.png" alt=""></p><p>当线程创建时，会创建一个由多个栈帧组成的虚拟机栈，存放着例如 <strong>局部变量、对象引用</strong> 等</p><h3 id="1-3-本地方法栈（线程独享）"><a href="#1-3-本地方法栈（线程独享）" class="headerlink" title="1.3 本地方法栈（线程独享）"></a>1.3 本地方法栈（线程独享）</h3><p>存放一些由 <strong>C语言编写的native方法</strong> ，例如我们常用到的 <strong>Unsafe（CAS）</strong> </p><h3 id="1-4-程序计数器（线程独享）"><a href="#1-4-程序计数器（线程独享）" class="headerlink" title="1.4 程序计数器（线程独享）"></a>1.4 程序计数器（线程独享）</h3><p>用来 <strong>记录线程执行字节码的地址</strong> ，也就是对执行到哪一行代码做一个标记。当线程被挂起，再恢复时，方便及时定位到继续执行的位置</p><h3 id="1-5-方法区（线程共享）"><a href="#1-5-方法区（线程共享）" class="headerlink" title="1.5 方法区（线程共享）"></a>1.5 方法区（线程共享）</h3><p>方法区是 <strong>逻辑层面</strong> 上的划分，如图</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-methodArea.png" alt=""></p><p>方法区在 <strong>堆</strong> 中存储着 <strong>静态变量 和 字符串常量</strong><br>方法区在 <strong>元空间</strong> 中存储着 <strong>类相关信息 和 运行时常量</strong></p><blockquote><p>【静态常量池】：属于<strong>堆</strong>，存放着 <strong>文本常量</strong> 或者 <strong>被final修饰的常量</strong>，也存放着一些 <strong>类名、方法名</strong> 等<br>【运行时常量池】：属于<strong>元空间/本地内存</strong>，当类被加载到内存中，JVM会把静态常量池中的内容存放到运行时常量池中。<br>【字符串常量池】：属于<strong>堆</strong>，运行时常量池分出来的一部分，类加载到内存中时，字符串会存放在字符串常量池中</p></blockquote><h2 id="2-你知道JVM是如何运行起来的吗？对象是如何分配的？"><a href="#2-你知道JVM是如何运行起来的吗？对象是如何分配的？" class="headerlink" title="2.你知道JVM是如何运行起来的吗？对象是如何分配的？"></a>2.你知道JVM是如何运行起来的吗？对象是如何分配的？</h2><p>举个例子🌰：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PREFIX <span class="token operator">=</span> <span class="token string">"名称前缀"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        MyService myService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myService<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token string">"testName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>PREFIX <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-demoDesc.jpg" alt=""></p><ol><li>java代码通过编译器编译成JVM可读懂的class字节码文件。项目启动，JVM调用main方法，或者存在Spring容器实例化必需类时，都会通过 <strong>类加载机制</strong> 把MyController.class文件加载到内存中，在堆内存中创建MyController实例，将MyController类相关信息存放在元空间中，在堆内存的静态常量池中创建静态常量</li><li>当请求到来时，线程执行<code>doRequest()</code>方法，会在 <strong>堆内存</strong> 中创建一个MyService对象实例，同时在栈内存中创建一个栈帧，存放方法信息和局部引用变量myService，指向堆内存中的示例。静态常量池的”名称前缀”也会存入运行时常量池</li><li>当myService执行<code>printName()</code>方法时，会创建<code>printName()</code>方法对应的栈帧，字符串常量池创建”testName”，局部变量name也存在栈帧中，指向”testName”</li><li>当<code>printName()</code>方法执行完毕，对应栈帧销毁，而后<code>doRequest()</code>执行完毕，对应栈帧销毁。因栈帧中的引用销毁了，堆内存相关的数据没有引用，下一次会被垃圾回收</li></ol><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/BLcJm5xG">JVM内存结构个人笔记</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM灵魂拷问系列之JVM内存模型知多少&quot;&gt;&lt;a href=&quot;#JVM灵魂拷问系列之JVM内存模型知多少&quot; class=&quot;headerlink&quot; title=&quot;JVM灵魂拷问系列之JVM内存模型知多少&quot;&gt;&lt;/a&gt;JVM灵魂拷问系列之JVM内存模型知多少&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="JVM灵魂拷问系列" scheme="http://xuyk.top/categories/JVM%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JVM" scheme="http://xuyk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游</title>
    <link href="http://xuyk.top/posts/interview-springcloud.html"/>
    <id>http://xuyk.top/posts/interview-springcloud.html</id>
    <published>2021-01-27T10:54:00.000Z</published>
    <updated>2021-01-29T07:47:25.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游"><a href="#Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游" class="headerlink" title="Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游"></a>Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游</h1><p><strong>SpringCloud组件</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringCloud-component.png" alt=""></p><p><strong>一个请求怎么在SpringCloud中遨游</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringCloud-structure.jpg" alt=""></p><ol><li>在Spring Cloud中，每个服务和组件都需要在 <strong>Eureka注册中心</strong> 注册，注册成功后，Eureka也会主动发起 <strong>心跳检测来进行健康检查和信息同步</strong></li><li>服务启动时，会根据环境从配置中心中拉取对应配置来启动</li><li>浏览器发起请求，到达网关层，网关层根据 <strong>路由转发</strong> 到指定服务A（网关层还可起到限流、鉴权、负载均衡等作用）</li><li>如果服务A需要需要依赖服务B，则会通过 <strong>ribbon负载均衡策略</strong> 找到某一台服务B的实例，再通过 <strong>feign调用</strong> 实例服务，其中使用 <strong>hystrix</strong> 进行服务 <strong>降级/熔断</strong> </li><li>A服务执行业务完毕，返回数据给网关，网关返回浏览器/前端工程</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之一个请求怎么在Spri
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SpringCloud" scheme="http://xuyk.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring灵魂拷问系列之简单理一下SpringMVC流程</title>
    <link href="http://xuyk.top/posts/interview-springmvc.html"/>
    <id>http://xuyk.top/posts/interview-springmvc.html</id>
    <published>2021-01-25T15:54:00.000Z</published>
    <updated>2021-01-25T15:58:16.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之简单理一下SpringMVC流程"><a href="#Spring灵魂拷问系列之简单理一下SpringMVC流程" class="headerlink" title="Spring灵魂拷问系列之简单理一下SpringMVC流程"></a>Spring灵魂拷问系列之简单理一下SpringMVC流程</h1><p> <img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringMVC-structure.jpg" alt=""></p><p>SpringMVC大体流程：</p><ol><li>tomcat工作线程将请求转发给Spring MVC框架的<strong>中央控制器DispatcherServlet</strong></li><li>中央控制器根据请求信息做相关的<strong>适配</strong>和<strong>映射</strong>，将请求转发到对应Controller</li><li>根据<code>@RequestMapping</code>来<strong>定位</strong>和<strong>调用</strong>到http请求对应的处理方法（处理器映射器、处理器适配器、处理器）</li><li>业务执行完毕后会有一个返回值。（1）以前：会通过JSP/模版引擎，将前端页面存放在后端工程中，返回值这里就是页面模版的名字，Spring MVC根据返回的数据对象对html页面进行渲染；（2）如今，前后端分离，返回值为json字符串，前端会根据返回的json数据，对html页面进行渲染</li><li>将渲染后的html页面返回给浏览器进行显示</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之简单理一下SpringMVC流程&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之简单理一下SpringMVC流程&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之简单理一下SpringMVC流程&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SpringMVC" scheme="http://xuyk.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring灵魂拷问系列之Spring基础拷问</title>
    <link href="http://xuyk.top/posts/interview-spring-base.html"/>
    <id>http://xuyk.top/posts/interview-spring-base.html</id>
    <published>2021-01-23T12:04:00.000Z</published>
    <updated>2021-01-23T12:04:06.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之Spring基础拷问"><a href="#Spring灵魂拷问系列之Spring基础拷问" class="headerlink" title="Spring灵魂拷问系列之Spring基础拷问"></a>Spring灵魂拷问系列之Spring基础拷问</h1><h2 id="0-面试连环炮"><a href="#0-面试连环炮" class="headerlink" title="0.面试连环炮"></a>0.面试连环炮</h2><p>Spring IOC和AOP的理解 -&gt; 动态代理 -&gt; JDK/Cglib动态代理 -&gt; Spring Bean线程安全 -&gt; Spring事务实现原理和事务传播机制</p><h2 id="1-说说对Spring-IOC的理解"><a href="#1-说说对Spring-IOC的理解" class="headerlink" title="1.说说对Spring IOC的理解"></a>1.说说对Spring IOC的理解</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-old-process.jpg" alt=""></p><p>以前的一套系统：<br>web服务器：绑定地址端口，负责接收请求<br>servlet：引入serviceImpl类来处理请求（doPost、doGet）</p><p>像这样每个servlet都新建一个serviceImpl服务类实例，导致耦合度很高，当需要换一个服务实现类时，每个地方都需要修改成新的类，导致改动、测试成本巨大</p><p>Spring IOC：<strong>控制反转，依赖注入，让系统的类与类之间解耦</strong></p><p>Tomcat启动Spring容器，扫描指定路径的包路径，所有加了Spring注解的类会被Spring容器初始和实例化Bean并且交给Spring容器管理，当某个地方使用到时，Spring容器会自动注入实例</p><blockquote><p>Spring MVC：核心Servlet、Filter，负责用户请求的转发，转发给对应的Controller，之后调用相应的服务类进行处理</p></blockquote><p>底层：通过反射来动态的构建对象实例</p><p>当改成Spring IOC解耦时，只需要修改service的实现类即可。这样的话，在具体请求过来时，Spring会根据反射动态生成实现类来处理请求了</p><h2 id="2-说说对Spring-AOP的理解"><a href="#2-说说对Spring-AOP的理解" class="headerlink" title="2.说说对Spring AOP的理解"></a>2.说说对Spring AOP的理解</h2><p><strong>核心技术：动态代理</strong></p><blockquote><p>不关心底层代码的实现逻辑，在此实现逻辑前后做一些公共的处理，例如事务处理、统计方法耗时等</p></blockquote><p>把代码公共/重复的代码抽取出来，比如日志、事务、通知等业务，做一个切面</p><h2 id="3-cglib动态代理和jdk动态代理的区别"><a href="#3-cglib动态代理和jdk动态代理的区别" class="headerlink" title="3.cglib动态代理和jdk动态代理的区别"></a>3.cglib动态代理和jdk动态代理的区别</h2><p>动态代理，动态的创建一个代理类和他的实例对象出来，在里面引用真正需要调用的类，代理类在此做一些增强（事务、日志等）</p><p>两者区别在于 <strong>生成动态代理类的方式</strong></p><p>Spring AOP使用的 <strong>JDK动态代理</strong> ，生成实现同个接口代理类，构造实例出来。当需要代理的类没有接口时，Spring AOP会改用 <strong>Cglib动态代理</strong> ，生成该类的子类（动态生成字节码），覆盖目标类的方法，在覆盖方法中进行增强</p><ol><li><strong>JDK动态代理</strong>：代理类实现 <strong>InvocationHandler</strong> 接口， <strong>Proxy</strong> 生成代理对象，当调用接口方法时，真正会调用的是代理类的 <strong>invoke</strong> 方法</li><li><strong>Cglib动态代理</strong>：代理类实现 <strong>MethodInterceptor</strong> 接口， <strong>Enhancer</strong> 生成代理对象，当调用类方法时，拦截器会拦截在方法前后进行增强（ <strong>intercept方法</strong> ）</li></ol><h2 id="4-Spring中的Bean是线程安全的吗"><a href="#4-Spring中的Bean是线程安全的吗" class="headerlink" title="4.Spring中的Bean是线程安全的吗"></a>4.Spring中的Bean是线程安全的吗</h2><p>Spring Bean的作用域：</p><ul><li><strong>singleton</strong>：默认，单例，只有一个实例</li><li><strong>prototype</strong>：为每个bean请求都提供一个实例</li><li><strong>request</strong>：为每个网络请求request创建一个实例，请求完成后被垃圾回收</li><li><strong>session</strong>：为每个session创建一个实例，请求完成后被垃圾回收</li><li><strong>global-session</strong>：标准的HTTP Session作用域</li></ul><blockquote><p>基本大部分时候我们都使用默认的singleton单例作用域</p></blockquote><p><strong>Spring Bean是线程不安全的</strong></p><blockquote><p>例如，bean中存在一个变量data（未被volatile修饰），多线程并发（多个请求同时发起同个服务）时，多个线程同时调用实例A的同一方法（该方法里存在data++），基于线程的工作内存和主内存不一定同步的机制，就会发生线程安全问题<br>如果不存在实例变量，逻辑处理只操作数据库的话，一般不会有线程安全问题</p></blockquote><h2 id="5-Spring的事务实现原理是什么？"><a href="#5-Spring的事务实现原理是什么？" class="headerlink" title="5.Spring的事务实现原理是什么？"></a>5.Spring的事务实现原理是什么？</h2><p>日常编码中，需要对代码逻辑增加事务，使用Transactional注解，Spring会通过AOP/动态代理的机制，对方法进行增强，织入事务，方法执行前开启事务，执行成功后提交事务，异常回滚事务</p><h2 id="6-能聊聊你对Spring事务的传播机制的理解吗？"><a href="#6-能聊聊你对Spring事务的传播机制的理解吗？" class="headerlink" title="6.能聊聊你对Spring事务的传播机制的理解吗？"></a>6.能聊聊你对Spring事务的传播机制的理解吗？</h2><p><strong>事务传播机制级别 - 最常用的是前4个</strong></p><ul><li><strong>REQUIRED</strong>：如果父方法没有事务，则新创建一个事务，存在事务则加入事务</li><li><strong>SUPPORTS</strong>：如果父方法存在事务则加入事务，当前没有事务，则不开启事务执行</li><li><strong>REQUIRES_NEW</strong>：无论当前父方法有没有事务，都新建一个事务，父方法存在事务时，两者事务是隔离开的</li><li><strong>NESTED</strong>：父方法存在事务，则嵌套事务执行（外层代码出错内层代码一起回滚，内层代码出错只有内层回滚），如果没有事务，按照REQUIRED属性执行</li><li><strong>MONDATORY</strong>：如果当前父方法存在事务则加入事务，当前没有事务，则抛异常</li><li><strong>NOT_SUPPORTED</strong>：强制要求非事务运行，如果父方法存在事务则挂起</li><li><strong>NEVER</strong>：非事务方式执行，如果存在事务会报错</li></ul><p><strong>方法A调用方法B，希望方法A出错只回滚方法A自己，不回滚方法B，该怎么办</strong></p><blockquote><p>选择事务传播机制的REQUIRES_NEW</p></blockquote><p><strong>方法A调用方法B，方法B只能回滚自己，方法A可以带着方法B一起回滚</strong></p><blockquote><p>NESTED嵌套事务</p></blockquote><h2 id="7-谈谈Spring-Boot的核心架构"><a href="#7-谈谈Spring-Boot的核心架构" class="headerlink" title="7.谈谈Spring Boot的核心架构"></a>7.谈谈Spring Boot的核心架构</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringBoot-structure.jpg" alt=""></p><p>在早期java web开发时，我们使用SSM框架那一套，需要打包部署到线上的tomcat上，请求到来，根据Spring MVC框架流程，来一一调用controller、service、dao层等。</p><p>早期开发时，我们也需要根据业务引入比较多的中间件技术，例如redis、elasticsearch、rabbitmq等，引入时配置比较繁琐复杂，例如引入jar包，编写xml配置文件，定义bean等</p><p><strong>SpringBoot</strong></p><ol><li>内嵌了tomcat，上线时可以直接部署启动；</li><li>通过 <strong>自动装配</strong> 的特性，在整合第三方组件时，只要引入相关的starter依赖，会自动做一些配置、定义生成对应bean等操作，只要配置必要的相关地址等配置，一定程度上降低了原先整合的成本，详细可看<a href="http://xuyk.top/posts/SpringBoot-autoConfiguration.html">SpringBoot之自动配置原理</a></li></ol><h2 id="8-Spring-Bean的生命周期"><a href="#8-Spring-Bean的生命周期" class="headerlink" title="8.Spring Bean的生命周期"></a>8.Spring Bean的生命周期</h2><p><strong>Spring Bean大致的生命周期</strong></p><p>实例化 -&gt; 初始化 -&gt; Spring容器管理下长期存活 -&gt; 销毁</p><h3 id="1-实例化Bean"><a href="#1-实例化Bean" class="headerlink" title="1.实例化Bean"></a>1.实例化Bean</h3><p>如果需要使用bean，需要先实例化</p><ul><li>对于 BeanFactory 容器，通过 createBean 进行实例化</li><li>对于 ApplicationContext 容器，通过 BeanDefinition 进行实例化</li></ul><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h3><p>当需要使用的bean依赖其他的bean，也需要把依赖的bean创建并且注入进来，注入的方式有两种</p><ul><li><strong>构造器注入</strong></li><li><strong>setter注入</strong></li></ul><h3 id="3-处理Aware接口"><a href="#3-处理Aware接口" class="headerlink" title="3.处理Aware接口"></a>3.处理Aware接口</h3><p>如果bean实现了 ApplicationContextAware 接口，Spring容器就会通过 <code>setApplicationContext(ApplicationContext)</code> 方法，把Spring容器传递给这个bean</p><h3 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4.BeanPostProcessor"></a>4.BeanPostProcessor</h3><p>bean实例化完成之后，如果想对Bean进行一些自定义的处理，那么可以让Bean实现 BeanPostProcessor 接口，将会调用<code>postProcessBeforeInitialization(Object obj,String s)</code>方法</p><blockquote><p>初始化之前</p></blockquote><h3 id="5-初始化initializingBean与init-method"><a href="#5-初始化initializingBean与init-method" class="headerlink" title="5.初始化initializingBean与init-method"></a>5.初始化initializingBean与init-method</h3><p>对bean进行初始化</p><h3 id="6-BeanPostProcessor"><a href="#6-BeanPostProcessor" class="headerlink" title="6.BeanPostProcessor"></a>6.BeanPostProcessor</h3><p>如果Bean实现 BeanPostProcessor 接口，将会调用<code>postProcessAfterInitialization(Object obj,String s)</code>方法</p><blockquote><p>由于发生在初始化完成之后，所以经常用于内存或者缓存的操作</p></blockquote><h3 id="7-DisposableBean"><a href="#7-DisposableBean" class="headerlink" title="7.DisposableBean"></a>7.DisposableBean</h3><p>当Bean不再被需要时，如果Bean实现了DisposableBean接口，会调用他的<code>destory()</code>方法</p><h3 id="8-destroy-method"><a href="#8-destroy-method" class="headerlink" title="8.destroy-method"></a>8.destroy-method</h3><p>如果bean配置的destroy-method属性，会自动调用配置的销毁方法</p><h2 id="9-能说说Spring中使用了哪些设计模式吗"><a href="#9-能说说Spring中使用了哪些设计模式吗" class="headerlink" title="9.能说说Spring中使用了哪些设计模式吗"></a>9.能说说Spring中使用了哪些设计模式吗</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><p>Spring IOC自己就是一个大工厂，把所有bean实例都放在Spring容器中，需要使用就直接从Spring容器中拿</p><h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>Spring Bean默认使用单例，保证类在运行期间只有一个实例对象，最常见的就是懒汉式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonTest singletonTest<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonTest <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    singletonTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singletonTest<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用双重检查 + synchronized关键字保证只生成一个实例，volatile保证不发生指令重排</p></blockquote><h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h3><p>主要涉及到的就是Spirng AOP，例如XXXAware那些某个增强类，创建动态代理对象实例，在调用被代理对象的方法时，会先执行代理类的增强代码，再执行方法代码，例如Spring Bean生命周期中，实现 ApplicationContextAware 接口后，Spring容器会把 ApplicationContext 注入到bean中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring灵魂拷问系列之Spring基础拷问&quot;&gt;&lt;a href=&quot;#Spring灵魂拷问系列之Spring基础拷问&quot; class=&quot;headerlink&quot; title=&quot;Spring灵魂拷问系列之Spring基础拷问&quot;&gt;&lt;/a&gt;Spring灵魂拷问系列之Spri
      
    
    </summary>
    
    
      <category term="Spring灵魂拷问系列" scheme="http://xuyk.top/categories/Spring%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring" scheme="http://xuyk.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之Java内存模型</title>
    <link href="http://xuyk.top/posts/interview-JMM.html"/>
    <id>http://xuyk.top/posts/interview-JMM.html</id>
    <published>2021-01-17T06:25:00.000Z</published>
    <updated>2021-01-17T06:25:11.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之Java内存模型"><a href="#并发编程灵魂拷问系列之Java内存模型" class="headerlink" title="并发编程灵魂拷问系列之Java内存模型"></a>并发编程灵魂拷问系列之Java内存模型</h1><h2 id="0-面试连环炮路径"><a href="#0-面试连环炮路径" class="headerlink" title="0.面试连环炮路径"></a>0.面试连环炮路径</h2><p>JMM（Java内存模型）-&gt; 原子性、可见性、有序性 -&gt; volatile和可见性 -&gt; volatile和有序性（指令重排+happens-before）-&gt; volatile和原子性 -&gt; volatile底层原理（内存屏障级别的原理）</p><h2 id="1-聊一下Java的内存模型"><a href="#1-聊一下Java的内存模型" class="headerlink" title="1.聊一下Java的内存模型"></a>1.聊一下Java的内存模型</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM-process.jpg" alt=""></p><p>volatile：共享变量修改时会强制刷新一下主内存的值</p><ol><li>线程1/2 read 主内存的共享变量， load 到工作内存中，此时读到的值都为0</li><li>线程1/2 use 从工作内存中拿出共享变量，进行操作（比如 <strong>++</strong> 操作，那么计算之后的值都为1）</li><li>线程1/2 assign 把工作内存设置回工作内存中，之后工作内存尝试 <strong>store</strong> 写入主内存，写入成功就是 <strong>write</strong></li><li>结果就是主内存data从 0 -&gt; 1</li></ol><h2 id="2-你知道Java内存模型的原子性、有序性、可见性是什么"><a href="#2-你知道Java内存模型的原子性、有序性、可见性是什么" class="headerlink" title="2.你知道Java内存模型的原子性、有序性、可见性是什么"></a>2.你知道Java内存模型的原子性、有序性、可见性是什么</h2><p><strong>原子性</strong>：指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1。</p><p><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。Java保证可见性可以认为通过volatile、synchronized、final来实现。</p><p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行，Java通过volatile、synchronized来保证。具备有序性，则不会发生指令重排</p><p>volatile禁止指令重排序，防止编译器编译优化时对代码重新排序，导致代码顺序变化。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM_orderliness.png" alt=""></p><p>【例子】正常情况是资源准备完毕，flag才设置为true，但是如图，如果发生指令重排，可能导致先设置为true再进行资源准备，导致直接直接execute而报错</p><h2 id="3-讲讲volatile的工作原理，如何保证可见性？"><a href="#3-讲讲volatile的工作原理，如何保证可见性？" class="headerlink" title="3.讲讲volatile的工作原理，如何保证可见性？"></a>3.讲讲volatile的工作原理，如何保证可见性？</h2><p>volatile关键字用来保证 <strong>可见性</strong> 和 <strong>有序性</strong> 的，不能保证原子性（极端特殊情况下可保证而已）</p><p>举例说明无法保证原子性（还是这张图）：<br><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM-process.jpg" alt=""></p><blockquote><p>就算使用volatile修饰data，当线程1更新data=1到主内存，使得线程二工作内存的data值失效，但是可能此时data已经在被运算中，及时失效了，还是会通过assign把data=1设置到工作内存中，最后write到主内存<br>需要保证原子性，还是需要 <strong>synchronized</strong> 、 <strong>lock</strong> 来保证</p></blockquote><p>当volatile修饰值data，保证data在多线程之间的 <strong>可见性</strong> ，如果data修改，会强制刷新其他线程工作内存中的data的值（让其他线程工作内存data的值失效，来起到强制刷新的作用）</p><p>volatile通过 <strong>禁止指令重排</strong> 来保证 <strong>有序性</strong> </p><h2 id="4-你知道指令重排和happens-before是什么吗？"><a href="#4-你知道指令重排和happens-before是什么吗？" class="headerlink" title="4.你知道指令重排和happens-before是什么吗？"></a>4.你知道指令重排和happens-before是什么吗？</h2><p>一般情况下，为了提高程序执行的效率，编译器或者指令器会对代码进行优化，例如指令重排。</p><p>java中有一个 <strong>happens-before</strong> 原则,<strong>一定程度上来避免胡乱地指令重排</strong>。他在一些特殊情况下，不允许编译器或者指令器对写的代码进行指令重排。</p><p>其中有一个与volatile相关的原则，如果代码中存在volatile修饰的值，此值进行volatile写后，再volatile读，那么顺序上必须先写再读</p><blockquote><p>比如代码中,代码顺序A-&gt;B-&gt;C，那么A的顺序就优于C；或者比如对lock的操作顺序不能被重排（代码先unlock再lock，就不能重排为lock后unlock，否则导致流程错乱）</p></blockquote><h2 id="5-volatile是如何基于内存屏障保证可见性和有序性的？"><a href="#5-volatile是如何基于内存屏障保证可见性和有序性的？" class="headerlink" title="5.volatile是如何基于内存屏障保证可见性和有序性的？"></a>5.volatile是如何基于内存屏障保证可见性和有序性的？</h2><p>内存屏障：禁止重排序</p><p><strong>如何保证有序性</strong><br>如果使用了volatile修饰一个值后，那么会对该值的读写前后会加入一些内存屏障，加入屏障之后，来避免发生指令重排</p><p><strong>如何保证可见性</strong><br>如果使用了volatile修饰一个值data后，在对data执行写操作，JVM会发送<strong>lock前缀指令</strong>给CPU，CPU收到指令，计算完毕会把data强制刷新到主内存里，其他线程通过<strong>对总线的嗅探</strong>，让工作内存的data值失效，之后读取data值时因为工作内存data值失效，所以从缓存中获取。保证了可见性</p><blockquote><p>lock前缀指令 + MESI缓存一致性协议</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之Java内存模型&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之Java内存模型&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之Java内存模型&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JMM" scheme="http://xuyk.top/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之对AQS理解吗</title>
    <link href="http://xuyk.top/posts/interview-AQS.html"/>
    <id>http://xuyk.top/posts/interview-AQS.html</id>
    <published>2021-01-16T09:05:00.000Z</published>
    <updated>2021-01-24T07:03:44.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之对AQS理解吗"><a href="#并发编程灵魂拷问系列之对AQS理解吗" class="headerlink" title="并发编程灵魂拷问系列之对AQS理解吗"></a>并发编程灵魂拷问系列之对AQS理解吗</h1><p><strong>AQS</strong> 即 AbstractQueuedSynchronizer，队列同步器。早期是因为JDK6以前的synchronized关键字使用的是重量级锁，性能不太好，所以作者编写了AQS。</p><p>在JUC中 CountDownLatch、ReentrantLock、ThreadPoolExecutor、ReentrantReadWriteLock 等底层用的都是AQS，AQS几乎占据了JUC并发包里的半壁江山，如果想要获取锁可以被中断、超时获取锁、尝试获取锁那就用AQS吧。</p><p>AQS内部维护了一个 <strong>先进先出队列</strong> 和 <strong>state状态变量</strong></p><ul><li>先进先出队列载体是 Node节点，节点里包含状态值，属于独占/共享模式，前驱/后继节点等信息</li><li>state由 <strong>volatile</strong> 修饰，标识当前锁的状态，1表示加锁成功 0未加锁</li></ul><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AQS-first.png" alt=""></p><ol><li>当线程1操作CAS加锁成功，AQS中的加锁线程变为线程1，state设置为1。</li><li>与此同时线程2加锁失败会进入FIFO先进先出等待队列，当线程1执行完成后，state设为0，然后唤醒等待队列的首位线程也就是线程2，让线程2进行CAS操作</li></ol><p><strong>独占式锁和共享式锁</strong></p><ul><li>独占式：有且只有一个线程能获取到锁，如：ReentrantLock。</li><li>共享式：可以多个线程同时获取到锁，如：CountDownLatch</li></ul><p><strong>公平锁和非公平锁</strong></p><ul><li>公平锁：先到先得，线程通过排队的方式来获取锁</li><li>非公平锁：后来的线程可能会率先获取到锁，非公平锁性能优于公平锁</li></ul><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/k8s-B1ZsEQylba4NWjehEA">由浅入深逐步讲解Java并发的半壁江山AQS</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/ZNURbYIdYqDNXLtRAvDxBQ">1.5w字，30图带你彻底掌握 AQS</a><br>4：<a href="https://mp.weixin.qq.com/s/-OEOk5NNgyjI8aYBm9Sspg">【对线面试官】AQS&amp;&amp;ReentrantLock</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之对AQS理解吗&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之对AQS理解吗&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之对AQS理解吗&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之对AQS理解吗&lt;/h1&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="AQS" scheme="http://xuyk.top/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之如何理解CAS</title>
    <link href="http://xuyk.top/posts/interview-CAS.html"/>
    <id>http://xuyk.top/posts/interview-CAS.html</id>
    <published>2021-01-15T01:12:00.000Z</published>
    <updated>2021-01-24T06:46:42.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之如何理解CAS"><a href="#并发编程灵魂拷问系列之如何理解CAS" class="headerlink" title="并发编程灵魂拷问系列之如何理解CAS"></a>并发编程灵魂拷问系列之如何理解CAS</h1><p><strong>什么是CAS</strong></p><p> CAS，compare And set/swap等，他底层的硬件级别操作（CPU指令cmpxchg）来保证一定是原子性操作，让同一时间只能有一个线程执行CAS操作，在此时间其他线程执行CAS会失败。java里经常使用unsafe类来执行CAS操作</p><p> CAS有三个参数：<strong>当前值A、内存值V、修改的新值B</strong></p><ul><li>如果A和V相等，则把内存值V修改成新值B</li><li>如果A和V不相等，要么重试，要么放弃更新</li></ul><p><strong>为什么要使用CAS呢</strong></p><ul><li>synchronized关键字每次都需要使用锁来保证同一时间只有一个线程执行操作</li><li>CAS允许多个线程同时操作共享数据，但是同一时间只能有一个线程执行CAS操作，在很多情况下比synchronized更加高效，例如 <strong>对一个值进行累加</strong> 这样的操作</li></ul><blockquote><p>AtomicLong等底层使用了CAS，但是更推荐使用LongAdder，性能更高（数组来分散目标值减少自旋重试）</p></blockquote><p><strong>CAS的缺点</strong></p><ul><li>无法解决ABA的问题（共享变量从A -&gt; B -&gt; A），需要加一个版本号</li><li>循环时间长导致资源消耗</li><li>循环执行CAS操作不成功会陷入自旋而耗费cpu资源，锁竞争激烈的场景更倾向于使用重量级锁</li></ul><blockquote><p>解决ABA问题，可以使用结合 <strong>乐观锁</strong> 的机制，例如Java中的 <strong>AtomicStampedReference</strong> 类</p></blockquote><p><strong>使用场景</strong></p><ol><li>如果高并发执行时间久 ，用SYN好， 因为SYN底层用了wait() 阻塞后是不消耗CPU资源的</li><li>如果锁竞争不激烈说明自旋不严重，此时用CAS。</li></ol><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/kvuPxn-vc8dke093XSE5IQ">由浅入深讲解JUC下 CAS + Lock</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/uHl9cnNBtvY_Xc-5WfwpmQ">【对线面试官】 CAS</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之如何理解CAS&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之如何理解CAS&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之如何理解CAS&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之如何理解CAS&lt;/h1&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="CAS" scheme="http://xuyk.top/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之ConcurrentHashMap</title>
    <link href="http://xuyk.top/posts/interview-ConcurrentHashMap.html"/>
    <id>http://xuyk.top/posts/interview-ConcurrentHashMap.html</id>
    <published>2021-01-13T08:40:00.000Z</published>
    <updated>2021-01-13T08:40:49.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之ConcurrentHashMap"><a href="#并发编程灵魂拷问系列之ConcurrentHashMap" class="headerlink" title="并发编程灵魂拷问系列之ConcurrentHashMap"></a>并发编程灵魂拷问系列之ConcurrentHashMap</h1><h2 id="那有什么线程安全的HashMap可以代替呢"><a href="#那有什么线程安全的HashMap可以代替呢" class="headerlink" title="那有什么线程安全的HashMap可以代替呢"></a>那有什么线程安全的HashMap可以代替呢</h2><p>一般面试连环炮会在大致问完HashMap后有此一问，<strong>既然HashMap是线程不安全的，那有什么线程安全的HashMap可以代替呢</strong>，就是为了引出ConcurrentHashMap。</p><ul><li><p>JDK1.8之前：采用分段锁的机制，整个数组被分为对个段（segment），每一段都有一个锁，段与段之间可以并发访问，但是多个线程同时访问同一段时，需要获取锁才能进行访问，提升了一定的性能，但是高并发下性能还是不够强</p></li><li><p>JDK1.8之后：取消分段锁机制，回归一个大数组的方式，采用CAS + synchronized，数据结构和Hashmap一样，使用数组 + 链表 + 红黑树</p></li></ul><blockquote><p>【分析】：JDK1.8之后，锁的粒度控制到了数组的每一个元素，当多线程对数组同一个元素进行操作比如put等，会先通过 CAS 的方式让同一时间只有一个线程A成功执行 CAS ，然后进行put ，其他线程就会使用synchronized 关键字对这个数组元素对象加锁，串行的等待线程A执行完毕后继续获取锁，进行后续操作</p></blockquote><p>【总结】：JDK1.8之后的ConcurrentHashMap，当多个线程对数组不同位置的元素进行操作时，可以并发操作；如果多个线程对数组统一位置元素进行操作时，则加锁串行化处理</p><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/XajTc9dqNNi_ByLR2B_J3A">为什么ConcurrentHashMap的读操作不需要加锁？</a><br>2：<a href="https://mp.weixin.qq.com/s/wZWPg2ldcG1QwHbk6oPOWQ">面试官邪魅一笑: 你说说 Java8 的 ConcurrentHashMap ？</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之ConcurrentHashMap&quot;&gt;&lt;/a&gt;并发
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://xuyk.top/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>并发编程灵魂拷问系列之说说synchronized</title>
    <link href="http://xuyk.top/posts/interview-synchronized.html"/>
    <id>http://xuyk.top/posts/interview-synchronized.html</id>
    <published>2021-01-10T02:04:00.000Z</published>
    <updated>2021-01-24T07:10:44.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之synchronized"><a href="#并发编程灵魂拷问系列之synchronized" class="headerlink" title="并发编程灵魂拷问系列之synchronized"></a>并发编程灵魂拷问系列之synchronized</h1><h2 id="1-什么是synchronized，JDK1-6前后变化？"><a href="#1-什么是synchronized，JDK1-6前后变化？" class="headerlink" title="1.什么是synchronized，JDK1.6前后变化？"></a>1.什么是synchronized，JDK1.6前后变化？</h2><p>我们可以知道，并发问题一般都是因为 <strong>多个线程同时操作同一个共享数据</strong> 所造成的，解决办法就是加锁，例如 <strong>synchronized加锁</strong></p><ul><li>JDK1.6之前：synchronized使用的是操作系统的互斥锁（底层操作系统的mutex相关指令），因为需要在用户态和内核态进行切换，开销很大，导致并发激烈时性能很差</li><li>JDK1.6之后：进行了锁优化，比如锁升/分级、锁消除、锁粗化等，性能大幅提高，推荐使用</li></ul><h2 id="2-那synchronized底层原理是什么呢？"><a href="#2-那synchronized底层原理是什么呢？" class="headerlink" title="2.那synchronized底层原理是什么呢？"></a>2.那synchronized底层原理是什么呢？</h2><p>synchronized属于 <strong>非公平锁</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>synchronized是基于Monitor来实现同步的，每一个对象都有对应着一个Monitor，如果需要加锁，则必须获取monitor的lock锁。</p><p>monitor锁是可重入锁，有一个计数器，当进入同步代码块时，执行monitorenter指令，计数器+1，退出一个同步代码块时，执行monitorexit指令，计数器-1；当发生对同一对象多次加锁时，计数器加减多次</p><ol><li>对于同步方法，JVM采用 <strong>ACC_SYNCHRONIZED</strong> 标记符来实现同步。</li><li>对于同步代码块。JVM采用 <strong>monitorenter</strong> 、<strong>monitorexit</strong> 两个指令来实现同步。</li></ol><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/synchronized-monitor.jpg" alt=""></p><h2 id="3-什么是锁升-分级？"><a href="#3-什么是锁升-分级？" class="headerlink" title="3.什么是锁升/分级？"></a>3.什么是锁升/分级？</h2><blockquote><p>synchronized 一般来说都对 <strong>对象</strong> 进行加锁</p></blockquote><p>这个可以从对象入手分析，对象在 <strong>堆</strong> 的存储中存有对象头，对象头中的 <strong>Mark Word</strong> 存储着对象的运行时数据，包括对象的hashcode、对象持有的锁等，当中锁从状态进行了分类：</p><p><strong>无锁、偏向锁、轻量级锁、重量级锁</strong>。</p><p>线程获取锁，会根据锁竞争激烈程度进行锁升级来提高性能，<strong>锁可以升级但是不能降级</strong>。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/synchronized-lock-update1.png" alt=""></p><p><strong>总结：</strong></p><ol><li><p><strong>偏向锁</strong>：作者认为很多情况都是一个线程多次获取锁，这种情况加锁解锁最好不需要消耗太多资源，引入了偏向锁。当一个线程获取到锁，锁进进入了偏向模式（偏向锁），下一次该线程获取锁时，不需要额外进行额外进行操作，减少消耗。<strong>所以适合没有多线程来竞争锁的场景</strong></p></li><li><p><strong>轻量级锁</strong>：当其他线程来竞争原本偏向线程A的偏向锁时，等线程A释放锁后，该锁的偏向锁被撤销，升级为轻量级锁（只有发生了多线程之间的锁竞争，该锁会从偏向锁升级为轻量级锁）。<br>轻量级锁生效后，当线程X持有锁时，线程Y获取该对象的锁被线程X持有，则进行 <strong>自旋</strong> （循环使用CAS来获取锁）</p></li><li><p><strong>重量级锁</strong>：当线程Y自旋超过一定时间或者次数，锁会升级为重量级锁，防止CPU空转（自旋过久）。升级为重量级锁后，线程Y不在主动获取锁，而是线程X释放锁之后通知线程Y去获取锁，线程Y从自旋变为阻塞。</p></li></ol><p>简单来说：</p><ul><li><strong>偏向锁</strong>：在Mark Word 记录线程ID进行比对</li><li><strong>轻量级锁</strong>：通过CAS + 自旋的方式竞争</li><li><strong>重量级锁</strong>：使用monitor对象，阻塞</li></ul><h2 id="4-什么是锁消除？"><a href="#4-什么是锁消除？" class="headerlink" title="4.什么是锁消除？"></a>4.什么是锁消除？</h2><p>前文可知，线程安全问题条件之一是存在共享数据，但是当 <strong>synchronized</strong> 修饰的代码块中不存在共享数据时，JDK会通过逃逸分析判断这段代码不会有线程安全问题，自动消除这个锁</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>someMethod方法中的object是局部变量，当多个线程进入方法，会new一个新的object，不存在共享数据，所以会进行 <strong>锁消除</strong></p></blockquote><h2 id="5-什么是锁粗化？"><a href="#5-什么是锁粗化？" class="headerlink" title="5.什么是锁粗化？"></a>5.什么是锁粗化？</h2><p>将多个加锁解锁操作连接在一起，JDK会根据优化策略将其扩展成一个范围更大的锁</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 粗化前</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do some thing</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 能够很快执行完毕，且无需同步的代码</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 粗化后：</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//进行锁粗化：整合成一次锁请求、同步、释放</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do some thing</span>        <span class="token comment" spellcheck="true">// 能够很快执行完毕，且无需同步的代码</span>        <span class="token comment" spellcheck="true">// do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-synchronized都可以修饰哪些对象？"><a href="#6-synchronized都可以修饰哪些对象？" class="headerlink" title="6.synchronized都可以修饰哪些对象？"></a>6.synchronized都可以修饰哪些对象？</h2><ul><li>1.修饰实例方法：锁定的是this对象（类锁）</li><li>2.修饰静态方法：锁定的是class对象（对象内置锁）</li><li>3.修饰代码块：锁定任意指定的对象</li></ul><h2 id="7-synchronized有什么缺点呢"><a href="#7-synchronized有什么缺点呢" class="headerlink" title="7.synchronized有什么缺点呢"></a>7.synchronized有什么缺点呢</h2><ul><li>1.锁的粒度还是比较大的</li><li>2.锁竞争激烈情况下，可能发生死锁</li><li>3.锁竞争激烈时，因为串行化，多个线程排队竞争锁效率不会太高</li></ul><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/8UtdfawQ">synchronized和锁</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/e_fYFWK5Qnxjmz6Abi7uqw">由浅入深逐步了解 Synchronized</a><br>4：<a href="https://mp.weixin.qq.com/s/v1XgT2X4IuF3_WNqeUVhVA">全网最细：17张图带你秒杀synchronized关键字</a><br>5:<a href="https://mp.weixin.qq.com/s/wwGvEt_3x9oHORwuXDqX5g">【对线面试官】synchronized</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程灵魂拷问系列之synchronized&quot;&gt;&lt;a href=&quot;#并发编程灵魂拷问系列之synchronized&quot; class=&quot;headerlink&quot; title=&quot;并发编程灵魂拷问系列之synchronized&quot;&gt;&lt;/a&gt;并发编程灵魂拷问系列之synchr
      
    
    </summary>
    
    
      <category term="并发编程灵魂拷问系列" scheme="http://xuyk.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="synchronized" scheme="http://xuyk.top/tags/synchronized/"/>
    
  </entry>
  
</feed>
