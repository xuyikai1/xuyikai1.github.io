<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis灵魂拷问系列之如何保证数据库和缓存双写一致性</title>
      <link href="/posts/interview-redis-database-writeConsistency.html"/>
      <url>/posts/interview-redis-database-writeConsistency.html</url>
      
        <content type="html"><![CDATA[<h1 id="redis灵魂拷问系列之如何保证数据库和缓存双写一致性"><a href="#redis灵魂拷问系列之如何保证数据库和缓存双写一致性" class="headerlink" title="redis灵魂拷问系列之如何保证数据库和缓存双写一致性"></a>redis灵魂拷问系列之如何保证数据库和缓存双写一致性</h1><h2 id="1-什么是数据库缓存双写一致性呢？"><a href="#1-什么是数据库缓存双写一致性呢？" class="headerlink" title="1.什么是数据库缓存双写一致性呢？"></a>1.什么是数据库缓存双写一致性呢？</h2><p>一般为了加快查询响应速度等，我们通过加缓存来提高接口的QPS，例如redis缓存、JVM缓存等。</p><p>数据是 <strong>缓存和数据库共享的</strong>。在 <strong>高并发场景下更新数据</strong> 时，因为数据库和缓存都要更新，就很可能会有数据一致性问题，其实也是分布式场景下数据一致性的问题</p><blockquote><p>什么时候会发生数据库缓存双写不一致的情况呢？</p></blockquote><p>例如：高并发场景下，先更新数据库，再删除缓存之后，另外一个线程把旧数据存入缓存</p><h2 id="2-选择更新缓存还是删除缓存？"><a href="#2-选择更新缓存还是删除缓存？" class="headerlink" title="2.选择更新缓存还是删除缓存？"></a>2.选择更新缓存还是删除缓存？</h2><p>这里就需要提到<strong>Cache Aside Pattern</strong>，也是我们日常编码中一般会采取的策略 </p><ol><li>读取数据时，先读缓存，缓存不存在再读数据库，然后把结果存入缓存</li><li>更新数据时，先更新数据库，再删除缓存</li></ol><p><strong>为什么是删除缓存不是更新缓存呢？</strong></p><p>假如为 <strong>更新缓存</strong></p><ul><li>如果数据更新频繁，则每一次都需要更新缓存，如果加上还是联表查询，则更新缓存的代价就很大</li><li>如果数据不会被频繁查询到（冷数据），这时候频繁更新缓存则是在浪费资源（例如数据A一分钟内被更新20次，但是只查询了一次）</li><li>还可能存在更新缓存失败的情况</li></ul><p>假如为 <strong>删除缓存</strong></p><ul><li>数据在删除后，第一次被访问时，会从数据库读取（类似懒加载方式），保证了只有被用到才去操作，减少了资源浪费</li></ul><blockquote><p>所以当之无愧，选择 <strong>删除缓存</strong></p></blockquote><h2 id="3-先更新数据库，还是先删除缓存？"><a href="#3-先更新数据库，还是先删除缓存？" class="headerlink" title="3.先更新数据库，还是先删除缓存？"></a>3.先更新数据库，还是先删除缓存？</h2><ol><li><strong>先删除缓存，删除成功后去更新数据库</strong>。会出现问题：高并发场景下，删除成功后，可能另外一个请求查询后又把旧数据存入缓存中。这时候要么采用 <strong>延迟双删</strong>，也就是睡眠一定时间后再次删除一次，要么选择下一种做法</li><li><strong>先更新数据库，再删除缓存</strong>。会出现问题：高并发下，在删除成功后，可能其他线程把旧数据再存入缓存中的问题。也会出现数据不一致的情况（影响相对较小所以可以接受）</li></ol><h2 id="4-具体落地的解决策略有哪些？"><a href="#4-具体落地的解决策略有哪些？" class="headerlink" title="4.具体落地的解决策略有哪些？"></a>4.具体落地的解决策略有哪些？</h2><p><strong>（1）延时双删策略</strong></p><ul><li>a. 删除缓存 </li><li>b. 更新数据库 </li><li>c. 睡眠一段时间，具体多长有业务决定（mysql读写分离的话还需要加上主从同步时间）</li><li>d. 再删除缓存（吞吐量降低的话使用 <strong>异步</strong>）</li></ul><p><strong>（2）更新数据库、后删缓存</strong></p><p><strong>（3）串行化思维保证两者的最终一致性</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-binlog-mq.jpg" alt=""></p><p>利用binlog天然的顺序性用来做同步操作，顺序删除缓存，删除缓存失败则使用消息队列的同步性重试删除缓存</p><p><strong>（4）强一致性</strong></p><blockquote><p>如果需要保证强一致性，那么是否还有添加缓存的必要（没有海量qps的情况下）？</p></blockquote><p>可以参考这篇文章：<a href="https://blog.kido.site/2018/12/09/db-and-cache-04/">缓存与数据库一致性系列-04 - Kido的博客 | Kido’s Blog</a></p><blockquote><p>【参考链接】<br>1：<a href="https://zhuanlan.zhihu.com/p/59167071">Redis与Mysql双写一致性方案解析</a><br>2：<a href="https://blog.kido.site/2018/12/08/db-and-cache-03/">缓存与数据库一致性系列-03</a><br>3：<a href="https://blog.kido.site/2018/12/09/db-and-cache-04/">缓存与数据库一致性系列-04</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库和缓存双写一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis灵魂拷问系列之过期策略与数据持久化</title>
      <link href="/posts/interview-redis-data-expireAndStore.html"/>
      <url>/posts/interview-redis-data-expireAndStore.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis灵魂拷问系列之过期策略与数据持久化"><a href="#Redis灵魂拷问系列之过期策略与数据持久化" class="headerlink" title="Redis灵魂拷问系列之过期策略与数据持久化"></a>Redis灵魂拷问系列之过期策略与数据持久化</h1><h2 id="1-redis过期策略能说一下吗"><a href="#1-redis过期策略能说一下吗" class="headerlink" title="1.redis过期策略能说一下吗"></a>1.redis过期策略能说一下吗</h2><h3 id="1-1-redis为什么需要过期策略"><a href="#1-1-redis为什么需要过期策略" class="headerlink" title="1.1 redis为什么需要过期策略"></a>1.1 redis为什么需要过期策略</h3><p>我们平常用 redis 做缓存时，可能会有一些问题：为什么有的key塞入之后就会消失，如果真的发现这样的情况，说明可能 redis 没有用对。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-stageTime.png" alt="图量化系统的各种延时时间图"></p><p>redis 本质上属于 <strong>内存数据库</strong>，把内存当作缓存使用，可以从图中看出，内存属于 ns 级别，可见速度是很快的。但是内存也是宝贵的，可以从几千的电脑只有 那么16、32G的内存，而可以有1T的硬盘中看出。</p><p>当内存被你不断塞入的数据给塞满，那么 redis 就会在你再次塞入数据时根据一些算法（LRU、LFU等）给你淘汰一些数据，才能保证你能存入数据</p><h3 id="1-2-定期删除、惰性删除"><a href="#1-2-定期删除、惰性删除" class="headerlink" title="1.2 定期删除、惰性删除"></a>1.2 定期删除、惰性删除</h3><p>redis使用 <strong>定期删除 + 惰性删除</strong> 的方式淘汰过期数据</p><ul><li><strong>定期删除</strong>：redis在定期删除（比如100ms）时，不会每次都把过期的key全部删除，而是随机抽取一些过期数据进行删除</li><li><strong>惰性删除</strong>：当过期数据被访问时，redis 会进行检查，如果过期则进行删除</li></ul><p>但是这样还是会有一些问题，如果过期数据定期删除时一直未被删除，又一直未被查询导致不走惰性删除，那么还是会一直占据着内存空间，最终导致内存占满。redis 使用 <strong>内存淘汰机制</strong> 来处理这一问题。</p><h3 id="1-3-内存淘汰机制"><a href="#1-3-内存淘汰机制" class="headerlink" title="1.3 内存淘汰机制"></a>1.3 内存淘汰机制</h3><p>redis在内存占用过多时，会自行使用一些淘汰算法，淘汰一些数据</p><ul><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）</li><li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</li><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错（很少用）</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key（很少用）</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key（很少用）</li></ul><h3 id="1-4-可以手写一个LRU算法吗"><a href="#1-4-可以手写一个LRU算法吗" class="headerlink" title="1.4 可以手写一个LRU算法吗"></a>1.4 可以手写一个LRU算法吗</h3><p>我们可以基于Java的数据结构 <strong>LinkedHashMap</strong> 来写一个</p><p>大致思路：创建LRUCache类，继承LinkedHashMap类，定义一个存放数据数量的阈值，编写构造器方法，使用LinkedHashMap类的构造器方法，设置初始容量、负载因子以及按访问顺序排序（true），重写<code>removeEldestEntry()</code>方法，设置当容量超过阈值时，会把最少访问的数据删除</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CACHE_SIZE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 传递进来最多能缓存多少数据     *     * @param cacheSize 缓存大小     */</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> cacheSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>cacheSize <span class="token operator">/</span> <span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CACHE_SIZE <span class="token operator">=</span> cacheSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> CACHE_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-redis持久化RDB和AOF"><a href="#2-redis持久化RDB和AOF" class="headerlink" title="2.redis持久化RDB和AOF"></a>2.redis持久化RDB和AOF</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-RDB-AOF.png" alt=""></p><blockquote><p>也不妨瞧瞧官方怎么说的：<a href="http://www.redis.cn/topics/persistence.html">REDIS persistence</a></p></blockquote><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/8HN1PqqU57Kdz9ERwDY2cw">Redis 核心篇：唯快不破的秘密</a><br>2：<a href="https://www.cnblogs.com/madashu/p/12832766.html">Redis 6.0 新特性-多线程连环13问！</a><br>3：<a href="http://www.redis.cn/">redis中文官方网站</a><br>4：<a href="http://www.redis.cn/topics/persistence.html">redis 数据持久化-官方网站</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis过期策略 </tag>
            
            <tag> Redis数据持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis灵魂拷问系列之数据结构和单线程模型</title>
      <link href="/posts/interview-redis-structure.html"/>
      <url>/posts/interview-redis-structure.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis灵魂拷问系列之数据结构和单线程模型"><a href="#Redis灵魂拷问系列之数据结构和单线程模型" class="headerlink" title="Redis灵魂拷问系列之数据结构和单线程模型"></a>Redis灵魂拷问系列之数据结构和单线程模型</h1><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/8HN1PqqU57Kdz9ERwDY2cw">Redis 核心篇：唯快不破的秘密</a><br>2：<a href="https://www.cnblogs.com/madashu/p/12832766.html">Redis 6.0 新特性-多线程连环13问！</a><br>3：<a href="http://www.redis.cn/">redis中文官方网站</a><br>4：<a href="https://mp.weixin.qq.com/s/DC-xgcOyX3lBb1pwm---ZA">redis三种高级数据结构</a><br>5：<a href="https://www.jianshu.com/p/4c8e119f35db">redis 学习（13）– BitMap</a><br>6：<a href="https://zhuanlan.zhihu.com/p/92538808">Redis 到底是怎么实现“附近的人”这个功能的呢？</a></p></blockquote><p>[TOC]</p><h2 id="1-说说Redis单线程模型，为什么单线程还有很高的效率"><a href="#1-说说Redis单线程模型，为什么单线程还有很高的效率" class="headerlink" title="1.说说Redis单线程模型，为什么单线程还有很高的效率"></a>1.说说Redis单线程模型，为什么单线程还有很高的效率</h2><p>我们要明确的是：<strong>Redis 的单线程指的是 Redis 的网络 IO 以及键值对指令读写是由一个线程来执行的</strong>，对于 Redis 的持久化、集群数据同步、异步删除等都是 <strong>其他线程</strong> 执行。</p><blockquote><p>根据官方数据，Redis 的 QPS 可以达到约 100000（每秒请求数），有兴趣的可以参考官方的基准程序测试《How fast is Redis？》，地址：<a href="https://redis.io/topics/benchmarks">https://redis.io/topics/benchmarks</a></p></blockquote><p>一般的网络IO流程大致有以下事件</p><ul><li>listen 监听客户端请求</li><li>accept 建立客户端连接</li><li>receive 读取客户端请求</li><li>write 写入/响应数据</li></ul><p>如果是传统同步阻塞IO的话，在上述各操作未处理完毕时都会处于阻塞等待状态；而redis采用IO多路复用，不会阻塞在某一个特定的处理上，借此可以同时处理多个客户端的请求，提升并发性</p><p><strong>IO多路复用</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-io-multiplexing.png" alt=""></p><p>redis采用IO多路复用的方式，通过复用一个线程，来同时监听多个socket连接，根据标识符判断socket是否就绪（可建立连接、可读等），已就绪就将socket放入一个阻塞队列中。</p><p>由一个 <strong>文件事件分派器</strong> 依次不断地从队列中取出socket，再针对socket需要处理的事件类型来指派给对应的处理器</p><ol><li><strong>连接应答处理器</strong>：处理客户端连接请求</li><li><strong>命令请求处理器</strong>：处理redis命令请求</li><li><strong>命令回复处理器</strong>：redis命令请求由 <strong>命令请求处理器</strong> 处理完毕后关联至 <strong>命令回复处理器</strong> 来返回命令请求相关响应</li></ol><p><strong>为什么redis单线程模型效率也能这么高？</strong></p><ol><li>纯内存操作，属于纳秒级别</li><li>高效率的核心是使用了非阻塞的IO多路复用机制</li><li>单线程反而避免了多线程频繁切换上下文耗费资源的问题</li></ol><h2 id="2-那为什么redis-6-0又引入了多线程呢"><a href="#2-那为什么redis-6-0又引入了多线程呢" class="headerlink" title="2.那为什么redis 6.0又引入了多线程呢"></a>2.那为什么redis 6.0又引入了多线程呢</h2><p>严格来讲，redis 4.0之后都是用的多线程，而网络 IO 以及键值对指令读写是由单线程处理，对于 Redis 的持久化、集群数据同步、异步删除等都是 其他线程 执行。</p><p>redis 6.0默认关闭多线程，如若要开启，需要在 redis.conf 文件中 <strong>io-threads-do-reads yes</strong>，并且设置线程数 <strong>io-threads 4</strong></p><blockquote><p>官方建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数</p></blockquote><p>开启IO多线程确实可以显著提升性能，但是如果要开启多线程，至少要4核的机器，且Redis实例已经占用相当大的CPU耗时的时候才建议采用，否则使用多线程没有意义。所以估计80%的公司开发人员看看就好</p><h2 id="3-redis都有哪些基本数据结构？分别在哪些场景下使用比较合适？"><a href="#3-redis都有哪些基本数据结构？分别在哪些场景下使用比较合适？" class="headerlink" title="3.redis都有哪些基本数据结构？分别在哪些场景下使用比较合适？"></a>3.redis都有哪些基本数据结构？分别在哪些场景下使用比较合适？</h2><h3 id="3-1-String"><a href="#3-1-String" class="headerlink" title="3.1 String"></a>3.1 String</h3><p><strong>简单的key/value结构</strong></p><ol><li>一般用来做 <strong>缓存、分布式锁</strong> 等，其中分布式锁一般涉及到的就是setnx以及expire等命令</li></ol><blockquote><p>string 命令笔记：<a href="http://note.youdao.com/s/WNOIrxPQ">redis string</a></p></blockquote><h3 id="3-2-Hash"><a href="#3-2-Hash" class="headerlink" title="3.2 Hash"></a>3.2 Hash</h3><p><strong>类似map的结构</strong></p><ol><li>一般存放一些对象，比如用户信息等，可以指定修改对象其中的某个属性</li></ol><blockquote><p>hash 命令笔记：<a href="http://note.youdao.com/s/EnT00O13">redis hash</a></p></blockquote><h3 id="3-3-List"><a href="#3-3-List" class="headerlink" title="3.3 List"></a>3.3 List</h3><p>属于 <strong>有序队列</strong></p><ol><li>一般可以用来保存 <strong>粉丝列表、评论列表</strong> 等，其中的lrange命令可以实现高性能的分页功能，很实用；</li><li>也可以用来当做 <strong>简单的消息队列</strong> （lpush、rpop命令）使用，如果你的项目没有引入第三方消息队列组件，而依赖redis，不妨用redis做一个消息队列玩玩</li></ol><blockquote><p>list 命令笔记：<a href="http://note.youdao.com/s/AUfgbHFC">redis list</a></p></blockquote><h3 id="3-4-Set"><a href="#3-4-Set" class="headerlink" title="3.4 Set"></a>3.4 Set</h3><p><strong>无需集合、自动去重</strong></p><ol><li>单机场景可以使用jvm中的HashSet去重，在多台机器上则可以直接使用redis set；</li><li>可以基于set做一些交集、并集、差集的操作，例如QQ中两人的共同好友（交集）</li></ol><blockquote><p>set 命令笔记：<a href="http://note.youdao.com/s/Sgb2Y2KA">redis set</a></p></blockquote><h3 id="3-5-Zset（sorted-set）"><a href="#3-5-Zset（sorted-set）" class="headerlink" title="3.5 Zset（sorted set）"></a>3.5 Zset（sorted set）</h3><p><strong>排序的set</strong>，既可以去重也可以排序，每个key写入时会给一个 <strong>分数score</strong> ，redis自动根据分数进行排序</p><ol><li>可以做一些  <strong>访问量/点击量排行榜</strong></li></ol><blockquote><p>zset 命令笔记：<a href="http://note.youdao.com/s/Nw7KLxLR">redis zset</a></p></blockquote><h2 id="4-那redis有没有哪些高级数据结构平常可以使用到呢？"><a href="#4-那redis有没有哪些高级数据结构平常可以使用到呢？" class="headerlink" title="4.那redis有没有哪些高级数据结构平常可以使用到呢？"></a>4.那redis有没有哪些高级数据结构平常可以使用到呢？</h2><h3 id="4-1-bitMap-位图"><a href="#4-1-bitMap-位图" class="headerlink" title="4.1 bitMap 位图"></a>4.1 bitMap 位图</h3><p>bitMaps并不是真实的数据结构，其实是个 byte 数组，用二进制表示，只有 0 和 1 两个数字</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-redis-bitMap.png" alt=""></p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> setbit login_2019_06_17  <span class="token number">10000</span> <span class="token function">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> setbit login_2019_06_17  <span class="token number">1024</span> <span class="token function">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> setbit login_2019_06_17  <span class="token number">238</span> <span class="token function">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> setbit login_2019_06_17  <span class="token number">3434</span> <span class="token function">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> bitcount <span class="token function">login_2019_06_17</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用场景</strong></p><ol><li>用户签到、统计用户登录情况（活跃用户）、用户是否在线</li><li>实现布隆过滤器，避免推荐给用户已推荐的数据</li></ol><blockquote><p>布隆过滤器详情可以看看这篇文章：<a href="http://xuyk.top/posts/bloom-filter.html">5分钟搞懂布隆过滤器</a></p></blockquote><h3 id="4-2-HyperLogLog"><a href="#4-2-HyperLogLog" class="headerlink" title="4.2 HyperLogLog"></a>4.2 HyperLogLog</h3><p>Redis HyperLogLog 是用来做 <strong>基数统计</strong> 的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p><strong>使用场景</strong></p><ol><li>统计用户日活月活</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> pfadd login<span class="token punctuation">.</span>2019_06_17 <span class="token function">user1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span>  pfadd login<span class="token punctuation">.</span>2019_06_17 <span class="token function">user2</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span>  pfadd login<span class="token punctuation">.</span>2019_06_17 <span class="token function">user3</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span>  pfadd login<span class="token punctuation">.</span>2019_06_17 <span class="token function">user4</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> pfcount login<span class="token punctuation">.</span><span class="token function">2019_06_17</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是HyperLogLog的统计结果并不是一个精确的值，误差在0.81%左右，但是对于统计用户数这种场景来说足够了</p></blockquote><h3 id="4-3-Geo"><a href="#4-3-Geo" class="headerlink" title="4.3 Geo"></a>4.3 Geo</h3><p>这个功能可以将 <strong>用户给定的地理位置（经度和纬度）信息</strong> 储存起来，并对这些信息进行操作。</p><p><strong>使用场景</strong></p><ol><li>附近的人</li></ol><p><a href="https://zhuanlan.zhihu.com/p/92538808">Redis 到底是怎么实现“附近的人”这个功能的呢？</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis单线程模型 </tag>
            
            <tag> Redis数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络灵魂拷问系列之基础问答</title>
      <link href="/posts/interview-net-base.html"/>
      <url>/posts/interview-net-base.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络灵魂拷问系列之基础问答"><a href="#计算机网络灵魂拷问系列之基础问答" class="headerlink" title="计算机网络灵魂拷问系列之基础问答"></a>计算机网络灵魂拷问系列之基础问答</h1><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/94sx4QID">有道云笔记-网络</a></p></blockquote><h2 id="1-浏览器请求www-baidu-com的全过程大概是怎么样的？"><a href="#1-浏览器请求www-baidu-com的全过程大概是怎么样的？" class="headerlink" title="1. 浏览器请求www.baidu.com的全过程大概是怎么样的？"></a>1. 浏览器请求<a href="http://www.baidu.com的全过程大概是怎么样的？">www.baidu.com的全过程大概是怎么样的？</a></h2><h3 id="1-1-DNS解析"><a href="#1-1-DNS解析" class="headerlink" title="1.1 DNS解析"></a>1.1 DNS解析</h3><p>根据输入的域名去当前设置的DNS服务器中查询该域名对应的ip地址</p><h3 id="1-2-封装报文"><a href="#1-2-封装报文" class="headerlink" title="1.2 封装报文"></a>1.2 封装报文</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-DataPackage.png" alt=""></p><p>根据计算机网络的四层/七层模型，从上往下依次进行操作：</p><ol><li><strong>应用层</strong>：根据 <strong>HTTP协议</strong> 封装数据包，其中包括请求类型、请求地址、请求头、请求内容、HTTP版本等信息</li><li><strong>表示层/会话层</strong>：数据加密，通过三次握手建立连接等</li><li><strong>传输层</strong>：根据 <strong>TCP协议</strong> 把应用层封装的数据包再封装一层tcp协议的相关信息，设置 <strong>发送者/接收者的端口号</strong> 等信息</li><li><strong>网络层</strong>：根据 <strong>IP协议</strong> 把网络层封装的数据包再封装一层ip协议的相关信息，设置 <strong>发送者/接收者的ip地址</strong> 等信息</li><li><strong>数据链路层/物理层等</strong>：根据 <strong>以太网协议</strong> 把网络层封装的数据包再封装一层ip协议的相关信息，设置发送者/接收者的mac地址等信息（因为通过ip地址和子网掩码与操作后192.168.1这样的二进制信息不一致，所以接收者的mac地址设置的是 <strong>网关/路由器的mac地址</strong> ，通过 <strong>广播</strong> 的方式层层网关下发送到目标服务器）</li><li><strong>服务器</strong> 接收到多个数据包，根据数据包的序号排列再拼接成一个完整的数据包，对数据包依次进行处理解析出具体请求，转发请求给对应的应用（例如tomcat）上进行处理。<strong>应用</strong> 处理后返回响应数据包，按照原链路返回给请求浏览器，<strong>浏览器</strong> 解析渲染结果到页面上，再通过<strong>四次挥手断开连接</strong></li></ol><blockquote><p>以太网默认数据包大小限制是 <strong>1500字节</strong>，如果ip数据包为5000字节，则会分为4个数据包发送（1500，1500，1500，500）</p></blockquote><h2 id="2-画一下TCP三次握手-四次挥手流程图？什么是三次握手不是两次呢？"><a href="#2-画一下TCP三次握手-四次挥手流程图？什么是三次握手不是两次呢？" class="headerlink" title="2. 画一下TCP三次握手/四次挥手流程图？什么是三次握手不是两次呢？"></a>2. 画一下TCP三次握手/四次挥手流程图？什么是三次握手不是两次呢？</h2><h3 id="2-1-三次握手-建立连接流程"><a href="#2-1-三次握手-建立连接流程" class="headerlink" title="2.1 三次握手-建立连接流程"></a>2.1 三次握手-建立连接流程</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-3Hands.png" alt=""></p><ol><li><strong>握手1</strong>：客户端发送建立连接报文，表示想与服务端建立起连接，自身进入发送状态</li><li><strong>握手2</strong>：服务端返回确认报文，表示收到客户端握手1的请求报文了，并且成功开辟好资源等待连接，自身进入接收状态</li><li><strong>握手3</strong>：客户端返回确认报文，表示收到服务端握手2的确认报文了，同时为了防止自己握手1时可能 <strong>多次发送握手1</strong> 的情况发生 <strong>会告诉服务端把其他连接的资源释放免得浪费</strong></li></ol><p>通过 <strong>传输层的tcp协议</strong> 建立网络连接的时候，其实就是走的三次握手的过程</p><p>通过根据约好的协议在 <strong>数据包请求头里设kv</strong> 来建立连接</p><p>三次握手的意义是为了 <strong>验证客户/服务端双方是否有收发数据的能力</strong> </p><p>首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。</p><p>于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。</p><p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。</p><h3 id="2-2-为什么是三次握手而不是两次呢"><a href="#2-2-为什么是三次握手而不是两次呢" class="headerlink" title="2.2 为什么是三次握手而不是两次呢"></a>2.2 为什么是三次握手而不是两次呢</h3><p>如果是 <strong>两次握手</strong> 的话，有一种情况会出现问题：</p><ol><li>客户端 <strong>第一次发起握手1</strong> ，可能由于网络抖动或者系统资源等原因 <strong>卡在半路上</strong></li><li>客户端尝试 <strong>第二次发起握手1</strong> ，这次发起成功，服务端发起第二次握手的同时会开辟资源，等待客户端发送数据。因为只有两次握手，所以这里代表此次建立连接成功</li><li>但是客户端 <strong>第一次发起的握手1</strong> 阻塞结束成功发送到了服务端，那么服务端也会继续发起握手2、开辟资源，而客户端因为 <strong>没有握手3来复位连接让服务端撤回开辟的资源</strong> ，导致服务端资源被浪费</li></ol><blockquote><p>第三次握手作用：在发送了多次握手1时，会复位连接，保证服务端的资源不被浪费</p></blockquote><h3 id="2-3-四次挥手-断开连接流程"><a href="#2-3-四次挥手-断开连接流程" class="headerlink" title="2.3 四次挥手-断开连接流程"></a>2.3 四次挥手-断开连接流程</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-4Hands.png" alt=""></p><ol><li><strong>挥手1</strong>：客户端发送断开连接的报文，表示要关闭双方之间的连接，自身进入等待关闭连接的状态1</li><li><strong>挥手2</strong>：服务端收到报文，进入等待关闭连接的状态，返回确认报文，这时客户端到服务端的连接就释放了，客户端收到报文时进入等待关闭状态2</li><li><strong>挥手3</strong>：服务端发送连接释放报文，表示释放服务端到客户端的连接，自身进入连接关闭的最后确认状态</li><li><strong>挥手4</strong>：客户端收到报文后发送应答报文，进入等待释放连接的状态，过一段时间进入连接关闭状态，</li></ol><p>第一步：客户端C和服务端S说：我要断开和你的连接（C -&gt; S）<br>第二步：服务端收到后返回表示同意，那么C -&gt; S这条线就可以断开了<br>第三步：服务端和客户端说：我也要断开和你的连接（S -&gt; C）<br>第四步：客户端收到后返回表示同意，那么等服务端这边东西全部给客户端传完之后，那么S -&gt; C这条线也就断开了</p><h2 id="3-HTTP的工作原理是什么"><a href="#3-HTTP的工作原理是什么" class="headerlink" title="3. HTTP的工作原理是什么"></a>3. HTTP的工作原理是什么</h2><p>HTTP有1.0、1.1、2.0版本，底层都是在以太网协议、TCP协议、IP协议之上封装的HTTP协议，各个版本请求报文会有些许不同，但是基本相通的就有请求头、请求体、请求方法、响应状态码等</p><ol><li><strong>HTTP1.0</strong>：在2000年之前，早期的网页只有文字，使用的是 <strong>TCP短连接</strong> ，浏览器通过三次握手建立连接与服务器进行通信，接收到响应渲染到出来后，就会四次挥手断开连接（双方之间的连接不会太频繁）</li><li><strong>HTTP1.1</strong>：在之后的互联网迅猛发展的时期，往往网页都要加载很多图片、脚本等信息（CSS、JS），如果还是像HTTP1.0一样一次请求开辟断开一次连接则非常耗费资源和时间。所以HTTP1.1版本默认支持了 <strong>TCP长连接</strong> 。当浏览器通过三次握手和服务器建立连接之后不会马上关闭连接，来支持浏览器多次的请求，等待请求完毕再释放连接。</li><li><strong>HTTP2.0</strong>：HTTP1.1对同一时间同一域名的请求有限制，所以HTTP2.0支持 <strong>多路复用</strong>，基于一个tcp连接发送多个请求以及接收响应，来实现低延迟高吞吐</li></ol><h2 id="4-HTTP里的长连接是什么"><a href="#4-HTTP里的长连接是什么" class="headerlink" title="4. HTTP里的长连接是什么"></a>4. HTTP里的长连接是什么</h2><p>HTTP本身没有长连接短连接之说，本质上是TCP的长连接和短连接，在HTTP1.0时，协议底层的TCP协议默认走的是短连接，HTTP1.1底层的TCP协议默认走的是长连接</p><ol><li><strong>短连接</strong>：每次请求响应后都会断开连接、释放资源</li><li><strong>长连接</strong>：可以看成一个网页一个长连接，这个网页的多个请求都通过一个TCP连接来收到响应、获取资源，很长时间后，没有进行通信这个链接才被释放</li></ol><p>长连接一般应用于聊天工具等这样的特殊场景</p><h2 id="5-HTTPS的工作原理是什么"><a href="#5-HTTPS的工作原理是什么" class="headerlink" title="5. HTTPS的工作原理是什么"></a>5. HTTPS的工作原理是什么</h2><p>HTTP协议是 <strong>明文传输</strong> 的，<strong>中间商就可以拦截下来插入自己的广告或者篡改信息</strong>，来达到盈利的目的，这显然是不安全的</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-https-process.png" alt=""></p><ol><li>浏览器把自己支持的加密算法发送给网站</li><li>网站从中选择一套加密算法和hash算法，然后发送 <strong>证书</strong> 给浏览器（证书里含有网站地址、加密公钥、证书颁发机构）</li><li>浏览器校验证书合法性，如果合法一般浏览器地址栏旁边会出现一把绿色的锁。接着，浏览器会生成随机数密码P1，使用证书里的 <strong>公钥</strong> 对P1加密（<strong>非对称加密</strong>）保证P1的安全性；又对整个消息进行 <strong>hash算法</strong> 算出hash值H1；再使用P1对消息进行 <strong>对称加密</strong>，发送消息给网站</li><li>网站收到数据后，先使用 <strong>私钥</strong> 对消息解密取出密码P1，再对消息进行对称解密（使用P1），对消息进行hash，比对浏览器发送的hash值H1和自己计算的hash值，一致则说明未被篡改。成功建立连接</li><li>之后两者就使用密码P1进行hash加密、使用P1对消息进行对称加密的方式来通信</li></ol><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-httpsLock.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络灵魂拷问系列之计算机网络模型</title>
      <link href="/posts/interview-net-model.html"/>
      <url>/posts/interview-net-model.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络灵魂拷问系列之计算机网络模型"><a href="#计算机网络灵魂拷问系列之计算机网络模型" class="headerlink" title="计算机网络灵魂拷问系列之计算机网络模型"></a>计算机网络灵魂拷问系列之计算机网络模型</h1><h2 id="0-网络通信协议的意义"><a href="#0-网络通信协议的意义" class="headerlink" title="0.网络通信协议的意义"></a>0.网络通信协议的意义</h2><p>各个电脑厂商，比如联想、苹果、华硕之类的，每个品牌的电脑之间的通信，如果通信协议不同，那么就只能品牌电脑内通信，这是不可取的。所以搞了一个国际通行的协议，大家都按照协议来，使得所有电脑都可以互相通信</p><p>OSI七层网络模型：<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-cn-osi.png" alt=""></p><ol><li><strong>物理层</strong>：以前电脑都是通过网线来联网，传输0和1的信号。属于物理上的连接</li><li><strong>数据链路层</strong>：电脑接收到0101010001这样的电路信号怎么识别和分组，从哪个电脑传输到哪个电脑。数据链路层来解决。以太网协议就是这一层来的，以太网规定每个电脑都有一个网卡，电路信号一般从电脑1网卡传输到电脑2网卡。电脑出厂时都有一个唯一的mac地址（12个16进制，前6产商编号，后6流水号，win10中ipconfig /all可查询mac物理地址）。一组电信号就是一帧，每帧分为标头和数据，标头包含了一些发送者、接收者和数据类型之类的信息。发送者会把数据通过广播发送给所有局域网里的电脑，每个电脑网卡通过比对接收者mac地址来判断是否是发送给自己</li><li><strong>网络层</strong>：数据链路层发送方通过广播发送给局域网内所有的电脑，那么他是如何判别哪些电脑是处于同一个局域网内的呢？通过网络层判别。ip协议，一般通过4个十进制数字表示，范围从0.0.0.0到255.255.255.255。每台计算机都分配一个ip地址，各自对子网掩码（一般是255.255.255.0）做二进制与运算，得到前三段（192.168.1）一致则为同一局域网。跨局域网通信：请求头填写接收方ip和路由器mac地址，经过交换机发送给路由器/网关，路由器/网关转换成目标mac地址，而后正确发送给对方电脑。ARP：局域网内个台电脑都把自己的ip地址和对应的mac地址广播给其他电脑，最后每台电脑都会知道其他电脑的地址了。【关键】网络层最关键的就是提供了ip协议，电脑A和电脑B通信，如果两者在一个局域网，则只需要在请求头填写接收方mac地址即可通信；如果不在，在请求头填写接收方ip地址和路由器的mac地址进行通信</li><li><strong>传输层</strong>：电脑上很多应用都从网卡发送和接收数据，该如何辨别是给哪个应用的呢？传输层引入了端口的概念，例如qq监听20386端口，数据包解析到发送到20386端口，就说明是给qq的。关联端口号的就是tcp协议和udp协议（udp不可靠，只管发送数据不管对方是否接收），规定了端对端的规则，例如怎么建立连接、怎么发送和读取数据。socket基于tcp协议封装，我们可以基于socket进行网络编程（ip地址+端口号）</li><li><strong>应用层</strong>：当收到基于tcp协议发送过来的数据包后，如何将数据包进行对应解析？数据包可能用于发送邮件（STMP协议）、发送HTTP请求，用了什么格式进行封装</li></ol><blockquote><p>例如我们使用java中的nio来搭建rpc通信框架，底层过程还是走了：传输层的tcp协议、网络层的ip协议、数据链路层的以太网协议和物理层的网线传递着0101的信号 </p></blockquote><p>TCP/IP四层模型常用协议：<br>数据链路层（以太网协议）、网络层（ip协议）、传输层（tcp协议）、应用层（HTTP协议）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL灵魂拷问系列之MySQL如何优化</title>
      <link href="/posts/interview-MySQL-optimization.html"/>
      <url>/posts/interview-MySQL-optimization.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问系列之MySQL如何优化"><a href="#MySQL灵魂拷问系列之MySQL如何优化" class="headerlink" title="MySQL灵魂拷问系列之MySQL如何优化"></a>MySQL灵魂拷问系列之MySQL如何优化</h1><h2 id="1-SQL语句日常优化"><a href="#1-SQL语句日常优化" class="headerlink" title="1. SQL语句日常优化"></a>1. SQL语句日常优化</h2><ol><li>通过skywalking发现慢sql、或者mysql中的慢查询日志（开启慢查询日志）</li><li>使用 <strong>explain</strong> 关键字查看sql执行计划</li><li>type一般控制在 <strong>ref</strong> 甚至更好的话，sql性能应该都不错</li><li><strong>key_len</strong>：表示索引的长度，越小越好</li><li><strong>rows</strong>：扫描行数，很重要，最少越好</li><li><strong>extra</strong>：当查询包含 <strong>using filesort</strong> 文件排序和 <strong>using temporary</strong>临时表（使用order/group by很容易出现），这样的sql必须优化</li></ol><h2 id="2-表结构优化"><a href="#2-表结构优化" class="headerlink" title="2. 表结构优化"></a>2. 表结构优化</h2><p><strong>在遵循三大范式的基础上，可以为了业务增加一定的冗余字段</strong></p><blockquote><p>个人笔记：<a href="http://note.youdao.com/s/LoTjHgzV">表结构设计优化</a></p></blockquote><h2 id="2-join优化"><a href="#2-join优化" class="headerlink" title="2. join优化"></a>2. join优化</h2><p><strong>（1）灵活使用左连接、右连接等</strong></p><ul><li><strong>left join</strong>：A表的全部数据，即使B表不包含A表的关系数据</li><li><strong>right join</strong>：B表的全部数据，即使B表不包含A表的关系数据</li><li><strong>inner join</strong>：A表和B表的交集</li><li><strong>full outer join</strong>：A表和B表并集</li><li><strong>cross join</strong>：笛卡尔连接，把A表的数据和B表的数据任意连接，结果行数 = A表行数 *B表行数；如果cross join带有on语句把两表的外键相连，则作用等于inner join</li></ul><p><strong>（2）使用join时，用数据量比较小的作为驱动表，用小表驱动大表，where条件尽量走索引，参与join的表不能超过3张</strong></p><blockquote><p>个人join优化笔记：<a href="http://note.youdao.com/s/CqwXTRyN">join优化</a></p></blockquote><h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><ol><li>遵循 <strong>最左前缀原则</strong></li><li>编写sql时避免 <strong>隐式转换</strong></li><li>必要时建议使用 <strong>组合索引、覆盖索引</strong></li></ol><blockquote><p>【个人索引优化笔记】<br>1：<a href="http://note.youdao.com/s/CVUXjziS">常见索引失效场景与解决方案</a><br>2：<a href="http://note.youdao.com/s/PBoh23ho">索引优化</a></p></blockquote><h2 id="4-limit优化"><a href="#4-limit优化" class="headerlink" title="4. limit优化"></a>4. limit优化</h2><ol><li>使用 <strong>覆盖索引 + join</strong>优化offset特别大的场景</li><li>模仿淘宝或者百度，对页面做限制（100页）</li></ol><blockquote><p>个人limit优化笔记：<a href="http://note.youdao.com/s/Fh5SAlZ1">limit优化</a></p></blockquote><h2 id="5-个人小结笔记"><a href="#5-个人小结笔记" class="headerlink" title="5. 个人小结笔记"></a>5. 个人小结笔记</h2><p>（1）表结构设计方面：首先需要遵循三大范式，字段不能再分割，非主键属性 <a href="https://zhuanlan.zhihu.com/p/259788257">https://zhuanlan.zhihu.com/p/259788257</a><br>a.字段不能再分割，比如只有一个地址字段，到时候如果按照省统计时就会非常头疼<br>b.每行记录要有唯一标识。比如学号、姓名、课程、课程分数，这一条记录就包含了学生、课程信息，主键无法保证唯一性，两个应该分开<br>c.不能存在冗余。比如学号、姓名、学院、学院电话。这里学院电话每行都有，肯定会存在冗余的情况。应该分开<br>d.适当加一些冗余字段，比如订单表记录商品金额，为的是保存当时商品信息快照，因为不同时期的商品价格可能发生变化</p><p>（2）表字段设计方面：字段尽量不允许为null，字段选择最适合的，比如性别、订单状态这样的字段可以使用tinyint，使用varchar可变的<br>字符串代替char等</p><p>（3）sql优化：通过skywalking或者mysql慢查询日志查询慢sql，通过explain关键字查询他的执行计划，保证type控制在ref，rows扫描行数<br>越少越好，extra列不出现临时表和文件排序；<br>a.join优化：遵循数据量小的表来驱动大表，where的条件尽量走索引，参与join的表最好不超过3张<br>b.索引优化：遵循最左前缀原则，避免隐式转换，否则可能造成索引失效。建议使用复合索引<br>c.limit优化：如果进行深度分页的话，比如10000，10，mysql的具体操作是查找10010条数据，然后丢弃前10000条，取后10条，性能很低。<br>这种情况，如果主键的自增类型，则直接可以让id&gt;10000，limit 10即可。如果不是自增类型，就根据主键索引查询到分页信息的主键，再<br>根据主键查询数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL灵魂拷问之数据库事务说说吧</title>
      <link href="/posts/interview-MySQL-transaction.html"/>
      <url>/posts/interview-MySQL-transaction.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问之数据库事务说说吧"><a href="#MySQL灵魂拷问之数据库事务说说吧" class="headerlink" title="MySQL灵魂拷问之数据库事务说说吧"></a>MySQL灵魂拷问之数据库事务说说吧</h1><h2 id="1-事务的四大特性是什么-ACID"><a href="#1-事务的四大特性是什么-ACID" class="headerlink" title="1. 事务的四大特性是什么-ACID"></a>1. 事务的四大特性是什么-ACID</h2><ul><li><strong>原子性</strong>：一个事务作为一个整体，要么一起成功要么一起失败</li><li><strong>一致性</strong>：说的是数据一致性。事务执行前后，数据的执行是对的，不能存在某操作未执行的情况</li><li><strong>隔离性</strong>：各个事务之间互不干扰</li><li><strong>持久性</strong>：事务执行成功，对数据的操作是永久有效的</li></ul><h2 id="2-事务的隔离级别有哪些"><a href="#2-事务的隔离级别有哪些" class="headerlink" title="2. 事务的隔离级别有哪些"></a>2. 事务的隔离级别有哪些</h2><p>MySQL默认事务隔离级别：<strong>可重复读</strong></p><p>隔离级别依次是：读未提交、读已提交、可重复读、串行化，对应的性能从左到右依次递减</p><h3 id="2-1-事务隔离级别-读未提交"><a href="#2-1-事务隔离级别-读未提交" class="headerlink" title="2.1 事务隔离级别-读未提交"></a>2.1 事务隔离级别-读未提交</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-ReadUncommit.png" alt=""></p><p>读未提交：事务A可以查看到事务B修改的数据（事务B还未提交），也就是存在 <strong>脏读</strong> 的问题</p><h3 id="2-2-事务隔离级别-读已提交-不可重复读"><a href="#2-2-事务隔离级别-读已提交-不可重复读" class="headerlink" title="2.2 事务隔离级别-读已提交/不可重复读"></a>2.2 事务隔离级别-读已提交/不可重复读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-ReadCommitted.png" alt=""></p><p>存在 <strong>不可重复读</strong> 的问题</p><h3 id="2-3-事务隔离级别-可重复读"><a href="#2-3-事务隔离级别-可重复读" class="headerlink" title="2.3 事务隔离级别-可重复读"></a>2.3 事务隔离级别-可重复读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-RepeatableRead.png" alt=""></p><p>保证事务在运行期间，同一行数据是不会变更的</p><h3 id="2-4-可重复读的问题-幻读"><a href="#2-4-可重复读的问题-幻读" class="headerlink" title="2.4 可重复读的问题-幻读"></a>2.4 可重复读的问题-幻读</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-IllusoryRead.png" alt=""></p><h3 id="2-5-事务隔离级别-串行化"><a href="#2-5-事务隔离级别-串行化" class="headerlink" title="2.5 事务隔离级别-串行化"></a>2.5 事务隔离级别-串行化</h3><p>MySQL事务隔离级别-串行化可以解决幻读的问题</p><p>事务A执行期间，事务B不允许执行，只能阻塞等待事务A执行完毕接着执行事务B</p><h2 id="3-MySQL是如何实现可重复读的（MVVC机制）？"><a href="#3-MySQL是如何实现可重复读的（MVVC机制）？" class="headerlink" title="3. MySQL是如何实现可重复读的（MVVC机制）？"></a>3. MySQL是如何实现可重复读的（MVVC机制）？</h2><p>使用 <strong>MVVC机制</strong>，也就是 <strong>多版本并发控制</strong>（Multi-Version Concurrency Control） 实现的可重复读</p><p>innodb对每一行都会追加两个隐藏列：<strong>创建这一行的事务id</strong>、<strong>删除这一行的事务id</strong>（事务id在MySQL中是 <strong>全局唯一并且递增</strong> 的）</p><p>核心规则： <strong>创建事务id &lt;= 当前事务id &lt; 删除事务id</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-mvvc-demo-one.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-mvvc-demo-two.png" alt=""></p><blockquote><p>并发场景下，多个事务对同一行进行修改，同一行就会存在多个版本<br>各个事务会对于这一行有一条创建事务id为自己id的快照</p></blockquote><blockquote><p>【参考链接】<br>1： <a href="https://mp.weixin.qq.com/s/XOBhxc_AiuUxvwBsB_JprQ">一文彻底读懂 MySQL 事务的四大隔离级别</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL灵魂拷问系列之MySQL基础拷问</title>
      <link href="/posts/interview-MySQL-common.html"/>
      <url>/posts/interview-MySQL-common.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL灵魂拷问系列之MySQL基础拷问"><a href="#MySQL灵魂拷问系列之MySQL基础拷问" class="headerlink" title="MySQL灵魂拷问系列之MySQL基础拷问"></a>MySQL灵魂拷问系列之MySQL基础拷问</h1><h2 id="1-MySQL有哪些存储引擎，有什么区别"><a href="#1-MySQL有哪些存储引擎，有什么区别" class="headerlink" title="1.MySQL有哪些存储引擎，有什么区别"></a>1.MySQL有哪些存储引擎，有什么区别</h2><p>mysql我们耳熟能详的就是两种存储引擎：<strong>Innodb、Myisam</strong></p><h3 id="1-1-Myisam"><a href="#1-1-Myisam" class="headerlink" title="1.1 Myisam"></a>1.1 Myisam</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-myisam.png" alt=""></p><ol><li><strong>不支持事务、外键</strong></li><li>从 <strong>物理存储角度</strong> 上看，Myisam属于 <strong>非聚簇索引</strong>，数据存在叶子结点（没有孩子的节点）上，叶子节点的data为数据的物理地址引用（索引文件和数据文件分开存储），，通过物理地址引用来找到具体的数据行。</li><li>适用于 <strong>少量插入、大量查询</strong> 的场景，以前做 <strong>大数据报表系统</strong> 的时候会用到，一次性大批量插入，接下来只是纯查询.不过现在基本已经不用myisam了（mysql扛不住，单表一般控制在500w）</li></ol><h3 id="1-2-Innodb"><a href="#1-2-Innodb" class="headerlink" title="1.2 Innodb"></a>1.2 Innodb</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-innodb.png" alt=""></p><ol><li>支持事务、外键</li><li>从 <strong>物理存储角度</strong> 上看，Innodb属于 <strong>聚簇索引</strong>，数据存在叶子结点（没有孩子的节点）上。如果是二级索引，则叶子结点存储的是主键，如果不止查询索引列，则需要再根据主键回表查询一次</li><li>目前来说，适用于大多数业务场景，无脑选即可</li></ol><blockquote><p>二级索引查找流程：先到二级索引的B+ Tree中根据name找到具体的叶子节点的data，data中存储的主键，根据主键再到聚簇索引（主键索引）中找到具体的数据行</p></blockquote><h3 id="1-3-Myisam和Innodb汇总比对图"><a href="#1-3-Myisam和Innodb汇总比对图" class="headerlink" title="1.3 Myisam和Innodb汇总比对图"></a>1.3 Myisam和Innodb汇总比对图</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-InnodbAndMyisam.png" alt=""></p><blockquote><p>Innodb二级索引叶子结点存储的是 <strong>索引和主键</strong>，需要查询到主键后，去主键索引查询数据</p></blockquote><h2 id="2-为什么MySQL的索引要使用B-树而不是其它树形结构-比如B树？"><a href="#2-为什么MySQL的索引要使用B-树而不是其它树形结构-比如B树？" class="headerlink" title="2.为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？"></a>2.为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？</h2><blockquote><p>具体细节参考：<br><a href="https://mp.weixin.qq.com/s/IZqjGK58mRUN4YFXO_QyHw">面试官：为什么MySQL的索引要使用B+树，而不是其它树？比如B树？</a></p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysq-b-tree.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-mysql-baddtree.png" alt=""></p><p>都属于多路搜索树</p><p>因为B树不管叶子节点还是非叶子节点，都会保存数据，如果要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低</p><p>而B+树只有在叶子节点存储数据，非叶子节点只保存索引值</p><p>数据库对B+ Tree还进行了优化，让每个叶子节点末尾有一个 <strong>next指针</strong> 指向下一个叶子节点的数据，使得在做范围查询的时候效率更高</p><h2 id="3-MySQL索引的使用规则"><a href="#3-MySQL索引的使用规则" class="headerlink" title="3.MySQL索引的使用规则"></a>3.MySQL索引的使用规则</h2><p>最左前缀匹配原则</p><p>假设表中只有A,B,C这三列的联合索引（A，B，C）</p><ol><li>全列匹配</li></ol><blockquote><p>select * from table where A = 1 and B = 2 and C = 3<br>说明：完美地走这个联合索引</p></blockquote><ol start="2"><li>最左前缀匹配</li></ol><blockquote><p>select * from table where A = 1 and B = 2<br>说明：走联合索引</p></blockquote><ol start="3"><li>最左匹配了，中间的值未匹配</li></ol><blockquote><p>select * from table where A = 1 and C = 3<br>说明：A走索引，C不走索引，会当作过滤条件，因为也走索引，所以在性能上也是可以接受的</p></blockquote><ol start="4"><li>未匹配最左匹配原则</li></ol><blockquote><p>select * from table where C = 3<br>说明：全表扫描，性能低，需要优化</p></blockquote><ol start="5"><li>前缀匹配</li></ol><blockquote><p>select * from table where A = 1 and B like “2%”<br>说明：like关键字 左边不能加 <strong>%</strong></p></blockquote><ol start="6"><li>范围/函数查询</li></ol><blockquote><p>select * from table where A &gt;= 0 and B = 2 and 函数（C） = 3<br>说明：A走索引，B不走索引，B作为筛选条件，C不走索引</p></blockquote><p><strong>索引的注意事项</strong></p><blockquote><p><a href="http://note.youdao.com/s/ZZP28HXU">理想设置索引和伪哈希技巧</a></p></blockquote><ol><li>单表索引数量不宜过多</li><li>类似于status、isValid这样的经常性重复的字段，创建索引意义不大</li><li>类似于网站这样前缀大致相同的字段，可以新建一个字段使用 <strong>crc32</strong> 函数对相同部分做hash，再对新字段创建索引</li></ol><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/ZxE8XDKUa8szJ6wRc-w-rA">InnoDB和MyISAM两者的对比</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上出现问题了你有思路解决吗</title>
      <link href="/posts/interview-daily-prodProblem.html"/>
      <url>/posts/interview-daily-prodProblem.html</url>
      
        <content type="html"><![CDATA[<h1 id="线上出现问题了你有思路解决吗"><a href="#线上出现问题了你有思路解决吗" class="headerlink" title="线上出现问题了你有思路解决吗"></a>线上出现问题了你有思路解决吗</h1><h2 id="1-线上服务器CPU使用率达到100-，如何排查、定位与解决呢"><a href="#1-线上服务器CPU使用率达到100-，如何排查、定位与解决呢" class="headerlink" title="1. 线上服务器CPU使用率达到100%，如何排查、定位与解决呢"></a>1. 线上服务器CPU使用率达到100%，如何排查、定位与解决呢</h2><p>面试官通过这个问题来试探面试者，有没有真实的玩过线上的机器</p><p><strong>导致CPU过高的一般原因</strong></p><ol><li>无线循环，例如递归调用等（可以整个sleep）</li><li>频繁GC（内存分配过快，导致区域很快就满了）</li><li>频繁创建新对象（可以考虑使用单例）</li><li>错误姿势的使用序列化和反序列化类库</li><li>正则表达式</li><li>线程上下文频繁切换</li></ol><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>top</strong> 到CPU占用最高的进程A <strong>pid1</strong></li><li>再使用 <strong>top -Hp</strong> 拿到指定进程占用最高的线程 <strong>pid2</strong></li><li>使用 <strong>printf %x pid2</strong> 将10进制线程号转换成16进制 <strong>8ccc</strong></li><li>通过 <strong>jstack pid1 &gt; dump.txt</strong> 获取进程A的堆栈快照</li><li>使用 <strong>cat dump.txt | grep -A 30 8ccc</strong> 根据16进制信息筛查出有问题的代码（往下展示30行）</li><li>排查代码中的问题并修复</li></ol><h2 id="2-线上机器的一个进程使用kill命令无法杀死怎么办？"><a href="#2-线上机器的一个进程使用kill命令无法杀死怎么办？" class="headerlink" title="2. 线上机器的一个进程使用kill命令无法杀死怎么办？"></a>2. 线上机器的一个进程使用kill命令无法杀死怎么办？</h2><p>kill进程如果死活杀不死，那么这个进程会进入 <strong>zombie（僵尸）</strong> 状态，也就是一个僵尸进程，这是因为 <strong>子进程释放了资源，但是没有经过父进程的确认</strong></p><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>ps aux</strong> 查看 <strong>stat</strong> ，如果对应这一栏值是 <strong>Z</strong> ,那么说明是僵尸进程</li><li>使用 <strong>ps -ef | grep 僵尸进程id</strong> 可以找到 <strong>父进程id</strong></li><li>使用 <strong>kill</strong> 杀死父进程即可</li></ol><h2 id="3-磁盘空间快满了，不影响服务的情况下如何解决？"><a href="#3-磁盘空间快满了，不影响服务的情况下如何解决？" class="headerlink" title="3. 磁盘空间快满了，不影响服务的情况下如何解决？"></a>3. 磁盘空间快满了，不影响服务的情况下如何解决？</h2><p><strong>解决方法思路</strong></p><ol><li>使用Linux命令 <strong>df -h</strong> 查看磁盘使用率情况</li><li>可以通过删除一些年份比较久的日志文件来释放空间。（一般可以通过 <strong>crontab定时任务</strong> 来每天定时清理一些日志文件，保证空间富余）</li><li>如果不是日志文件导致，就通过 <strong>find \ -size +100M | xargs ls -lh</strong> （查询根目录下所有大于100M的文件）</li><li>如果没找到大文件，可以查询占据磁盘空间大的目录，看看各个目录里是否有大量的小文件， <strong>du -h &gt; fs_du.log</strong></li></ol><h2 id="4-线上发生-java-lang-OutOfMemoryError-Java-heap-space-堆内存溢出怎么办？"><a href="#4-线上发生-java-lang-OutOfMemoryError-Java-heap-space-堆内存溢出怎么办？" class="headerlink" title="4. 线上发生 java.lang.OutOfMemoryError Java heap space 堆内存溢出怎么办？"></a>4. 线上发生 java.lang.OutOfMemoryError Java heap space 堆内存溢出怎么办？</h2><p><strong>堆内存溢出的原因及解决思路</strong></p><ol><li><strong>内存泄漏</strong>：找到堆栈引用链，查出哪个对象没有被回收导致内存泄漏（找到泄漏对象的创建位置）</li><li><strong>非内存泄漏</strong>：考虑调大JVM参数的xms xmx最大\小堆内存，为应用分配更多的堆内存；检查代码，排除有些对象生命周期是否太长了，又或者存储结构不合理（有时换个方式存储对象可以节省很多内存）</li></ol><p><strong>现实可能发生堆内存溢出的场景</strong></p><ol><li>数据库过多数据返回给服务端，导致内存溢出：</li><li>根据某个分类搜索商品列表（分页），如果这个分类的商品特别多，并且pageSize没有设置限制，被恶意攻击时，会一下子就把内存打崩</li><li>…</li></ol><p><strong>举个🌰说明</strong></p><pre class="line-numbers language-java"><code class="language-java">\<span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">*</span> 使用该选项运行：<span class="token operator">-</span>Xms20m <span class="token operator">-</span>Xmx20m <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>HeapDumpOnOutOfMemoryError      使用最小\最大堆内存都为20m 并且在堆内存溢出时做一次堆dump <span class="token operator">*</span>\<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOMTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> oomList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HeapOOMTest oomTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeapOOMTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            oomTest<span class="token punctuation">.</span>oomList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照配置运行代码，会发生堆内存溢出。</p><p>在实际项目中，堆内存溢出可能会导致进程崩溃，极端场景下进程可能直接就挂掉了，不会打印日志</p><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5COutOfMemoryError-JavaHeapSpace.png" alt=""></p><p><strong>项目根目录中，会生成dump文件，例如 java_pid15468.hprof</strong></p><p><strong>分析dump文件</strong></p><ol><li>MAT</li><li>VisualVM</li><li>PerfMa</li></ol><p>具体操作查看本人在有道云做的笔记</p><p><a href="http:\note.youdao.com\s\Jbdk16jn">实战：堆内存溢出【java.lang.OutOfMemoryError Java heap space】</a></p><p>也可以查看以下文章</p><p><a href="https:\club.perfma.com\article\670585">实战：OOM 后我如何分析解决的 | PerfMa应用性能技术社区</a></p><blockquote><p><strong>栈内存溢出</strong>：可能由 <strong>递归创建过多栈帧</strong> 导致栈内存溢出<br><strong>方法区内存溢出</strong>：可能由 <strong>常量占据内存过多</strong> 导致元空间内存不足</p></blockquote><h2 id="5-如果一个项目越跑越慢，你觉得可能是因为什么？"><a href="#5-如果一个项目越跑越慢，你觉得可能是因为什么？" class="headerlink" title="5. 如果一个项目越跑越慢，你觉得可能是因为什么？"></a>5. 如果一个项目越跑越慢，你觉得可能是因为什么？</h2><ol><li>垃圾收集非常频繁，stop the world时间越来越长，导致项目执行越来越慢</li><li>数据库数据量变大（慢SQL优化或者分库分表来解决）</li><li>Code Cache默认的240M代码缓存区满了。未满时，代码以编译的方式执行，如果满了，代码会以解释的方式执行，执行速度上比编译执行慢了一个数量级，严重影响项目性能</li><li>线程争抢过于激烈，导致代码争抢不到CPU时间片去执行任务</li><li>操作系统问题则重启大法好</li></ol><blockquote><p>代码缓存区相关知识点：<a href="http:\note.youdao.com\s\czDaSk5r">实战：代码缓存区域满</a></p></blockquote><p>可以通过 <strong>skywalking</strong> 来预防和辅助分析问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常工作应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线上问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM灵魂拷问系列之整点类加载机制吧</title>
      <link href="/posts/interview-jvm-classloader.html"/>
      <url>/posts/interview-jvm-classloader.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之问点类加载机制吧"><a href="#JVM灵魂拷问系列之问点类加载机制吧" class="headerlink" title="JVM灵魂拷问系列之问点类加载机制吧"></a>JVM灵魂拷问系列之问点类加载机制吧</h1><h2 id="1-你知道java文件是如何被运行的吗？"><a href="#1-你知道java文件是如何被运行的吗？" class="headerlink" title="1. 你知道java文件是如何被运行的吗？"></a>1. 你知道java文件是如何被运行的吗？</h2><ol><li>Java文件经过编译后变成 <strong>.class字节码文件</strong></li><li>字节码文件通过 <strong>类加载器</strong> 被搬运加载到 JVM 虚拟机中 </li></ol><h2 id="2-那你说说类加载器的流程吧，从类被加载到释放内存"><a href="#2-那你说说类加载器的流程吧，从类被加载到释放内存" class="headerlink" title="2. 那你说说类加载器的流程吧，从类被加载到释放内存"></a>2. 那你说说类加载器的流程吧，从类被加载到释放内存</h2><p>总共有七个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中 <strong>验证，准备，解析三个部分统称为连接</strong> </p><ol><li><strong>加载</strong>：将class文件加载进内存中</li><li><strong>连接</strong>：（1）验证，做一个安全检查，保证字节码符合JVM相关规则与规范；（2）准备：设置静态变量初始值等（3）解析：将常量池的引用替换为真实地址引用</li><li><strong>初始化</strong>：赋值的过程</li><li><strong>卸载</strong>：GC释放无用对象的内存</li></ol><h2 id="3-类加载器是怎么加载一个class的（双亲委派机制）？"><a href="#3-类加载器是怎么加载一个class的（双亲委派机制）？" class="headerlink" title="3. 类加载器是怎么加载一个class的（双亲委派机制）？"></a>3. 类加载器是怎么加载一个class的（双亲委派机制）？</h2><p><strong>双亲委派加载机制</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-classLoader-pic.png" alt=""></p><p>当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的。</p><ol><li>首先由最顶层的类加载器 <strong>Bootstrap ClassLoader</strong> 试图加载</li><li>如果没加载到，则把任务转交给 <strong>Extension ClassLoader</strong> 试图加载</li><li>如果也没加载到，则转交给 <strong>App ClassLoader</strong> 进行加载</li><li>如果它也没有加载得到的话，则返回给 <strong>委托的发起者</strong>，由它到指定的文件系统或网络等URL中加载该类。</li><li>如果它们都没有加载到这个类时，则抛出 <strong>ClassNotFoundException</strong> 异常。</li></ol><p><strong>那为什么要这么做呢？</strong></p><p>比如加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到 <strong>BootStrap ClassLoader</strong> 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>例子🌰：如果我们自己写了String类，其实是会报错的，因为在加载的过程中，会先找到 <strong>rt.jar</strong> 中的String.class。</p><blockquote><p>【参考链接】<br>1：<a href="https://mp.weixin.qq.com/s/Llps6z99cpPMN2ekeQljrA">Jar 包依赖冲突排查思路和解决方法</a><br>2：<a href="https://juejin.cn/post/6844904048013869064">大白话带你认识JVM</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM灵魂拷问系列之垃圾回收</title>
      <link href="/posts/interview-jvm-GarbageCollection.html"/>
      <url>/posts/interview-jvm-GarbageCollection.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之垃圾回收"><a href="#JVM灵魂拷问系列之垃圾回收" class="headerlink" title="JVM灵魂拷问系列之垃圾回收"></a>JVM灵魂拷问系列之垃圾回收</h1><h2 id="1-垃圾回收发生在哪些区域？"><a href="#1-垃圾回收发生在哪些区域？" class="headerlink" title="1. 垃圾回收发生在哪些区域？"></a>1. 垃圾回收发生在哪些区域？</h2><p>JVM内存模型中， <strong>线程共享区域</strong> 会发生垃圾回收，也就是 <strong>堆内存</strong> 和 <strong>方法区</strong></p><p>线程独占区域的内存，会随着线程的消亡而销毁，不需要垃圾回收</p><h2 id="2-说说JVM在哪些情况下会进行垃圾回收？"><a href="#2-说说JVM在哪些情况下会进行垃圾回收？" class="headerlink" title="2. 说说JVM在哪些情况下会进行垃圾回收？"></a>2. 说说JVM在哪些情况下会进行垃圾回收？</h2><p>Eden区域/永久代内存满了会进行垃圾回收</p><p>一般有通过两种方式来判断：<strong>引用计数法</strong> 和 <strong>可达性分析</strong></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>通过对象的引用计数器来判断该对象是否被引用，被其他地方引用一次+1，反之-1，值为0表示没有引用可回收</p><p><strong>缺点</strong>：循环引用的情况无法解决，所以Java没用使用引用计数法</p><h3 id="2-2-可达性分析"><a href="#2-2-可达性分析" class="headerlink" title="2.2 可达性分析"></a>2.2 可达性分析</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-AccessibilityAnalysis.png" alt=""></p><p>以根对象为起点向下搜索，走过的路径为引用链，<strong>如果对象到根对象没用引用链相连</strong>，则认定这个对象不可达，是可以回收，如图Object5和Object7是可回收的 </p><p><strong>哪些对象可以作为根对象</strong></p><ol><li>虚拟机栈（栈帧中的本地变量表）引用的对象</li><li>方法区类静态属性引用的对象</li><li>方法区常量引用的对象</li><li>本地方法栈中JNI（即Native方法）引用的对象</li></ol><h2 id="3-说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？"><a href="#3-说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？" class="headerlink" title="3. 说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？"></a>3. 说说强引用、软引用、弱引用和虚引用，在垃圾回收时会发生什么？</h2><ol><li>强引用：平时使用的引用，Object o = new Object();，只要强引用在对象就不会被回收.<strong>哪怕出现内存溢出也不回收</strong></li><li>软引用：SoftReference<string> sf = new SoftReference&lt;&gt;(“hello”);一般是描述一些有用但非必需的对象。<strong>内存不足才回收</strong><br>软引用比较适合用来实现缓存，比如网页缓存图片缓存等等</string></li><li>弱引用：WeakReference<string> sf = new WeakReference&lt;&gt;(“hello”);一般是描述一些有用但非必需的对象。<strong>不管内存是否不足都会被回收</strong></string></li><li>虚引用：任何时候都可能被回收，主要用来跟踪被回收的活动，一般跟引用引用队列配合使用</li></ol><h2 id="4-说说JVM的垃圾回收算法？对象什么时候转移到老年代？"><a href="#4-说说JVM的垃圾回收算法？对象什么时候转移到老年代？" class="headerlink" title="4.说说JVM的垃圾回收算法？对象什么时候转移到老年代？"></a>4.说说JVM的垃圾回收算法？对象什么时候转移到老年代？</h2><p>首先，我们需要了解一个原则：<strong>JVM一边运行代码一边判断和清理垃圾对象是不现实的</strong>，所以提到垃圾回收都会说一个概念： <strong>Stop The World</strong>，意思是JVM会停止工作线程的运行来进行垃圾回收 -&gt; 发生小小的卡顿</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-StopTheWorld.png" alt=""></p><blockquote><p>例子：聚会（程序运行）不断产生垃圾，清洁工清理垃圾（垃圾收集器），如果聚会不停止（程序不短暂暂停），则清洁工就没办法进入场地清理垃圾，打扫好屋子</p></blockquote><p>JVM使用 <strong>分代收集算法</strong> 来进行垃圾回收，根据不同区域使用不同垃圾回收算法，既可以有效清除垃圾对象，又提高了垃圾回收的效率</p><blockquote><p>这里省略另一种算法 <strong>增量算法</strong>：每次只收集一小片区域的垃圾（每次回收全部垃圾系统停顿更长，此算法可减小系统停顿）</p></blockquote><h3 id="4-1-年轻代垃圾回收算法-复制算法"><a href="#4-1-年轻代垃圾回收算法-复制算法" class="headerlink" title="4.1 年轻代垃圾回收算法-复制算法"></a>4.1 年轻代垃圾回收算法-复制算法</h3><p><strong>Minor/Young GC</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-youngGeneration.png" alt=""></p><p>98%的对象都会很快消亡，所以 <strong>大多数对象的生命周期都很短</strong></p><p>流程：对象在创建时，一般会先存放到Eden，Eden满了之后就会触发垃圾回收，会把Eden中存活对象拷贝到S1中，清理Eden区域的所有对象。如果Eden区域又满时，会把Eden区域和S1的存活对象复制到S2区域，再清楚所有Eden区域和S1区域的对象。如此反复..</p><blockquote><p>优点：性能好、无碎片<br>缺点：内存利用率低</p></blockquote><h3 id="4-2-老年代垃圾回收算法-标记清除-标记整理算法"><a href="#4-2-老年代垃圾回收算法-标记清除-标记整理算法" class="headerlink" title="4.2 老年代垃圾回收算法-标记清除/标记整理算法"></a>4.2 老年代垃圾回收算法-标记清除/标记整理算法</h3><p><strong>老年代的对象都是被长期引用的</strong>，老年代的垃圾回收比较慢，一般是年轻代垃圾回收的10倍以上</p><p><strong>新创建的对象也有可能直接进入老年代</strong>：</p><ol><li>对象大于JVM参数-XX:PretenureSizeThreshold的阈值时，直接分配到老年代</li><li>新生代的空间不足以存放该对象</li></ol><p>老年代的垃圾回收：<strong>Major GC</strong> </p><blockquote><p>执行Major GC时一般都伴随这Minor GC，所以老年代回收约等于Full GC。</p></blockquote><p><strong>Major GC 触发条件</strong>：</p><ol><li>老年代空间不足</li><li>元空间不足</li><li>某一对象晋升到老年代但是老年代空间不足</li><li>显式调用<code>System.gc()</code>方法，可以使用-XX:+DisableExplicitGC来忽略此调用</li></ol><p><strong>标记清除算法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-markClean.png" alt=""></p><ol><li>使用 <strong>可达性分析</strong> 标记可回收对象</li><li>清除可回收对象</li></ol><blockquote><p>优点：实现简单<br>缺点：清除后会存在内存碎片，例如图中情况下，如果想分配一个连续三个内存空间的数组，则图中的内存块无法做到</p></blockquote><p><strong>标记整理算法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-markSort.png" alt=""></p><ol><li>使用 <strong>可达性分析</strong> 标记可回收对象</li><li>把存活对象移动到一端</li><li>清除可回收对象</li></ol><blockquote><p>优点：无内存碎片<br>缺点：对比标记清除开销大</p></blockquote><h3 id="4-3-对象什么时候转移到老年代"><a href="#4-3-对象什么时候转移到老年代" class="headerlink" title="4.3 对象什么时候转移到老年代"></a>4.3 对象什么时候转移到老年代</h3><ol><li>经过 <strong>15次Young GC还存活</strong> 的对象会转移到老年代。例如<strong>Spring容器里管理的对象实例</strong>，被Spring容器引用，所以长期存活转移到老年代</li><li>新创建的大对象，如果Eden区域放不下，则会转移到老年代</li><li><strong>S区域放不下</strong> 的对象会转移到老年代</li></ol><h2 id="5-GC简单汇总图"><a href="#5-GC简单汇总图" class="headerlink" title="5. GC简单汇总图"></a>5. GC简单汇总图</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-GCList.png" alt=""></p><blockquote><p>Full GC待补充</p></blockquote><h2 id="6-常用的垃圾回收器"><a href="#6-常用的垃圾回收器" class="headerlink" title="6. 常用的垃圾回收器"></a>6. 常用的垃圾回收器</h2><p><strong>parnew + CMS</strong> </p><p>目前主流的jdk版本使用的组合</p><p>parnew： <strong>新生代垃圾回收器</strong>，使用<strong>多线程</strong>去回收垃圾对象，使用复制算法<br>CMS：<strong>老年代垃圾回收器</strong>，是一个<strong>并发收集器</strong>，使用标记清除算法</p><p><strong>G1分代垃圾回收器</strong></p><p>jdk新版本使用的垃圾回收器</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM灵魂拷问系列之JVM内存模型知多少</title>
      <link href="/posts/interview-jvm-model.html"/>
      <url>/posts/interview-jvm-model.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM灵魂拷问系列之JVM内存模型知多少"><a href="#JVM灵魂拷问系列之JVM内存模型知多少" class="headerlink" title="JVM灵魂拷问系列之JVM内存模型知多少"></a>JVM灵魂拷问系列之JVM内存模型知多少</h1><h2 id="1-JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？"><a href="#1-JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？" class="headerlink" title="1.JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？"></a>1.JVM中有几块内存区域？JDK8之后对内存分代做了什么改进？</h2><blockquote><p>前提流程分析：我们在部署项目时，无论是旧项目（SSH、SSM）还是新项目（SpringBoot内置tomcat），都会放在tomcat中的目录中部署运行的。<br>tomcat由java编写，本质上是一个JVM进程，当请求到来时，jvm通过编译后的项目字节码来执行我们的业务代码响应请求</p></blockquote><p>众所周知，不讲tomcat自带的线程池，我们平时使用的框架或者自定义的线程池都说明了一点，系统中运行着多个线程，这些线程既有自己独有的空间（栈内存），也有共同分享的空间（堆内存）</p><h3 id="1-1-堆内存（线程共享）"><a href="#1-1-堆内存（线程共享）" class="headerlink" title="1.1 堆内存（线程共享）"></a>1.1 堆内存（线程共享）</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-heap.png" alt=""></p><p>由图可知，堆分为三个部分：<strong>新生代、老年代和持久代/元空间</strong></p><blockquote><p>元空间不存放在堆中而是存放在在本地内存中，这里用作比较之用</p></blockquote><p>JVM在启动过程中，线程会创建很多对象，这些对象一般优先存放在 <strong>新生代的Eden伊甸园区域</strong> ，如果对象大于一定程度，则存放在 <strong>老年代</strong> 中</p><p>java语言的特点：一处编译，处处运行。说的就是我们写的项目代码会通过编译器编译成字节码文件，由不同系统的java虚拟机来运行他们。而这些 <strong>字节码文件（类信息等）</strong> 也是需要一个地方进行存放的，JDK8之前，存放地为 <strong>永久代</strong> ，JDK8之后为 <strong>元空间</strong></p><p>JDK8前后分代改进：</p><ul><li>JDK8以前：在 <strong>永久代</strong> 存放常量池和类信息</li><li>JDK8以后：在 <strong>metaspace元空间</strong> 存放类信息</li></ul><p><strong>为什么 JDK1.8 把永久代干掉</strong></p><ol><li>oracle收购两家公司，其中一家公司JDK1.8以前没有永久代，干脆干掉了再新增一个元空间</li><li>永久代存放一系列常量，类、方法的相关信息，但是这些都没办法确定，但是 <strong>永久代空间固定，可能导致内存溢出</strong>（内存不足以存放信息-OutOfMemoryError：PermGen）</li><li>元空间本质是本地内存，理论上 <strong>取决于操作系统可以分配的内存大小，可以解决内存不足的情况</strong></li></ol><h3 id="1-2-栈内存-虚拟机栈（线程独享）"><a href="#1-2-栈内存-虚拟机栈（线程独享）" class="headerlink" title="1.2 栈内存/虚拟机栈（线程独享）"></a>1.2 栈内存/虚拟机栈（线程独享）</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-stack.png" alt=""></p><p>当线程创建时，会创建一个由多个栈帧组成的虚拟机栈，存放着例如 <strong>局部变量、对象引用</strong> 等</p><h3 id="1-3-本地方法栈（线程独享）"><a href="#1-3-本地方法栈（线程独享）" class="headerlink" title="1.3 本地方法栈（线程独享）"></a>1.3 本地方法栈（线程独享）</h3><p>存放一些由 <strong>C语言编写的native方法</strong> ，例如我们常用到的 <strong>Unsafe（CAS）</strong> </p><h3 id="1-4-程序计数器（线程独享）"><a href="#1-4-程序计数器（线程独享）" class="headerlink" title="1.4 程序计数器（线程独享）"></a>1.4 程序计数器（线程独享）</h3><p>用来 <strong>记录线程执行字节码的地址</strong> ，也就是对执行到哪一行代码做一个标记。当线程被挂起，再恢复时，方便及时定位到继续执行的位置</p><h3 id="1-5-方法区（线程共享）"><a href="#1-5-方法区（线程共享）" class="headerlink" title="1.5 方法区（线程共享）"></a>1.5 方法区（线程共享）</h3><p>方法区是 <strong>逻辑层面</strong> 上的划分，如图</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-methodArea.png" alt=""></p><p>方法区在 <strong>堆</strong> 中存储着 <strong>静态变量 和 字符串常量</strong><br>方法区在 <strong>元空间</strong> 中存储着 <strong>类相关信息 和 运行时常量</strong></p><blockquote><p>【静态常量池】：属于<strong>堆</strong>，存放着 <strong>文本常量</strong> 或者 <strong>被final修饰的常量</strong>，也存放着一些 <strong>类名、方法名</strong> 等<br>【运行时常量池】：属于<strong>元空间/本地内存</strong>，当类被加载到内存中，JVM会把静态常量池中的内容存放到运行时常量池中。<br>【字符串常量池】：属于<strong>堆</strong>，运行时常量池分出来的一部分，类加载到内存中时，字符串会存放在字符串常量池中</p></blockquote><h2 id="2-你知道JVM是如何运行起来的吗？对象是如何分配的？"><a href="#2-你知道JVM是如何运行起来的吗？对象是如何分配的？" class="headerlink" title="2.你知道JVM是如何运行起来的吗？对象是如何分配的？"></a>2.你知道JVM是如何运行起来的吗？对象是如何分配的？</h2><p>举个例子🌰：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PREFIX <span class="token operator">=</span> <span class="token string">"名称前缀"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        MyService myService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myService<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token string">"testName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>PREFIX <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-JVM-demoDesc.jpg" alt=""></p><ol><li>java代码通过编译器编译成JVM可读懂的class字节码文件。项目启动，JVM调用main方法，或者存在Spring容器实例化必需类时，都会通过 <strong>类加载机制</strong> 把MyController.class文件加载到内存中，在堆内存中创建MyController实例，将MyController类相关信息存放在元空间中，在堆内存的静态常量池中创建静态常量</li><li>当请求到来时，线程执行<code>doRequest()</code>方法，会在 <strong>堆内存</strong> 中创建一个MyService对象实例，同时在栈内存中创建一个栈帧，存放方法信息和局部引用变量myService，指向堆内存中的示例。静态常量池的”名称前缀”也会存入运行时常量池</li><li>当myService执行<code>printName()</code>方法时，会创建<code>printName()</code>方法对应的栈帧，字符串常量池创建”testName”，局部变量name也存在栈帧中，指向”testName”</li><li>当<code>printName()</code>方法执行完毕，对应栈帧销毁，而后<code>doRequest()</code>执行完毕，对应栈帧销毁。因栈帧中的引用销毁了，堆内存相关的数据没有引用，下一次会被垃圾回收</li></ol><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/BLcJm5xG">JVM内存结构个人笔记</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游</title>
      <link href="/posts/interview-springcloud.html"/>
      <url>/posts/interview-springcloud.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游"><a href="#Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游" class="headerlink" title="Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游"></a>Spring灵魂拷问系列之一个请求怎么在SpringCloud中遨游</h1><p><strong>SpringCloud组件</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringCloud-component.png" alt=""></p><p><strong>一个请求怎么在SpringCloud中遨游</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringCloud-structure.jpg" alt=""></p><ol><li>在Spring Cloud中，每个服务和组件都需要在 <strong>Eureka注册中心</strong> 注册，注册成功后，Eureka也会主动发起 <strong>心跳检测来进行健康检查和信息同步</strong></li><li>服务启动时，会根据环境从配置中心中拉取对应配置来启动</li><li>浏览器发起请求，到达网关层，网关层根据 <strong>路由转发</strong> 到指定服务A（网关层还可起到限流、鉴权、负载均衡等作用）</li><li>如果服务A需要需要依赖服务B，则会通过 <strong>ribbon负载均衡策略</strong> 找到某一台服务B的实例，再通过 <strong>feign调用</strong> 实例服务，其中使用 <strong>hystrix</strong> 进行服务 <strong>降级/熔断</strong> </li><li>A服务执行业务完毕，返回数据给网关，网关返回浏览器/前端工程</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring灵魂拷问系列之简单理一下SpringMVC流程</title>
      <link href="/posts/interview-springmvc.html"/>
      <url>/posts/interview-springmvc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之简单理一下SpringMVC流程"><a href="#Spring灵魂拷问系列之简单理一下SpringMVC流程" class="headerlink" title="Spring灵魂拷问系列之简单理一下SpringMVC流程"></a>Spring灵魂拷问系列之简单理一下SpringMVC流程</h1><p> <img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringMVC-structure.jpg" alt=""></p><p>SpringMVC大体流程：</p><ol><li>tomcat工作线程将请求转发给Spring MVC框架的<strong>中央控制器DispatcherServlet</strong></li><li>中央控制器根据请求信息做相关的<strong>适配</strong>和<strong>映射</strong>，将请求转发到对应Controller</li><li>根据<code>@RequestMapping</code>来<strong>定位</strong>和<strong>调用</strong>到http请求对应的处理方法（处理器映射器、处理器适配器、处理器）</li><li>业务执行完毕后会有一个返回值。（1）以前：会通过JSP/模版引擎，将前端页面存放在后端工程中，返回值这里就是页面模版的名字，Spring MVC根据返回的数据对象对html页面进行渲染；（2）如今，前后端分离，返回值为json字符串，前端会根据返回的json数据，对html页面进行渲染</li><li>将渲染后的html页面返回给浏览器进行显示</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring灵魂拷问系列之Spring基础拷问</title>
      <link href="/posts/interview-spring-base.html"/>
      <url>/posts/interview-spring-base.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring灵魂拷问系列之Spring基础拷问"><a href="#Spring灵魂拷问系列之Spring基础拷问" class="headerlink" title="Spring灵魂拷问系列之Spring基础拷问"></a>Spring灵魂拷问系列之Spring基础拷问</h1><h2 id="0-面试连环炮"><a href="#0-面试连环炮" class="headerlink" title="0.面试连环炮"></a>0.面试连环炮</h2><p>Spring IOC和AOP的理解 -&gt; 动态代理 -&gt; JDK/Cglib动态代理 -&gt; Spring Bean线程安全 -&gt; Spring事务实现原理和事务传播机制</p><h2 id="1-说说对Spring-IOC的理解"><a href="#1-说说对Spring-IOC的理解" class="headerlink" title="1.说说对Spring IOC的理解"></a>1.说说对Spring IOC的理解</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-old-process.jpg" alt=""></p><p>以前的一套系统：<br>web服务器：绑定地址端口，负责接收请求<br>servlet：引入serviceImpl类来处理请求（doPost、doGet）</p><p>像这样每个servlet都新建一个serviceImpl服务类实例，导致耦合度很高，当需要换一个服务实现类时，每个地方都需要修改成新的类，导致改动、测试成本巨大</p><p>Spring IOC：<strong>控制反转，依赖注入，让系统的类与类之间解耦</strong></p><p>Tomcat启动Spring容器，扫描指定路径的包路径，所有加了Spring注解的类会被Spring容器初始和实例化Bean并且交给Spring容器管理，当某个地方使用到时，Spring容器会自动注入实例</p><blockquote><p>Spring MVC：核心Servlet、Filter，负责用户请求的转发，转发给对应的Controller，之后调用相应的服务类进行处理</p></blockquote><p>底层：通过反射来动态的构建对象实例</p><p>当改成Spring IOC解耦时，只需要修改service的实现类即可。这样的话，在具体请求过来时，Spring会根据反射动态生成实现类来处理请求了</p><h2 id="2-说说对Spring-AOP的理解"><a href="#2-说说对Spring-AOP的理解" class="headerlink" title="2.说说对Spring AOP的理解"></a>2.说说对Spring AOP的理解</h2><p><strong>核心技术：动态代理</strong></p><blockquote><p>不关心底层代码的实现逻辑，在此实现逻辑前后做一些公共的处理，例如事务处理、统计方法耗时等</p></blockquote><p>把代码公共/重复的代码抽取出来，比如日志、事务、通知等业务，做一个切面</p><h2 id="3-cglib动态代理和jdk动态代理的区别"><a href="#3-cglib动态代理和jdk动态代理的区别" class="headerlink" title="3.cglib动态代理和jdk动态代理的区别"></a>3.cglib动态代理和jdk动态代理的区别</h2><p>动态代理，动态的创建一个代理类和他的实例对象出来，在里面引用真正需要调用的类，代理类在此做一些增强（事务、日志等）</p><p>两者区别在于 <strong>生成动态代理类的方式</strong></p><p>Spring AOP使用的 <strong>JDK动态代理</strong> ，生成实现同个接口代理类，构造实例出来。当需要代理的类没有接口时，Spring AOP会改用 <strong>Cglib动态代理</strong> ，生成该类的子类（动态生成字节码），覆盖目标类的方法，在覆盖方法中进行增强</p><ol><li><strong>JDK动态代理</strong>：代理类实现 <strong>InvocationHandler</strong> 接口， <strong>Proxy</strong> 生成代理对象，当调用接口方法时，真正会调用的是代理类的 <strong>invoke</strong> 方法</li><li><strong>Cglib动态代理</strong>：代理类实现 <strong>MethodInterceptor</strong> 接口， <strong>Enhancer</strong> 生成代理对象，当调用类方法时，拦截器会拦截在方法前后进行增强（ <strong>intercept方法</strong> ）</li></ol><h2 id="4-Spring中的Bean是线程安全的吗"><a href="#4-Spring中的Bean是线程安全的吗" class="headerlink" title="4.Spring中的Bean是线程安全的吗"></a>4.Spring中的Bean是线程安全的吗</h2><p>Spring Bean的作用域：</p><ul><li><strong>singleton</strong>：默认，单例，只有一个实例</li><li><strong>prototype</strong>：为每个bean请求都提供一个实例</li><li><strong>request</strong>：为每个网络请求request创建一个实例，请求完成后被垃圾回收</li><li><strong>session</strong>：为每个session创建一个实例，请求完成后被垃圾回收</li><li><strong>global-session</strong>：标准的HTTP Session作用域</li></ul><blockquote><p>基本大部分时候我们都使用默认的singleton单例作用域</p></blockquote><p><strong>Spring Bean是线程不安全的</strong></p><blockquote><p>例如，bean中存在一个变量data（未被volatile修饰），多线程并发（多个请求同时发起同个服务）时，多个线程同时调用实例A的同一方法（该方法里存在data++），基于线程的工作内存和主内存不一定同步的机制，就会发生线程安全问题<br>如果不存在实例变量，逻辑处理只操作数据库的话，一般不会有线程安全问题</p></blockquote><h2 id="5-Spring的事务实现原理是什么？"><a href="#5-Spring的事务实现原理是什么？" class="headerlink" title="5.Spring的事务实现原理是什么？"></a>5.Spring的事务实现原理是什么？</h2><p>日常编码中，需要对代码逻辑增加事务，使用Transactional注解，Spring会通过AOP/动态代理的机制，对方法进行增强，织入事务，方法执行前开启事务，执行成功后提交事务，异常回滚事务</p><h2 id="6-能聊聊你对Spring事务的传播机制的理解吗？"><a href="#6-能聊聊你对Spring事务的传播机制的理解吗？" class="headerlink" title="6.能聊聊你对Spring事务的传播机制的理解吗？"></a>6.能聊聊你对Spring事务的传播机制的理解吗？</h2><p><strong>事务传播机制级别 - 最常用的是前4个</strong></p><ul><li><strong>REQUIRED</strong>：如果父方法没有事务，则新创建一个事务，存在事务则加入事务</li><li><strong>SUPPORTS</strong>：如果父方法存在事务则加入事务，当前没有事务，则不开启事务执行</li><li><strong>REQUIRES_NEW</strong>：无论当前父方法有没有事务，都新建一个事务，父方法存在事务时，两者事务是隔离开的</li><li><strong>NESTED</strong>：父方法存在事务，则嵌套事务执行（外层代码出错内层代码一起回滚，内层代码出错只有内层回滚），如果没有事务，按照REQUIRED属性执行</li><li><strong>MONDATORY</strong>：如果当前父方法存在事务则加入事务，当前没有事务，则抛异常</li><li><strong>NOT_SUPPORTED</strong>：强制要求非事务运行，如果父方法存在事务则挂起</li><li><strong>NEVER</strong>：非事务方式执行，如果存在事务会报错</li></ul><p><strong>方法A调用方法B，希望方法A出错只回滚方法A自己，不回滚方法B，该怎么办</strong></p><blockquote><p>选择事务传播机制的REQUIRES_NEW</p></blockquote><p><strong>方法A调用方法B，方法B只能回滚自己，方法A可以带着方法B一起回滚</strong></p><blockquote><p>NESTED嵌套事务</p></blockquote><h2 id="7-谈谈Spring-Boot的核心架构"><a href="#7-谈谈Spring-Boot的核心架构" class="headerlink" title="7.谈谈Spring Boot的核心架构"></a>7.谈谈Spring Boot的核心架构</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/interview-SpringBoot-structure.jpg" alt=""></p><p>在早期java web开发时，我们使用SSM框架那一套，需要打包部署到线上的tomcat上，请求到来，根据Spring MVC框架流程，来一一调用controller、service、dao层等。</p><p>早期开发时，我们也需要根据业务引入比较多的中间件技术，例如redis、elasticsearch、rabbitmq等，引入时配置比较繁琐复杂，例如引入jar包，编写xml配置文件，定义bean等</p><p><strong>SpringBoot</strong></p><ol><li>内嵌了tomcat，上线时可以直接部署启动；</li><li>通过 <strong>自动装配</strong> 的特性，在整合第三方组件时，只要引入相关的starter依赖，会自动做一些配置、定义生成对应bean等操作，只要配置必要的相关地址等配置，一定程度上降低了原先整合的成本，详细可看<a href="http://xuyk.top/posts/SpringBoot-autoConfiguration.html">SpringBoot之自动配置原理</a></li></ol><h2 id="8-Spring-Bean的生命周期"><a href="#8-Spring-Bean的生命周期" class="headerlink" title="8.Spring Bean的生命周期"></a>8.Spring Bean的生命周期</h2><p><strong>Spring Bean大致的生命周期</strong></p><p>实例化 -&gt; 初始化 -&gt; Spring容器管理下长期存活 -&gt; 销毁</p><h3 id="1-实例化Bean"><a href="#1-实例化Bean" class="headerlink" title="1.实例化Bean"></a>1.实例化Bean</h3><p>如果需要使用bean，需要先实例化</p><ul><li>对于 BeanFactory 容器，通过 createBean 进行实例化</li><li>对于 ApplicationContext 容器，通过 BeanDefinition 进行实例化</li></ul><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h3><p>当需要使用的bean依赖其他的bean，也需要把依赖的bean创建并且注入进来，注入的方式有两种</p><ul><li><strong>构造器注入</strong></li><li><strong>setter注入</strong></li></ul><h3 id="3-处理Aware接口"><a href="#3-处理Aware接口" class="headerlink" title="3.处理Aware接口"></a>3.处理Aware接口</h3><p>如果bean实现了 ApplicationContextAware 接口，Spring容器就会通过 <code>setApplicationContext(ApplicationContext)</code> 方法，把Spring容器传递给这个bean</p><h3 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4.BeanPostProcessor"></a>4.BeanPostProcessor</h3><p>bean实例化完成之后，如果想对Bean进行一些自定义的处理，那么可以让Bean实现 BeanPostProcessor 接口，将会调用<code>postProcessBeforeInitialization(Object obj,String s)</code>方法</p><blockquote><p>初始化之前</p></blockquote><h3 id="5-初始化initializingBean与init-method"><a href="#5-初始化initializingBean与init-method" class="headerlink" title="5.初始化initializingBean与init-method"></a>5.初始化initializingBean与init-method</h3><p>对bean进行初始化</p><h3 id="6-BeanPostProcessor"><a href="#6-BeanPostProcessor" class="headerlink" title="6.BeanPostProcessor"></a>6.BeanPostProcessor</h3><p>如果Bean实现 BeanPostProcessor 接口，将会调用<code>postProcessAfterInitialization(Object obj,String s)</code>方法</p><blockquote><p>由于发生在初始化完成之后，所以经常用于内存或者缓存的操作</p></blockquote><h3 id="7-DisposableBean"><a href="#7-DisposableBean" class="headerlink" title="7.DisposableBean"></a>7.DisposableBean</h3><p>当Bean不再被需要时，如果Bean实现了DisposableBean接口，会调用他的<code>destory()</code>方法</p><h3 id="8-destroy-method"><a href="#8-destroy-method" class="headerlink" title="8.destroy-method"></a>8.destroy-method</h3><p>如果bean配置的destroy-method属性，会自动调用配置的销毁方法</p><h2 id="9-能说说Spring中使用了哪些设计模式吗"><a href="#9-能说说Spring中使用了哪些设计模式吗" class="headerlink" title="9.能说说Spring中使用了哪些设计模式吗"></a>9.能说说Spring中使用了哪些设计模式吗</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><p>Spring IOC自己就是一个大工厂，把所有bean实例都放在Spring容器中，需要使用就直接从Spring容器中拿</p><h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>Spring Bean默认使用单例，保证类在运行期间只有一个实例对象，最常见的就是懒汉式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonTest singletonTest<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonTest <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonTest <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    singletonTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singletonTest<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用双重检查 + synchronized关键字保证只生成一个实例，volatile保证不发生指令重排</p></blockquote><h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h3><p>主要涉及到的就是Spirng AOP，例如XXXAware那些某个增强类，创建动态代理对象实例，在调用被代理对象的方法时，会先执行代理类的增强代码，再执行方法代码，例如Spring Bean生命周期中，实现 ApplicationContextAware 接口后，Spring容器会把 ApplicationContext 注入到bean中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程灵魂拷问系列之Java内存模型</title>
      <link href="/posts/interview-JMM.html"/>
      <url>/posts/interview-JMM.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之Java内存模型"><a href="#并发编程灵魂拷问系列之Java内存模型" class="headerlink" title="并发编程灵魂拷问系列之Java内存模型"></a>并发编程灵魂拷问系列之Java内存模型</h1><h2 id="0-面试连环炮路径"><a href="#0-面试连环炮路径" class="headerlink" title="0.面试连环炮路径"></a>0.面试连环炮路径</h2><p>JMM（Java内存模型）-&gt; 原子性、可见性、有序性 -&gt; volatile和可见性 -&gt; volatile和有序性（指令重排+happens-before）-&gt; volatile和原子性 -&gt; volatile底层原理（内存屏障级别的原理）</p><h2 id="1-聊一下Java的内存模型"><a href="#1-聊一下Java的内存模型" class="headerlink" title="1.聊一下Java的内存模型"></a>1.聊一下Java的内存模型</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM-process.jpg" alt=""></p><p>volatile：共享变量修改时会强制刷新一下主内存的值</p><ol><li>线程1/2 read 主内存的共享变量， load 到工作内存中，此时读到的值都为0</li><li>线程1/2 use 从工作内存中拿出共享变量，进行操作（比如 <strong>++</strong> 操作，那么计算之后的值都为1）</li><li>线程1/2 assign 把工作内存设置回工作内存中，之后工作内存尝试 <strong>store</strong> 写入主内存，写入成功就是 <strong>write</strong></li><li>结果就是主内存data从 0 -&gt; 1</li></ol><h2 id="2-你知道Java内存模型的原子性、有序性、可见性是什么"><a href="#2-你知道Java内存模型的原子性、有序性、可见性是什么" class="headerlink" title="2.你知道Java内存模型的原子性、有序性、可见性是什么"></a>2.你知道Java内存模型的原子性、有序性、可见性是什么</h2><p><strong>原子性</strong>：指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1。</p><p><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。Java保证可见性可以认为通过volatile、synchronized、final来实现。</p><p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行，Java通过volatile、synchronized来保证。具备有序性，则不会发生指令重排</p><p>volatile禁止指令重排序，防止编译器编译优化时对代码重新排序，导致代码顺序变化。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM_orderliness.png" alt=""></p><p>【例子】正常情况是资源准备完毕，flag才设置为true，但是如图，如果发生指令重排，可能导致先设置为true再进行资源准备，导致直接直接execute而报错</p><h2 id="3-讲讲volatile的工作原理，如何保证可见性？"><a href="#3-讲讲volatile的工作原理，如何保证可见性？" class="headerlink" title="3.讲讲volatile的工作原理，如何保证可见性？"></a>3.讲讲volatile的工作原理，如何保证可见性？</h2><p>volatile关键字用来保证 <strong>可见性</strong> 和 <strong>有序性</strong> 的，不能保证原子性（极端特殊情况下可保证而已）</p><p>举例说明无法保证原子性（还是这张图）：<br><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/JMM-process.jpg" alt=""></p><blockquote><p>就算使用volatile修饰data，当线程1更新data=1到主内存，使得线程二工作内存的data值失效，但是可能此时data已经在被运算中，及时失效了，还是会通过assign把data=1设置到工作内存中，最后write到主内存<br>需要保证原子性，还是需要 <strong>synchronized</strong> 、 <strong>lock</strong> 来保证</p></blockquote><p>当volatile修饰值data，保证data在多线程之间的 <strong>可见性</strong> ，如果data修改，会强制刷新其他线程工作内存中的data的值（让其他线程工作内存data的值失效，来起到强制刷新的作用）</p><p>volatile通过 <strong>禁止指令重排</strong> 来保证 <strong>有序性</strong> </p><h2 id="4-你知道指令重排和happens-before是什么吗？"><a href="#4-你知道指令重排和happens-before是什么吗？" class="headerlink" title="4.你知道指令重排和happens-before是什么吗？"></a>4.你知道指令重排和happens-before是什么吗？</h2><p>一般情况下，为了提高程序执行的效率，编译器或者指令器会对代码进行优化，例如指令重排。</p><p>java中有一个 <strong>happens-before</strong> 原则,<strong>一定程度上来避免胡乱地指令重排</strong>。他在一些特殊情况下，不允许编译器或者指令器对写的代码进行指令重排。</p><p>其中有一个与volatile相关的原则，如果代码中存在volatile修饰的值，此值进行volatile写后，再volatile读，那么顺序上必须先写再读</p><blockquote><p>比如代码中,代码顺序A-&gt;B-&gt;C，那么A的顺序就优于C；或者比如对lock的操作顺序不能被重排（代码先unlock再lock，就不能重排为lock后unlock，否则导致流程错乱）</p></blockquote><h2 id="5-volatile是如何基于内存屏障保证可见性和有序性的？"><a href="#5-volatile是如何基于内存屏障保证可见性和有序性的？" class="headerlink" title="5.volatile是如何基于内存屏障保证可见性和有序性的？"></a>5.volatile是如何基于内存屏障保证可见性和有序性的？</h2><p>内存屏障：禁止重排序</p><p><strong>如何保证有序性</strong><br>如果使用了volatile修饰一个值后，那么会对该值的读写前后会加入一些内存屏障，加入屏障之后，来避免发生指令重排</p><p><strong>如何保证可见性</strong><br>如果使用了volatile修饰一个值data后，在对data执行写操作，JVM会发送<strong>lock前缀指令</strong>给CPU，CPU收到指令，计算完毕会把data强制刷新到主内存里，其他线程通过<strong>对总线的嗅探</strong>，让工作内存的data值失效，之后读取data值时因为工作内存data值失效，所以从缓存中获取。保证了可见性</p><blockquote><p>lock前缀指令 + MESI缓存一致性协议</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程灵魂拷问系列之对AQS理解吗</title>
      <link href="/posts/interview-AQS.html"/>
      <url>/posts/interview-AQS.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之对AQS理解吗"><a href="#并发编程灵魂拷问系列之对AQS理解吗" class="headerlink" title="并发编程灵魂拷问系列之对AQS理解吗"></a>并发编程灵魂拷问系列之对AQS理解吗</h1><p><strong>AQS</strong> 即 AbstractQueuedSynchronizer，队列同步器。早期是因为JDK6以前的synchronized关键字使用的是重量级锁，性能不太好，所以作者编写了AQS。</p><p>在JUC中 CountDownLatch、ReentrantLock、ThreadPoolExecutor、ReentrantReadWriteLock 等底层用的都是AQS，AQS几乎占据了JUC并发包里的半壁江山，如果想要获取锁可以被中断、超时获取锁、尝试获取锁那就用AQS吧。</p><p>AQS内部维护了一个 <strong>先进先出队列</strong> 和 <strong>state状态变量</strong></p><ul><li>先进先出队列载体是 Node节点，节点里包含状态值，属于独占/共享模式，前驱/后继节点等信息</li><li>state由 <strong>volatile</strong> 修饰，标识当前锁的状态，1表示加锁成功 0未加锁</li></ul><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AQS-first.png" alt=""></p><ol><li>当线程1操作CAS加锁成功，AQS中的加锁线程变为线程1，state设置为1。</li><li>与此同时线程2加锁失败会进入FIFO先进先出等待队列，当线程1执行完成后，state设为0，然后唤醒等待队列的首位线程也就是线程2，让线程2进行CAS操作</li></ol><p><strong>独占式锁和共享式锁</strong></p><ul><li>独占式：有且只有一个线程能获取到锁，如：ReentrantLock。</li><li>共享式：可以多个线程同时获取到锁，如：CountDownLatch</li></ul><p><strong>公平锁和非公平锁</strong></p><ul><li>公平锁：先到先得，线程通过排队的方式来获取锁</li><li>非公平锁：后来的线程可能会率先获取到锁，非公平锁性能优于公平锁</li></ul><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/k8s-B1ZsEQylba4NWjehEA">由浅入深逐步讲解Java并发的半壁江山AQS</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/ZNURbYIdYqDNXLtRAvDxBQ">1.5w字，30图带你彻底掌握 AQS</a><br>4：<a href="https://mp.weixin.qq.com/s/-OEOk5NNgyjI8aYBm9Sspg">【对线面试官】AQS&amp;&amp;ReentrantLock</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程灵魂拷问系列之如何理解CAS</title>
      <link href="/posts/interview-CAS.html"/>
      <url>/posts/interview-CAS.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之如何理解CAS"><a href="#并发编程灵魂拷问系列之如何理解CAS" class="headerlink" title="并发编程灵魂拷问系列之如何理解CAS"></a>并发编程灵魂拷问系列之如何理解CAS</h1><p><strong>什么是CAS</strong></p><p> CAS，compare And set/swap等，他底层的硬件级别操作（CPU指令cmpxchg）来保证一定是原子性操作，让同一时间只能有一个线程执行CAS操作，在此时间其他线程执行CAS会失败。java里经常使用unsafe类来执行CAS操作</p><p> CAS有三个参数：<strong>当前值A、内存值V、修改的新值B</strong></p><ul><li>如果A和V相等，则把内存值V修改成新值B</li><li>如果A和V不相等，要么重试，要么放弃更新</li></ul><p><strong>为什么要使用CAS呢</strong></p><ul><li>synchronized关键字每次都需要使用锁来保证同一时间只有一个线程执行操作</li><li>CAS允许多个线程同时操作共享数据，但是同一时间只能有一个线程执行CAS操作，在很多情况下比synchronized更加高效，例如 <strong>对一个值进行累加</strong> 这样的操作</li></ul><blockquote><p>AtomicLong等底层使用了CAS，但是更推荐使用LongAdder，性能更高（数组来分散目标值减少自旋重试）</p></blockquote><p><strong>CAS的缺点</strong></p><ul><li>无法解决ABA的问题（共享变量从A -&gt; B -&gt; A），需要加一个版本号</li><li>循环时间长导致资源消耗</li><li>循环执行CAS操作不成功会陷入自旋而耗费cpu资源，锁竞争激烈的场景更倾向于使用重量级锁</li></ul><blockquote><p>解决ABA问题，可以使用结合 <strong>乐观锁</strong> 的机制，例如Java中的 <strong>AtomicStampedReference</strong> 类</p></blockquote><p><strong>使用场景</strong></p><ol><li>如果高并发执行时间久 ，用SYN好， 因为SYN底层用了wait() 阻塞后是不消耗CPU资源的</li><li>如果锁竞争不激烈说明自旋不严重，此时用CAS。</li></ol><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/kvuPxn-vc8dke093XSE5IQ">由浅入深讲解JUC下 CAS + Lock</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/uHl9cnNBtvY_Xc-5WfwpmQ">【对线面试官】 CAS</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程灵魂拷问系列之ConcurrentHashMap</title>
      <link href="/posts/interview-ConcurrentHashMap.html"/>
      <url>/posts/interview-ConcurrentHashMap.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之ConcurrentHashMap"><a href="#并发编程灵魂拷问系列之ConcurrentHashMap" class="headerlink" title="并发编程灵魂拷问系列之ConcurrentHashMap"></a>并发编程灵魂拷问系列之ConcurrentHashMap</h1><h2 id="那有什么线程安全的HashMap可以代替呢"><a href="#那有什么线程安全的HashMap可以代替呢" class="headerlink" title="那有什么线程安全的HashMap可以代替呢"></a>那有什么线程安全的HashMap可以代替呢</h2><p>一般面试连环炮会在大致问完HashMap后有此一问，<strong>既然HashMap是线程不安全的，那有什么线程安全的HashMap可以代替呢</strong>，就是为了引出ConcurrentHashMap。</p><ul><li><p>JDK1.8之前：采用分段锁的机制，整个数组被分为对个段（segment），每一段都有一个锁，段与段之间可以并发访问，但是多个线程同时访问同一段时，需要获取锁才能进行访问，提升了一定的性能，但是高并发下性能还是不够强</p></li><li><p>JDK1.8之后：取消分段锁机制，回归一个大数组的方式，采用CAS + synchronized，数据结构和Hashmap一样，使用数组 + 链表 + 红黑树</p></li></ul><blockquote><p>【分析】：JDK1.8之后，锁的粒度控制到了数组的每一个元素，当多线程对数组同一个元素进行操作比如put等，会先通过 CAS 的方式让同一时间只有一个线程A成功执行 CAS ，然后进行put ，其他线程就会使用synchronized 关键字对这个数组元素对象加锁，串行的等待线程A执行完毕后继续获取锁，进行后续操作</p></blockquote><p>【总结】：JDK1.8之后的ConcurrentHashMap，当多个线程对数组不同位置的元素进行操作时，可以并发操作；如果多个线程对数组统一位置元素进行操作时，则加锁串行化处理</p><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/XajTc9dqNNi_ByLR2B_J3A">为什么ConcurrentHashMap的读操作不需要加锁？</a><br>2：<a href="https://mp.weixin.qq.com/s/wZWPg2ldcG1QwHbk6oPOWQ">面试官邪魅一笑: 你说说 Java8 的 ConcurrentHashMap ？</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程灵魂拷问系列之说说synchronized</title>
      <link href="/posts/interview-synchronized.html"/>
      <url>/posts/interview-synchronized.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之synchronized"><a href="#并发编程灵魂拷问系列之synchronized" class="headerlink" title="并发编程灵魂拷问系列之synchronized"></a>并发编程灵魂拷问系列之synchronized</h1><h2 id="1-什么是synchronized，JDK1-6前后变化？"><a href="#1-什么是synchronized，JDK1-6前后变化？" class="headerlink" title="1.什么是synchronized，JDK1.6前后变化？"></a>1.什么是synchronized，JDK1.6前后变化？</h2><p>我们可以知道，并发问题一般都是因为 <strong>多个线程同时操作同一个共享数据</strong> 所造成的，解决办法就是加锁，例如 <strong>synchronized加锁</strong></p><ul><li>JDK1.6之前：synchronized使用的是操作系统的互斥锁（底层操作系统的mutex相关指令），因为需要在用户态和内核态进行切换，开销很大，导致并发激烈时性能很差</li><li>JDK1.6之后：进行了锁优化，比如锁升/分级、锁消除、锁粗化等，性能大幅提高，推荐使用</li></ul><h2 id="2-那synchronized底层原理是什么呢？"><a href="#2-那synchronized底层原理是什么呢？" class="headerlink" title="2.那synchronized底层原理是什么呢？"></a>2.那synchronized底层原理是什么呢？</h2><p>synchronized属于 <strong>非公平锁</strong></p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>synchronized是基于Monitor来实现同步的，每一个对象都有对应着一个Monitor，如果需要加锁，则必须获取monitor的lock锁。</p><p>monitor锁是可重入锁，有一个计数器，当进入同步代码块时，执行monitorenter指令，计数器+1，退出一个同步代码块时，执行monitorexit指令，计数器-1；当发生对同一对象多次加锁时，计数器加减多次</p><ol><li>对于同步方法，JVM采用 <strong>ACC_SYNCHRONIZED</strong> 标记符来实现同步。</li><li>对于同步代码块。JVM采用 <strong>monitorenter</strong> 、<strong>monitorexit</strong> 两个指令来实现同步。</li></ol><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/synchronized-monitor.jpg" alt=""></p><h2 id="3-什么是锁升-分级？"><a href="#3-什么是锁升-分级？" class="headerlink" title="3.什么是锁升/分级？"></a>3.什么是锁升/分级？</h2><blockquote><p>synchronized 一般来说都对 <strong>对象</strong> 进行加锁</p></blockquote><p>这个可以从对象入手分析，对象在 <strong>堆</strong> 的存储中存有对象头，对象头中的 <strong>Mark Word</strong> 存储着对象的运行时数据，包括对象的hashcode、对象持有的锁等，当中锁从状态进行了分类：</p><p><strong>无锁、偏向锁、轻量级锁、重量级锁</strong>。</p><p>线程获取锁，会根据锁竞争激烈程度进行锁升级来提高性能，<strong>锁可以升级但是不能降级</strong>。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/synchronized-lock-update1.png" alt=""></p><p><strong>总结：</strong></p><ol><li><p><strong>偏向锁</strong>：作者认为很多情况都是一个线程多次获取锁，这种情况加锁解锁最好不需要消耗太多资源，引入了偏向锁。当一个线程获取到锁，锁进进入了偏向模式（偏向锁），下一次该线程获取锁时，不需要额外进行额外进行操作，减少消耗。<strong>所以适合没有多线程来竞争锁的场景</strong></p></li><li><p><strong>轻量级锁</strong>：当其他线程来竞争原本偏向线程A的偏向锁时，等线程A释放锁后，该锁的偏向锁被撤销，升级为轻量级锁（只有发生了多线程之间的锁竞争，该锁会从偏向锁升级为轻量级锁）。<br>轻量级锁生效后，当线程X持有锁时，线程Y获取该对象的锁被线程X持有，则进行 <strong>自旋</strong> （循环使用CAS来获取锁）</p></li><li><p><strong>重量级锁</strong>：当线程Y自旋超过一定时间或者次数，锁会升级为重量级锁，防止CPU空转（自旋过久）。升级为重量级锁后，线程Y不在主动获取锁，而是线程X释放锁之后通知线程Y去获取锁，线程Y从自旋变为阻塞。</p></li></ol><p>简单来说：</p><ul><li><strong>偏向锁</strong>：在Mark Word 记录线程ID进行比对</li><li><strong>轻量级锁</strong>：通过CAS + 自旋的方式竞争</li><li><strong>重量级锁</strong>：使用monitor对象，阻塞</li></ul><h2 id="4-什么是锁消除？"><a href="#4-什么是锁消除？" class="headerlink" title="4.什么是锁消除？"></a>4.什么是锁消除？</h2><p>前文可知，线程安全问题条件之一是存在共享数据，但是当 <strong>synchronized</strong> 修饰的代码块中不存在共享数据时，JDK会通过逃逸分析判断这段代码不会有线程安全问题，自动消除这个锁</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>someMethod方法中的object是局部变量，当多个线程进入方法，会new一个新的object，不存在共享数据，所以会进行 <strong>锁消除</strong></p></blockquote><h2 id="5-什么是锁粗化？"><a href="#5-什么是锁粗化？" class="headerlink" title="5.什么是锁粗化？"></a>5.什么是锁粗化？</h2><p>将多个加锁解锁操作连接在一起，JDK会根据优化策略将其扩展成一个范围更大的锁</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 粗化前</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do some thing</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 能够很快执行完毕，且无需同步的代码</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 粗化后：</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//进行锁粗化：整合成一次锁请求、同步、释放</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do some thing</span>        <span class="token comment" spellcheck="true">// 能够很快执行完毕，且无需同步的代码</span>        <span class="token comment" spellcheck="true">// do other thing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-synchronized都可以修饰哪些对象？"><a href="#6-synchronized都可以修饰哪些对象？" class="headerlink" title="6.synchronized都可以修饰哪些对象？"></a>6.synchronized都可以修饰哪些对象？</h2><ul><li>1.修饰实例方法：锁定的是this对象（类锁）</li><li>2.修饰静态方法：锁定的是class对象（对象内置锁）</li><li>3.修饰代码块：锁定任意指定的对象</li></ul><h2 id="7-synchronized有什么缺点呢"><a href="#7-synchronized有什么缺点呢" class="headerlink" title="7.synchronized有什么缺点呢"></a>7.synchronized有什么缺点呢</h2><ul><li>1.锁的粒度还是比较大的</li><li>2.锁竞争激烈情况下，可能发生死锁</li><li>3.锁竞争激烈时，因为串行化，多个线程排队竞争锁效率不会太高</li></ul><blockquote><p>【参考链接】：<br>1：<a href="http://note.youdao.com/s/8UtdfawQ">synchronized和锁</a><br>2：<a href="https://mp.weixin.qq.com/s/mn4eujncsYZwAgwgm8d-vg">Java中的锁原理、锁优化、CAS、AQS详解</a><br>3：<a href="https://mp.weixin.qq.com/s/e_fYFWK5Qnxjmz6Abi7uqw">由浅入深逐步了解 Synchronized</a><br>4：<a href="https://mp.weixin.qq.com/s/v1XgT2X4IuF3_WNqeUVhVA">全网最细：17张图带你秒杀synchronized关键字</a><br>5:<a href="https://mp.weixin.qq.com/s/wwGvEt_3x9oHORwuXDqX5g">【对线面试官】synchronized</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程灵魂拷问系列之HashMap</title>
      <link href="/posts/interview-hmap.html"/>
      <url>/posts/interview-hmap.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程灵魂拷问系列之HashMap"><a href="#并发编程灵魂拷问系列之HashMap" class="headerlink" title="并发编程灵魂拷问系列之HashMap"></a>并发编程灵魂拷问系列之HashMap</h1><h2 id="1-你知道hashmap底层的数据结构是什么"><a href="#1-你知道hashmap底层的数据结构是什么" class="headerlink" title="1.你知道hashmap底层的数据结构是什么"></a>1.你知道hashmap底层的数据结构是什么</h2><ol><li>JDK1.8之前：数组 + 链表</li><li>JDK1.8之后：数组 + 链表 + 红黑树</li></ol><h2 id="2-hashmap在JDK1-8前后有什么区别"><a href="#2-hashmap在JDK1-8前后有什么区别" class="headerlink" title="2.hashmap在JDK1.8前后有什么区别"></a>2.hashmap在JDK1.8前后有什么区别</h2><ol><li>JDK1.8之前数据结构为数组+链表，JDK1.8+采用数组+链表+红黑树</li></ol><blockquote><p>红黑树查询速度更快，最坏情况的时间复杂度为O(logn)</p></blockquote><ol start="2"><li>JDK1.8之前向链表插入数据时采用头插法，JDK1.8+采用尾插法</li></ol><blockquote><p>因为头插法在多线程环境下，在扩容时resize，也就是节点重新分配位置，有可能会发生A-&gt;B-&gt;A这样的环形链表，导致下次取值时会发生无限循环。尾插法则不会</p></blockquote><ol start="3"><li>JDK1.8之前计算hash值做了四次移位和四次异或，JDK1.8+只用一次异或来提升效率</li></ol><blockquote><p>可能觉得一次扰动就足够了，多了边际作用不大</p></blockquote><ol start="4"><li>JDK1.8之前扩容的时候需要对原数组中的元素进行重新hash定位在新数组的位置，JDK1.8+采用更简单的判断逻辑，位置不变或索引+旧容量大小</li></ol><blockquote><p>扩容为原来数组的两倍，在计算数组位置的二进制掩码中只是高位多了个1，效果等于加上旧数组的长度</p></blockquote><h2 id="3-jdk1-8后hashmap链表和红黑树如何切换"><a href="#3-jdk1-8后hashmap链表和红黑树如何切换" class="headerlink" title="3.jdk1.8后hashmap链表和红黑树如何切换"></a>3.jdk1.8后hashmap链表和红黑树如何切换</h2><ol><li>链表 -&gt; 红黑树： 插入数据时，当链表长度大于等于8，并且数组长度大于等于64，该链表转化为红黑树</li><li>红黑树 -&gt; 链表：长度小于等于6，该红黑树转化成链表</li></ol><h2 id="4-hashmap插入链表是怎么插入的"><a href="#4-hashmap插入链表是怎么插入的" class="headerlink" title="4.hashmap插入链表是怎么插入的"></a>4.hashmap插入链表是怎么插入的</h2><ol><li>JDK1.8之前：头插法，因为当时作者认为新插入的元素往往更可能被查找</li><li>JDK1.8之后：尾插法</li></ol><blockquote><p>【追问】那为什么要改成尾插法呢？</p></blockquote><p>因为头插法在多线程环境下，在扩容时resize，也就是节点重新分配位置，有可能会发生A-&gt;B-&gt;A这样的环形链表，导致下次取值时会发生无限循环。</p><p>尾插法在扩容时会保持链表原本的顺序，就不会出现环的问题</p><blockquote><p>【那么hashmap在JDK1.8之后还线程安全吗】</p></blockquote><p>不安全，例如多线程情况下的put操作，就无法保证上一秒put的值，与下一秒get的还是原值（里面就有很多某属性++，这些都有线程安全问题）</p><blockquote><p>【那有什么办法解决这个线程安全的问题】</p></blockquote><ol><li>可以使用 hashtable ，但是因为直接在方法上锁，导致性能低下所以不考虑</li><li>可以使用 concurrentHashMap </li></ol><h2 id="5-jdk1-8对hash算法和寻址算法是如何优化的？"><a href="#5-jdk1-8对hash算法和寻址算法是如何优化的？" class="headerlink" title="5.jdk1.8对hash算法和寻址算法是如何优化的？"></a>5.jdk1.8对hash算法和寻址算法是如何优化的？</h2><p>我们在put一个kv时，会进行(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)运算（key为null则取0），也就是<strong>拿key的hash值高16位和低16位做异或运算</strong>；</p><p>【优化】：通过对key的hashcode和hashcode右移16位做<strong>异或运算</strong>，也就是把key的hashcode的高16位和低16位做异或运算，通过这样算出的值会<strong>保留高低16位的特征</strong>，尽可能让结果的低16位值不一样，</p><blockquote><p>【hash算法优化】：hash值高低16为进行异或计算，可以同时保留高低16位的特征，减少hash冲突</p></blockquote><p>接着对异或结果进行 “取模运算” ，定位到数组中具体的某个位置上</p><p>【优化】：因为取模运算性能比较差，所以使用 <strong>(n-1) &amp; hash</strong> 来代替取模运算，这里的&amp;运算一般来讲就都是低16位的运算（因为n是数组长度，一般n-1都很小，换算成32位前16位基本为0），所以要保证hash算法后算出来的hash值要尽可能不一样</p><blockquote><p>【寻址算法优化】：同样效果，则使用性能更高的与运算也就是 (n-1)&amp;hash 来进行寻址</p></blockquote><h2 id="6-HashMap如何解决hash碰撞问题的？"><a href="#6-HashMap如何解决hash碰撞问题的？" class="headerlink" title="6.HashMap如何解决hash碰撞问题的？"></a>6.HashMap如何解决hash碰撞问题的？</h2><p>先说一下发生场景：</p><p>在put\get操作中，当两个key-value键值对通过hash算法异或和取模运算之后，定位到的数组位置还是一样时，我们称之为发生了hash碰撞\hash冲突</p><p>【解决方法】<br>hashmap通过在该数组位置挂上链表+红黑树的方式来解决hash碰撞的问题。当发生hash碰撞时，后面的kv会在定位到链表的下个空置节点</p><p>但是如果链表长度过长，极端情况下查询某个值的时间复杂度就为O(n)，性能比较差，所以hashmap在链表达到8（同时数组长度大于64）后会把链表转换成红黑树（时间复杂度为O(logn)），性能会好一些</p><blockquote><p>红黑树长度达到6或6以下后，会由红黑树转为链表</p></blockquote><h2 id="7-hashmap是如何扩容的"><a href="#7-hashmap是如何扩容的" class="headerlink" title="7.hashmap是如何扩容的"></a>7.hashmap是如何扩容的</h2><ol><li>当hashmap数组长度达到 负载因子（默认0.75）* 当前数组容量时，会进行扩容，扩容到原来的2倍，扩容过程涉及到rehash、复制数据等</li><li>当某一链表长度达到8但是数组长度小于64时，会进行扩容</li></ol><p>具体扩容：创建新的数组，将原数组重新hash并且分散到新数组中，可能 位置不变 或 索引+旧容量大小</p><blockquote><p>数组长度变化，取模（与运算）后的结果也相应发生改变。rehash过程中使用 (n-1) &amp; hash(key) 代替取模操作，提高了性能</p></blockquote><h2 id="8-HashMap的主要参数都有哪些？"><a href="#8-HashMap的主要参数都有哪些？" class="headerlink" title="8. HashMap的主要参数都有哪些？"></a>8. HashMap的主要参数都有哪些？</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap-params.jpg" alt=""></p><blockquote><p>摘自公众号【Java3y】</p></blockquote><h2 id="9-阐述一下HashMap在JDK7的环产生原理"><a href="#9-阐述一下HashMap在JDK7的环产生原理" class="headerlink" title="9.阐述一下HashMap在JDK7的环产生原理"></a>9.阐述一下HashMap在JDK7的环产生原理</h2><p>因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；</p><p>A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap-ring.jpg" alt=""></p><blockquote><p>【参考链接】：<br>1：<a href="https:\mp.weixin.qq.com\s\0Gf2DzuzgEx0i3mHVvhKNQ">《吊打面试官》系列-HashMap</a><br>2：<a href="https:\mp.weixin.qq.com\s\ubwe-2U19Y7GQsIByYTWng">HashMap就是这么简单【源码剖析】</a><br>3：<a href="http:\xuyk.top\posts\hashmap.html">HashMap-链表散列</a><br>4：<a href="https:\zhuanlan.zhihu.com\p\125628540">一个HashMap跟面试官扯了半个小时</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程灵魂拷问系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款自定义RPC框架 x-rpc</title>
      <link href="/posts/x-rpc.html"/>
      <url>/posts/x-rpc.html</url>
      
        <content type="html"><![CDATA[<h1 id="x-rpc"><a href="#x-rpc" class="headerlink" title="x-rpc"></a>x-rpc</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>在微服务大行其道的2021，说到服务之间的通信，大家都会马上想到RPC（Remote Procedure Call Protocol）远程方法调用，也就是可以让我们调用远程第三方服务时能像调用本地方法一样简单快捷省事儿。其中被大家所熟知的就有SpringCloud中的Feign、Alibaba的Dubbo和谷歌的gRpc等。为了对这些框架有更深刻的了解，笔者自己尝试造了个轮子，也就是x-rpc。</p><p>x-rpc是一款基于 Netty+protostuff+Zookeeper 实现的 RPC 框架，框架大体结构参考的是dubbo：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/dubbo-architure.jpg" alt=""></p><blockquote><p>服务提供方（服务端）启动，向注册中心注册所要发布的服务列表；消费端（客户端）启动，向注册中心订阅/拉取所关心的服务，也就是进行服务发现；消费端发起请求，服务端响应。</p></blockquote><p>简单说明一下x-rpc的设计思路：</p><ol><li><strong>网络传输</strong> ：netty作为<strong>底层通信</strong>框架，能够在简化网络编程的同时压榨cpu，充分提高应用的性能，是网络通信框架的不二之选。</li><li><strong>注册中心</strong> ：天生就用来作为分布式系统下的注册中心、统一配置管理中心、命名服务中心等功能的zookeeper毋庸置疑承担了<strong>服务发现</strong>和<strong>服务注册</strong>的角色</li><li><strong>序列化</strong> ：因为JDK自带的序列化效率很低并且有安全问题，所有这里采用谷歌的protostuff负责<strong>数据包的序列化和反序列化</strong>，当然kryo、Marshalling也是不错的选择</li><li><strong>动态代理</strong> ： 使用动态代理可以屏蔽远程方法调用的细节比如网络传输。也就是说当你调用远程方法的时候，实际会通过代理对象来传输网络请求。</li><li><strong>负载均衡</strong>：这里采用的是客户端负载均衡，通过轮询对服务的每个服务端节点进行依次请求，避免单机压力过大，达到负载均衡效果。</li></ol><h2 id="2-计划列表"><a href="#2-计划列表" class="headerlink" title="2.计划列表"></a>2.计划列表</h2><p><strong>已优化列表</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 重用 Channel 避免重复连接服务端</li><li><input checked="" disabled="" type="checkbox"> 使用 zookeeper 进行服务发现与注册</li><li><input checked="" disabled="" type="checkbox"> 心跳链路检测</li><li><input checked="" disabled="" type="checkbox"> 使用 CompletableFuture 包装接收服务端返回结果</li><li><input checked="" disabled="" type="checkbox"> 客户端调用远程服务进行负载均衡，x-rpc默认使用<strong>轮询</strong>进行负载均衡</li><li><input checked="" disabled="" type="checkbox"> 集成spring</li></ul><p><strong>代办列表</strong></p><ul><li><input disabled="" type="checkbox"> 数据传输时的数据包重新设计：加入魔数（识别之用）、采用序列化方式编号等</li><li><input disabled="" type="checkbox"> 对数据包进行压缩，例如gzip压缩</li><li><input disabled="" type="checkbox"> SPI 机制<br>…</li></ul><h2 id="3-图解说明"><a href="#3-图解说明" class="headerlink" title="3.图解说明"></a>3.图解说明</h2><p>下面是整个x-rpc的代码架构，基于maven构建</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-projects-desc.png" alt=""></p><p>正常在使用过程中，遵循如下顺序：</p><p>1.服务端启动 -&gt; 2.客户端启动 -&gt; 3.客户端服务端整个请求流程（包括客户端发送请求 -&gt; 服务端响应请求 -&gt; 客户端处理响应数据）</p><p>我们就来一一剖析，进一步理解rpc底层大概都干了啥</p><h3 id="3-1-服务端启动"><a href="#3-1-服务端启动" class="headerlink" title="3.1 服务端启动"></a>3.1 服务端启动</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverStartup.jpg" alt=""></p><ol><li>【具体操作】：通过rpc自定义注解@RpcService（@RpcScan属性basePackages范围内）找到所要发布的服务列表，通过扫描注册的方式将服务实例注入到spring bean中</li><li>【具体操作】：在服务实例初始化前，每个注册在spring的实例都会通过zookeeper客户端Curator创建持久节点注册服务，保存服务名和服务端地址，并对该节点进行监听，发生变化时</li><li>【具体操作】：使用ConcurrentHashMap和Set缓存已注册的服务列表，用于后续客户端获取服务列表使用</li><li>【具体操作】：创建启动Netty服务端，异步监控启动结果，添加shutdownHook用于应用关闭释放资源，服务端pipeline用于请求/响应信息的编解码、客户端请求处理等</li></ol><h3 id="3-2-客户端启动"><a href="#3-2-客户端启动" class="headerlink" title="3.2 客户端启动"></a>3.2 客户端启动</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-clientStartup.jpg" alt=""></p><ol><li>【具体操作】：通过@RpcScan属性basePackages，把该范围内的标识spring注解的类注入至spring bean；在bean初始化后，为标识了@RpcReference的属性添加proxy代理实例，之后调用该属性方法时会调用代理类的invoke方法</li><li>pipeline用于请求/响应信息的编解码、服务端响应结果处理等</li></ol><h3 id="3-3-整个调用流程"><a href="#3-3-整个调用流程" class="headerlink" title="3.3 整个调用流程"></a>3.3 整个调用流程</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-wholeRequestProcess.jpg" alt=""></p><blockquote><p>【server/client pipeline】：netty中的调用链，用到了设计模式中的责任链模式</p></blockquote><h2 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4.运行项目"></a>4.运行项目</h2><h3 id="4-1-将项目-clone-至本地"><a href="#4-1-将项目-clone-至本地" class="headerlink" title="4.1 将项目 clone 至本地"></a>4.1 将项目 clone 至本地</h3><pre class="line-numbers language-java"><code class="language-java">git clone https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>xuyikai1<span class="token operator">/</span>x<span class="token operator">-</span>rpc<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-部署运行zookeeper-3-5-8，推荐使用docker"><a href="#4-2-部署运行zookeeper-3-5-8，推荐使用docker" class="headerlink" title="4.2 部署运行zookeeper 3.5.8，推荐使用docker"></a>4.2 部署运行zookeeper 3.5.8，推荐使用docker</h3><p>下载：</p><pre class="line-numbers language-java"><code class="language-java">docker pull zookeeper<span class="token operator">:</span><span class="token number">3.5</span><span class="token punctuation">.</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-java"><code class="language-java">docker run <span class="token operator">-</span>d <span class="token operator">--</span>name zookeeper <span class="token operator">-</span>p <span class="token number">2181</span><span class="token operator">:</span><span class="token number">2181</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>zookeeper:3.5.8</p><h3 id="4-3-使用-maven-命令-install-整个x-rpc项目"><a href="#4-3-使用-maven-命令-install-整个x-rpc项目" class="headerlink" title="4.3 使用 maven 命令 install 整个x-rpc项目"></a>4.3 使用 maven 命令 install 整个x-rpc项目</h3><p>这里使用IDEA进行操作：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-mavenInstall.png" alt=""></p><h3 id="4-4-启动服务端"><a href="#4-4-启动服务端" class="headerlink" title="4.4 启动服务端"></a>4.4 启动服务端</h3><p>运行 rpc-example-server 中的 RpcServerTest1的<code>main()</code>方法启动服务端</p><p>服务端启动成功如图：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverStartupSuccess.png" alt=""></p><p>zookeeper节点情况：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-prettyZoo.png" alt=""></p><blockquote><p>zookeeper client使用的是 <a href="https://github.com/vran-dev/PrettyZoo">prettyZoo</a></p></blockquote><h3 id="4-5-启动客户端-发送请求"><a href="#4-5-启动客户端-发送请求" class="headerlink" title="4.5 启动客户端/发送请求"></a>4.5 启动客户端/发送请求</h3><p>运行 rpc-example-client 中的 RpcServerTest1的<code>main()</code>方法启动服务端</p><p>客户端启动/发送数据情况：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-clientStartupSuccess.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/x-rpc-serverReceiveRequestSuccess.png" alt=""></p><blockquote><p>这里测试demo中客户端发送了两次请求</p></blockquote><h2 id="5-源码"><a href="#5-源码" class="headerlink" title="5.源码"></a>5.源码</h2><p><a href="https://github.com/xuyikai1/x-rpc">GitHub - xuyikai1/x-rpc</a></p><h2 id="6-感谢"><a href="#6-感谢" class="headerlink" title="6.感谢"></a>6.感谢</h2><p>项目很多细节都是参考 javaGuide 的<a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a>，在这里表示感谢</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> rpc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpc </tag>
            
            <tag> netty </tag>
            
            <tag> protostuff </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShutdownHook钩子</title>
      <link href="/posts/shutdownHook.html"/>
      <url>/posts/shutdownHook.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用钩子shutdownHook优雅关闭资源"><a href="#使用钩子shutdownHook优雅关闭资源" class="headerlink" title="使用钩子shutdownHook优雅关闭资源"></a>使用钩子shutdownHook优雅关闭资源</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>这是一个笔者在造rpc轮子的时候诞生的需求，也是一个挺细节的小知识点。故写一篇blog用于记录。</p><p>这里先来简单讲一下rpc。rpc，远程方法调用，他旨在屏蔽了很多细节让我们调用远程方法和调用本地方法一样简单，目前存在的rpc框架就有<strong>dubbo</strong>、<strong>gRpc</strong>等</p><blockquote><p>想想平时对接第三方api时是不是经历http请求、序列化、拆箱校验、数据标准化装箱等操作呢</p></blockquote><p>而rpc在使用时也涉及道诸多系统资源的使用，例如线程池、注册中心（zookeeper等）等，当rpc服务端（服务提供方）停止服务时，是否也应该释放这些资源呢？</p><p>结果是必然的。想到这一层，需求就诞生了，经过多方寻找，类似于git + jenkins上的webHook，也就是shutdownHook钩子浮出水面</p><h2 id="2-shutdownHook"><a href="#2-shutdownHook" class="headerlink" title="2.shutdownHook"></a>2.shutdownHook</h2><p>这是JVM本身提供的功能，当 JVM 接受到系统的关闭通知之后，调用 ShutdownHook 内的方法，用以完成清理操作，从而平滑的退出应用，下面是示例代码：</p><p><strong>CustomShutdownHook.class</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomShutdownHook</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> CustomShutdownHook CUSTOM_SHUTDOWN_HOOK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CustomShutdownHook <span class="token function">getCustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> CUSTOM_SHUTDOWN_HOOK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">releaseResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"addShutdownHook for clearAll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addShutdownHook</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 1.删除服务端注册信息</span>            ZookeeperClient<span class="token punctuation">.</span><span class="token function">clearRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 2.关闭所有线程池</span>            ThreadPoolExecutorUtils<span class="token punctuation">.</span><span class="token function">shutDownAllThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>自定义的shutdownHook，用于关闭服务端在zookeeper上注册的信息以及线程池资源</p></blockquote><p><strong>RpcServer.class</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 校验</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 添加JVM钩子 用于应用关闭时 自动释放资源</span>        CustomShutdownHook<span class="token punctuation">.</span><span class="token function">getCustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">releaseResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 启动服务端</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>服务端启动时add自定义的ShutDownHook</p></blockquote><p><strong>关闭应用</strong></p><p>此方式支持在以下几种场景优雅停机:</p><ul><li><p>1.程序正常退出</p></li><li><p>2.使用System.exit()</p></li><li><p>3.终端使用Ctrl+C</p></li><li><p>4.使用Kill pid干掉进程</p></li></ul><h2 id="3-Tips"><a href="#3-Tips" class="headerlink" title="3.Tips"></a>3.Tips</h2><blockquote><p>摘自：<a href="https://zhuanlan.zhihu.com/p/82350423">Java中使用shutdownHook的一些注意事项</a></p></blockquote><p><strong>1. 不要使用kill -9来结束你的应用程序</strong></p><p>kill -9是操作系统的终极杀器，如果你使用kill -9的话，应用程序是没有任何发言权的，它只能选择默默退出，几乎可以肯定，shutdownHook不会被调用。</p><p><strong>2. shutdownHook涉及的方法应该尽量的短</strong></p><p>这个可能和操作系统有关系，不同的操作系统可能有不同的差异：</p><blockquote><p>When a computer shuts down, the final stage of the shutdown process sends every remaining process a SIGTERM, gives those processes a few seconds grace, then sends them a SIGKILL.</p></blockquote><p>也就是说，如果shutdownHook过长，可能方法还没执行完，进程就被操作系统强制杀掉了，这一点在addShutdownHook()的文档上也有提及:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">*</span> <span class="token operator">&lt;</span>p<span class="token operator">></span> Shutdown hooks should also finish their work quickly<span class="token punctuation">.</span>  When a<span class="token operator">*</span> program invokes <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> #exit exit<span class="token punctuation">}</span> the expectation is<span class="token operator">*</span> that the virtual machine will promptly shut down and exit<span class="token punctuation">.</span>  When the<span class="token operator">*</span> virtual machine is terminated due to user logoff or system shutdown the<span class="token operator">*</span> underlying operating system may only allow a fixed amount of time in<span class="token operator">*</span> which to shut down and exit<span class="token punctuation">.</span>  It is therefore inadvisable to attempt any<span class="token operator">*</span> user interaction or to perform a <span class="token keyword">long</span><span class="token operator">-</span>running computation in a shutdown<span class="token operator">*</span> hook<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. shutdownHook的方法应该是线程安全的</strong></p><p>这是因为，用户可能多次发送信号导致方法被不同的线程被多次调用，关于这一点文档也有说明：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">*</span> They should<span class="token punctuation">,</span> in<span class="token operator">*</span> particular<span class="token punctuation">,</span> be written to be thread<span class="token operator">-</span>safe and to avoid deadlocks insofar<span class="token operator">*</span> as possible<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>4. 关于shutdownHook方法的异常</strong></p><p>shutdownHook调用过程中产生的所有异常都会被忽略掉并且可能不会输出任何提示信息，因此程序可能蕴含了一个久久不能被发现的BUG导致你的shutdownHook无法被执行，在调用shutdownHook的过程中，一定要仔细检查你的代码，保证正确性。</p><p><strong>5. 某些场景下要提供at most once的保证</strong></p><p>这点其实是接第三点说的，就是你的shutdownHook可能被调用多次，但其实关闭一次就够了，多次调用可能会引发一些意想不到的异常。比如KafkaStream的close方法，就提供了这样的保证：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit timeUnit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Stopping Streams client with timeoutMillis = {} ms."</span><span class="token punctuation">,</span> timeUnit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>KafkaStreams<span class="token punctuation">.</span>State<span class="token punctuation">.</span>PENDING_SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Already in the pending shutdown state, wait to complete shutdown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ....</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用CAS操作来做这样的检查：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>ACTIVE<span class="token punctuation">,</span> CLOSED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// close here</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>【参考链接】：<br>1：<a href="https://zhuanlan.zhihu.com/p/340284353">微服务项目优雅上线、下线小技巧，你学废了吗</a><br>2：<a href="https://zhuanlan.zhihu.com/p/82350423">Java中使用shutdownHook的一些注意事项</a><br>3：<a href="https://zhuanlan.zhihu.com/p/86392065">ShutdownHook- Java 优雅停机解决方案</a><br>4：<a href="https://zhuanlan.zhihu.com/p/159298442">SpringBoot 2.3.0正式发布：优雅停机，配置文件位置新特性一览</a><br>5：<a href="https://zhuanlan.zhihu.com/p/265806389">Spring Boot 系列：最新版优雅停机详解</a><br>6：<a href="https://zhuanlan.zhihu.com/p/336252174">回调方法？钩子方法？模板模式？</a><br>7：<a href="https://mp.weixin.qq.com/s/EgbqwZ6BL-IJubr_Co4ZEg">拒绝 kill -9， SpringBoot 优雅停机详解！</a><br>8：<a href="https://blog.csdn.net/caide3/article/details/108782865">Java程序优雅关闭的两种方法</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常工作应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shutdownHook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot之自动配置原理</title>
      <link href="/posts/SpringBoot-autoConfiguration.html"/>
      <url>/posts/SpringBoot-autoConfiguration.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot之自动配置原理"><a href="#SpringBoot之自动配置原理" class="headerlink" title="SpringBoot之自动配置原理"></a>SpringBoot之自动配置原理</h1><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h2><p>创建SpringBoot项目时，都会默认创建一个Application启动类，并且标注着<code>@SpringBootApplication</code>注解。深入探究会发现<code>@SpringBootApplication</code>注解除了自定义注解经常出现的元注解外，主要还有三个注解标注：<code>@SpringBootConfiguration</code>、<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>，这三个注解可以说就是入口前的三把钥匙了，但是钥匙只有一把，所以我们不妨跟着其中的注释一一整理一番</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/SpringBootApplication.png" alt="SpringBootApplication"></p><blockquote><p><code>@SpringBootConfiguration</code>：再进入一层会发现就是我们配置类常用注解<code>@Configuration</code>，目的是<strong>使用JavaConfig的配置方式来代替XML的繁琐配置</strong></p></blockquote><blockquote><p><code>@ComponentScan</code>：扫描注解，默认是扫描当前类下的package。将Spring一些例如<code>@Controller</code>/<code>@Service</code>/<code>@Component</code>/<code>@Repository</code>等注解加载到IOC容器中。（备注：<code>@EnableAutoConfiguration</code>中的<code>@AutoConfigurationPackage</code>则是用来扫描一些其他组件注解的，比如Spring Data Jpa中的<code>@Entity</code>注解等）</p></blockquote><blockquote><p><code>@EnableAutoConfiguration</code>：自动配置核心注解，下文详细分析</p></blockquote><h2 id="2-EnableAutoConfiguration实现自动配置"><a href="#2-EnableAutoConfiguration实现自动配置" class="headerlink" title="2.@EnableAutoConfiguration实现自动配置"></a>2.<code>@EnableAutoConfiguration</code>实现自动配置</h2><blockquote><p>我们通过代码一步步抽丝剥茧</p></blockquote><h3 id="2-1-EnableAutoConfiguration注解"><a href="#2-1-EnableAutoConfiguration注解" class="headerlink" title="2.1 EnableAutoConfiguration注解"></a>2.1 EnableAutoConfiguration注解</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/EnableAutoConfiguration-annotation.png" alt="EnableAutoConfiguration"></p><blockquote><p>排除元注解和前面我们解释过的<code>@AutoConfigurationPackage</code>注解，可以看出，重点在于<code>@Import(AutoConfigurationImportSelector.class)</code>上。</p></blockquote><h3 id="2-2-自动配置链路分析"><a href="#2-2-自动配置链路分析" class="headerlink" title="2.2 自动配置链路分析"></a>2.2 自动配置链路分析</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/selectImports.png" alt="AutoConfigurationImportSelector.selectImports"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/getAutoConfigurationEntry.png" alt="getAutoConfigurationEntry"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/getCandidateConfigurations.png" alt="getCandidateConfigurations"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/loadFactoryNames.png" alt="SpringFactoriesLoader.loadFactoryNames"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring.factories.path.png" alt="/spring.factories.path"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring.factories.content.png" alt="spring.factories.content"></p><p>从上图和备注我们大致就可以理清自动配置的思路了，通过<strong>自动装配导入选择器</strong><code>AutoConfigurationImportSelector.class</code>来获取候选的一些自动配置项列表，这些自动配置项（127项）都以key为EnableAutoConfiguration统一存储在<strong>spring-boot-autoconfigure-x.x.x.x.jar的META-INF/spring.fatocies中</strong>。</p><h3 id="2-3-配置自动装配加载"><a href="#2-3-配置自动装配加载" class="headerlink" title="2.3 配置自动装配加载"></a>2.3 配置自动装配加载</h3><p>当然这些配置并不是全部127项都加载进去，而是按需分配，开发人员可以通过<code>@SpringBootApplication</code>的<strong>exclude属性</strong>来排除指定的配置项，再根据默认配置的<code>getConfigurationClassFilter()</code>方法获取到的过滤器过滤掉了，最后剩下23个默认配置项</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/Application-scanPackages-exclude.png" alt=""></p><blockquote><p><code>scanBasePackages</code>：扫描注解，默认是扫描当前类下的package。将Spring一些例如@Controller/@Service/@Component/@Repository等注解加载到IOC容器中。<br><code>exclude</code>：排除特定的自动配置类</p></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><ul><li>自动配置的核心是<code>@EnableAutoConfiguration</code>，SpringBoot在启动时会用SPI机制来加载spring.factories中的自动配置项，然后根据开发者的配置和默认配置筛选保留对应的配置进行加载。</li><li>自动配置功能保证了SpringBoot开箱即用的特点，省心省事</li></ul><blockquote><p>【参考链接】：<br>1：<a href="https://zhuanlan.zhihu.com/p/163685081">面试高频题：springboot自动装配的原理你能说出来吗？</a><br>2：<a href="https://zhuanlan.zhihu.com/p/55637237">SpringBoot自动配置原理</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的了解线程池吗</title>
      <link href="/posts/threadPool.html"/>
      <url>/posts/threadPool.html</url>
      
        <content type="html"><![CDATA[<h1 id="你真的了解线程池吗"><a href="#你真的了解线程池吗" class="headerlink" title="你真的了解线程池吗"></a>你真的了解线程池吗</h1><h2 id="1-new-Thread的弊端"><a href="#1-new-Thread的弊端" class="headerlink" title="1.new Thread的弊端"></a>1.new Thread的弊端</h2><ul><li>1：每次new Thread新建对象，性能差</li><li>2：线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或者OOM</li><li>3：缺少更多功能，如更多执行、定期执行、线程中断</li></ul><h2 id="2-线程池的意义"><a href="#2-线程池的意义" class="headerlink" title="2.线程池的意义"></a>2.线程池的意义</h2><ul><li>1：重用存在的线程，减少对象创建、消亡的的开销，性能佳</li><li>2：可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li><li>3：提供定时执行、定期执行、单线程、并发控制等功能</li><li>4：让线程一定程度上可管理</li></ul><h2 id="3-线程池参数"><a href="#3-线程池参数" class="headerlink" title="3.线程池参数"></a>3.线程池参数</h2><p>线程池类：<strong>ThreadPoolExecutor</strong>，参数最完整的构造方法如下图</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-params.png" alt=""></p><ul><li><strong>【coreThreadSize】</strong>：核心线程数量。类似公司的正式员工，在线程池公司中常年工作，除非设置了<strong>executor.allowCoreThreadTimeOut=true</strong>，否则线程一直运行着</li><li><strong>【maximumPoolSize】</strong>：最大线程数=核心线程数 + 非核心线程数</li><li><strong>【workQueue】</strong>：阻塞队列，当（很重要，会对线程池运行过程产生重大影响）</li><li><strong>【keepAliveTime】</strong>：线程空闲时，最多保持多久时间后终止，默认情况下，指的是非核心线程的空闲时间，如果设置executor.allowCoreThreadTimeOut为true也表示核心线程的空闲时间</li><li><strong>【unit】</strong>：keepAliveTime的时间单位</li><li><strong>【threadFactory】</strong>：线程工厂，用于创建线程</li><li><strong>【rejectHandler】</strong>：当拒绝处理任务时采用的策略</li></ul><blockquote><p><strong>1.非核心线程数</strong>：被临时抽调来的线程池以外的系统线程。满足以下条件时：（1）当线程池的核心线程都在工作时（2）阻塞队列满了或者阻塞队列为SynchronousQueue缓存队列（3）最大线程数&gt;核心数<br>当满足以上三个条件时，就会抽调池外线程（系统线程）来帮忙完成任务。任务完成后就会被回收<br><strong>2.executor.allowCoreThreadTimeOut=true</strong>：表示核心线程也会像非核心线程一样，在保持多久keepAliveTime空闲后，该线程消亡被回收</p></blockquote><p><strong>阻塞队列</strong>如下：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/blockingQueue.png" alt=""></p><blockquote><p><strong>【LinkedBlockingQueue】</strong>：不初始化容量则为无界队列。当线程池开始使用时，最开始会创建核心线程，当线程数达到设置的核心线程数时，会进入排队，因为属于无界队列，所以不会创建非核心线程。缺点：系统消耗高，因为任务可以无限排队，当流量非常大时，就会占用很多的内存，严重时可能会导致内存溢出</p></blockquote><blockquote><p><strong>【synchronousQueue】</strong>：无存储能力，一旦达到核心线程数之后，如果依然有比较多的任务进来，那么会尝试非核心线程，这时候maximumPoolSize要设置成比核心线程数更大的值才能生效</p></blockquote><p>日常工作的时候，上述这些参数中，我们需要着重注意以下三个参数：<strong>coreThreadSize</strong>、<strong>maximumPoolSize</strong>、<strong>workQueue</strong>，为什么呢？看看线程池任务调度执行流程吧</p><h2 id="4-线程池任务调度执行流程"><a href="#4-线程池任务调度执行流程" class="headerlink" title="4.线程池任务调度执行流程"></a>4.线程池任务调度执行流程</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-process.png" alt="执行流程"></p><p>执行过程如下：首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</p><ul><li><p>1.如果 <strong>当前活跃线程数 &lt; 核心线程数</strong> ，则创建并启动一个线程来执行新提交的任务。</p></li><li><p>2.如果 <strong>当前活跃线程数 &gt;= 核心线程数 且 线程池内的阻塞队列未满</strong> ，则将任务添加到该阻塞队列中。</p></li><li><p>3.如果 <strong>当前活跃线程数 &gt;= 核心线程数 且 当前活跃线程数 &lt; 最大线程数 且 线程池内的阻塞队列已满</strong> ，则创建并启动一个池外线程来执行新提交的任务。</p></li><li><p>4.如果 <strong>当前活跃线程数 &gt;= 最大线程数 且 线程池内的阻塞队列已满</strong> , 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</p></li></ul><blockquote><p>可以看出，线程池任务调度执行流程中，息息相关的就是核心线程数、最大线程数、以及阻塞队列这三个参数，他们的配置很大程度上影响着线程池处理任务的性能</p></blockquote><h2 id="5-线程池拒绝策略"><a href="#5-线程池拒绝策略" class="headerlink" title="5.线程池拒绝策略"></a>5.线程池拒绝策略</h2><p>当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-rejectHandler.png" alt="线程池拒绝策略"></p><p>日常开发中，一般有两种使用拒绝策略的方式</p><ol><li>采用 <strong>默认的拒绝策略AbortPolicy</strong> ，默认的拒绝策略可以及时的让系统抛出异常从而帮助开发人员定位问题</li><li>采用 <strong>自定义拒绝策略</strong> ，通过持久化磁盘或者消息队列的方式，把被拒绝的任务交给负载相对较低的服务器处理，保证 <strong>任务能100%被处理</strong></li></ol><h2 id="6-线程池使用场景"><a href="#6-线程池使用场景" class="headerlink" title="6 线程池使用场景"></a>6 线程池使用场景</h2><h3 id="6-1-场景一：侧重于高吞吐能力"><a href="#6-1-场景一：侧重于高吞吐能力" class="headerlink" title="6.1 场景一：侧重于高吞吐能力"></a>6.1 场景一：侧重于高吞吐能力</h3><p>当我们需要统计报表时，比如统计汇总各区域数据之后进行处理、生成报表。这种场景相对于相应数据，我们更关注于如何使用系统有限的资源，尽可能在一定的时间内完成更多的任务，也就是<strong>保证充分利用且不浪费系统资源</strong>。</p><p>这时候我们应该设置一定容量的阻塞队列，并且根据系统参数配置核心线程数和最大线程数，减少线程间切换开销</p><p><strong>阻塞队列</strong>：LinkedBlockingQueue（指定容量），有界的阻塞队列<br><strong>线程数</strong>：最大线程数 = 核心线程数 ，一般设置为CPU核数+1，+1的目的是防止CPU空跑</p><p><strong>【例子】</strong>：CPU为6核心6线程，则核心线程数为7，最大线程数为7，LinkedBlockingQueue阻塞队列容量为100</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *【线程池常用场景一】： * 阻塞队列为LinkedBlockingDeque有界阻塞队列（指定容量了），一般最大线程数和核心线程数相等 * 比如以下例子中，核心线程数为6，最大线程数为6 * 所以需要执行10个线程时，6个核心线程都在运行，会把接下来需要执行的任务存放到阻塞队列中 * 等线程执行完毕后，再去队列中获取任务继续执行 *【结果】：2个3s后 10个任务执行完毕 *【工作应用】： * 适用于实时性不会很强的业务解耦场景、比如异步发送通知、短信、异步生成报表等 *【优点】：吞吐量高 *【缺点】：在系统繁忙时，不保证实时性 * @param args */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span>            <span class="token number">6</span><span class="token punctuation">,</span>            <span class="token number">5</span><span class="token punctuation">,</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">NamedThreadFactory</span><span class="token punctuation">(</span><span class="token string">"demo-threadPool-"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提交10个任务给线程池执行 每个任务sleep 3秒</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 每1秒循环一次 已完成任务达到10时 跳出循环线程池关闭</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【--------------------场景一--------------------】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前活跃线程数】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前已经完成的任务数量】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前池中的线程数量】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> queue <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【阻塞队列包含任务数量】:{}"</span><span class="token punctuation">,</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行10个线程时，核心线程都在运行，会把接下来需要执行的任务存放到阻塞队列中，等线程任务执行完毕后再去队列中获取新的任务继续执行</p><h3 id="6-2-场景二：侧重于实时性-快速响应"><a href="#6-2-场景二：侧重于实时性-快速响应" class="headerlink" title="6.2 场景二：侧重于实时性 快速响应"></a>6.2 场景二：侧重于实时性 快速响应</h3><p>当用户进入一个页面时，页面聚合了多个服务的功能，可能开发会为了缩短响应时间，使用线程池去并行执行任务。这时候线程池就不应该设置阻塞队列来影响响应速度了，相对应的，建议提高核心线程数和最大线程数来增加并行线程的数量</p><p><strong>阻塞队列</strong>：SynchoronousQueue<br><strong>线程数</strong>：最大线程数 &gt; 核心线程数 </p><p>【例子】：CPU为6核心6线程，则核心线程数为1，最大线程数为10，阻塞队列为SynchoronousQueue也（队列容量为0）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 【线程池常用场景二】： *  阻塞队列为同步队列SynchronousQueue，不存储任务，一般与最大线程数搭配使用 *  比如以下例子中，核心线程数为1，最大线程数为10，最大线程数=核心线程数+非核心线程数 *  所以执行10个线程时，1个核心线程都在运行，会向系统借调线程（9个线程）来执行任务 * 【结果】：3s后 10个任务执行完毕 * 【工作应用】： *  适用于不影响主流程快速返回结果，但是也需要线程能快速处理好任务的场景 *  比如我司的支付回调后启动设备 * 【优点】：能更快速的处理完任务 * 【缺点】：系统性能和线程池吞吐量会受到一定影响 * @param args */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>            <span class="token number">10</span><span class="token punctuation">,</span>            <span class="token number">5</span><span class="token punctuation">,</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">NamedThreadFactory</span><span class="token punctuation">(</span><span class="token string">"demo-threadPool-"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提交10个任务给线程池执行 每个任务sleep 3秒</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 每1秒循环一次 已完成任务达到10时 跳出循环线程池关闭</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【--------------------场景二--------------------】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前活跃线程数】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前已经完成的任务数量】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【当前池中的线程数量】:{}"</span><span class="token punctuation">,</span> executor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> queue <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【阻塞队列包含任务数量】:{}"</span><span class="token punctuation">,</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要执行10个任务，此时1个核心线程在运行，会从池外（系统）抽调线程来运行剩余任务</p><h3 id="6-3-Spring-TaskExecutor快速实现自定义线程池"><a href="#6-3-Spring-TaskExecutor快速实现自定义线程池" class="headerlink" title="6.3 Spring TaskExecutor快速实现自定义线程池"></a>6.3 Spring TaskExecutor快速实现自定义线程池</h3><p>Spring集成了一个开箱即用的线程池接口以及多种实现类，这里我们举例其中的<strong>ThreadPoolTaskExecutor</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-taskExecutor-impl.png" alt=""></p><p><strong>配置类：TaskExecutorConfig.java</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskExecutorConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 构建一个demo线程池     * 测试类在 TaskExecutorTest     * @return     */</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"demoTaskExecutor"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> TaskExecutor <span class="token function">buildDemoExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置核心线程数</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置最大线程数</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"taskExecutor-demo-thread-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置队列容量 默认容量为Integer.MAX_VALUE 不建议设置为默认值 极端场景会导致OOM</span>        <span class="token comment" spellcheck="true">// 容量大于0：LinkedBlockingQueue 等于0：SynchronousQueue</span>        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试/使用类：TaskExecutorTest</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes<span class="token operator">=</span><span class="token punctuation">{</span>ThreadPoolDemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskExecutorTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"demoTaskExecutor"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> TaskExecutor taskExecutor<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        taskExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程开始休眠"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程休眠结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【测试异步线程池】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以看到，前面介绍的三个重要参数，我们都可以在配置类中指定，并且可以为线程池命名，可以说是非常方便了</p></blockquote><h2 id="7-JUC之Executors类（强烈不推荐使用）"><a href="#7-JUC之Executors类（强烈不推荐使用）" class="headerlink" title="7.JUC之Executors类（强烈不推荐使用）"></a>7.JUC之Executors类（强烈不推荐使用）</h2><p>java.util.concurrent包中为开发者提供了快速创建线程池的方法，如图：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-Executors.png" alt=""></p><blockquote><p>使用这种快速创建线程池的方法虽然极为省事快捷，但是不利于开发人员进一步了解线程池相关知识，也带来了隐患。</p></blockquote><ul><li>1：<strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li>2：<strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul><h2 id="8-线程池技巧与调优"><a href="#8-线程池技巧与调优" class="headerlink" title="8.线程池技巧与调优"></a>8.线程池技巧与调优</h2><h3 id="8-1-任务类型合理配置线程个数"><a href="#8-1-任务类型合理配置线程个数" class="headerlink" title="8.1 任务类型合理配置线程个数"></a>8.1 任务类型合理配置线程个数</h3><p><strong>（1）CPU 密集型任务 = N（CPU 核心数） + 1</strong></p><blockquote><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。<br>【适用场景】：数字计算、排序、挖矿等等</p></blockquote><p><strong>（2）IO 密集型任务 = 2N（CPU核心数）</strong> </p><blockquote><p>这种任务应用起来，系统会用大部分的时间来处理 I\O 交互，而线程在处理 I\O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I\O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。<br>【适用场景】：操作数据库、文件等</p></blockquote><p><strong>（3）混合型任务</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadpool-mixedTask.png" alt=""></p><blockquote><p>详细计算可查看这篇博客：<a href="https://blog.csdn.net/feilang00/article/details/95940059">如何合理地估算线程池大小？</a></p></blockquote><h3 id="8-2-调优小技巧与Tips"><a href="#8-2-调优小技巧与Tips" class="headerlink" title="8.2 调优小技巧与Tips"></a>8.2 调优小技巧与Tips</h3><p><strong>线程池抉择</strong></p><ol><li><p>如果想要<strong>降低系统资源的消耗</strong>（cpu使用率，操作系统资源消耗，上下文切换开销），那么可以设置一个比较大的队列容量和一个比较小的线程池容量</p></li><li><p>如果<strong>队列经常堆积比较多的任务</strong>，并且业务方面需要加快处理速度时，可以适当加大maximumPoolSize，找一些池外线程（临时工）帮忙</p></li></ol><p><strong>Timer与ScheduledThreadPoolExecutor的区别</strong></p><p>  timer是单线程的，如果一个线程执行时间很长，会影响下一个执行线程，实际项目中尽可能用ScheduledThreadPoolExecutor，慎用Timer</p><p><strong>线程池自定义命名小技巧</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// guava</span><span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">"my-thread-pool-%d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// hutoolnew NamedThreadFactory("my-thread-pool-", false)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>ScheduledThreadPoolExecutor</strong></p><p>继承了ThreadPoolExecutor，一般被用来当做延迟队列线程池使用，但是仔细查看他的构造函数可以发现，<strong>最大线程数maximumPoolSize都被设置成默认的Integer.MAX_VALUE</strong>，生产环境上容易造成OOM或者导致服务器性能下降，建议使用消息队列中的延迟队列代替</p><h3 id="8-3-线程池参数动态化"><a href="#8-3-线程池参数动态化" class="headerlink" title="8.3 线程池参数动态化"></a>8.3 线程池参数动态化</h3><p>业务与流量不会总是一成不变的，当初合理的配置可能也会在突发的巨大流量面前兵败如山倒，固定的线程池配置亦是如此，满足当时，却可能顶不住未来。为此，美团团队在博客中提到了<strong>线程池参数动态化</strong>的思路，非常值得精读！</p><p><a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">Java线程池实现原理及其在美团业务中的实践</a></p><h2 id="9-线程池灵魂拷问"><a href="#9-线程池灵魂拷问" class="headerlink" title="9.线程池灵魂拷问"></a>9.线程池灵魂拷问</h2><h3 id="9-1-当线程池里的线程执行异常会发生什么？"><a href="#9-1-当线程池里的线程执行异常会发生什么？" class="headerlink" title="9.1 当线程池里的线程执行异常会发生什么？"></a>9.1 当线程池里的线程执行异常会发生什么？</h3><p>一个线程出现异常不会影响线程池里面其他线程的正常执行，该异常线程不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。</p><p><strong>异常线程是否会打印异常信息</strong></p><ol><li>调用方法为 <strong>execute()</strong> ，会打印出堆栈异常日志</li><li>调用方法为 <strong>submit()</strong> ，堆栈异常没有输出。但是如果业务需要获取线程返回值，调用了<strong>Future.get()方法</strong>时，可以捕获打印出堆栈异常信息。而很多时候我们可能并不需要获取执行结果，导致异常“被吃”，进而不触发告警信息酿成大祸，<strong>所以个人不建议使用</strong><code>submit()</code>。</li></ol><blockquote><p>两者在使用日志工具打印自定义日志都比较困难，所以个人更推荐结合<strong>jdk8的新特性CompletableFuture</strong>，搭配线程池一起使用，详情可以查看这篇文章：<a href="http://xuyk.top/posts/async.html">如何优雅地异步编程 </a></p></blockquote><h3 id="9-2-如果线上突然宕机，阻塞队列中的任务怎么办？"><a href="#9-2-如果线上突然宕机，阻塞队列中的任务怎么办？" class="headerlink" title="9.2 如果线上突然宕机，阻塞队列中的任务怎么办？"></a>9.2 如果线上突然宕机，阻塞队列中的任务怎么办？</h3><p><strong>阻塞队列中的所有任务会丢失</strong></p><p><strong>保证任务不丢失的思路</strong></p><ol><li>我们可以在提交任务前先进行落库处理，当宕机重启后，再拿出待处理的任务继续执行。</li><li>使用消息队列</li></ol><h3 id="9-3-你知道如果线程池的队列满了之后会发生什么事情吗？"><a href="#9-3-你知道如果线程池的队列满了之后会发生什么事情吗？" class="headerlink" title="9.3 你知道如果线程池的队列满了之后会发生什么事情吗？"></a>9.3 你知道如果线程池的队列满了之后会发生什么事情吗？</h3><p>关键在于 <strong>线程池当前活跃线程数</strong> 与 <strong>最大线程数</strong> 的对比</p><ol><li>线程池当前活跃线程数 &lt; 最大线程数，则线程池会抽调 池外线程（系统线程）来处理任务</li><li>线程池当前活跃线程数 &gt;= 最大线程数，会根据线程池的拒绝策略来处理任务</li></ol><p><strong>保证任务100%被处理的思路</strong>： 自定义拒绝策略，把任务交给其他负载低的线程池进行处理，或者放入消息队列交给其他线程池处理 / 阻塞队列处理完毕后处理消息队列中的任务</p><h2 id="10-线程池demo"><a href="#10-线程池demo" class="headerlink" title="10.线程池demo"></a>10.线程池demo</h2><p>如果想快速上手的话，可以试试我github上的demo，链接如下：<br><a href="https://github.com/xuyikai1/Java-Trivia">Java-Trivia：thread-pool-demo</a></p><blockquote><p>【参考链接】：<br>1：<a href="https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答</a><br>2：<a href="https://mp.weixin.qq.com/s/wrTVGLDvhE-eb5lhygWEqQ">有的线程它死了，于是它变成一道面试题</a><br>3：<a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">Java线程池实现原理及其在美团业务中的实践</a><br>4：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/%E6%8B%BF%E6%9D%A5%E5%8D%B3%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.md">拿来即用的线程池最佳实践 JavaGuide</a><br>5：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.md">java线程池学习总结 JavaGuide</a><br>6：<a href="https://zhuanlan.zhihu.com/p/170320272">线程池的execute方法和submit方法有什么区别？</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅地异步编程</title>
      <link href="/posts/async.html"/>
      <url>/posts/async.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何优雅地异步编程"><a href="#如何优雅地异步编程" class="headerlink" title="如何优雅地异步编程"></a>如何优雅地异步编程</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>还得到刚毕业呆的第一家公司，是做医疗软件的。大家可能有所了解，因为年代比较久远，也为了稳定长久运行，医疗软件一般都是使用以前的技术框架来做，比如整体框架SSH，部署是远程windows手动的等。我在码代码的时候，有的代码就会看到new Thread。现在想想，得亏并发不高线上没啥问题。</p><p>可能有的兄弟就有疑问了，我业务照样走，new Thread会有什么不妥？我们又应该如何正确的进行异步编程呢？以下我就用一个个demo来分析和理解（大佬有更好的意见欢迎留言建议指正）</p><blockquote><p>以下使用api + postman的方式进行demo演示</p></blockquote><h2 id="1-错误之源-new-Thread"><a href="#1-错误之源-new-Thread" class="headerlink" title="1.错误之源 new Thread"></a>1.错误之源 new Thread</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/oldAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">oldAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"古老版本的线程使用方法，浪费线程资源，线程缺乏管理，性能差，坚决不用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"thread sleep end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/new%20Thread%20disadvantages.png" alt=""></p><blockquote><p>看到这么多弊端的我们应该知道这货不能用</p></blockquote><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h2><p>平常我们在公众号文章看到的<strong>池化</strong>，大部分指的就是使用线程池来合理使用线程，完成异步编程任务。当然，线程池可不止这些好处，如下图：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/threadPool%20advantages.png" alt=""></p><blockquote><p>其中说的定时/定期执行涉及 ScheduledThreadPoolExecutor，大家也可以查询了解一下 </p></blockquote><h3 id="2-1-Executors类快速创建线程池"><a href="#2-1-Executors类快速创建线程池" class="headerlink" title="2.1 Executors类快速创建线程池"></a>2.1 Executors类快速创建线程池</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/executors"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executors</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        Executors.newCachedThreadPool();</span><span class="token comment" spellcheck="true">//        Executors.newFixedThreadPool(2);</span>    executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【不关心返回值】，不推荐使用Executors的方式创建线程池"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"thread sleep end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>很多时候，为了方便，会使用Executors类来快速创建线程池，但是在重点业务或者高并发的场景下，这样创建出来的线程池就会有很大的隐患，这里并不推荐这样的方式创建线程池。</p></blockquote><p><strong>不推荐Executors创建线程池的理由</strong> ：</p><ul><li>1：<strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li>2：<strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li><li>3：无法根据业务需求来自定义线程池参数，无法为线程池命名，定位问题困难</li></ul><h3 id="2-2-自定义线程池"><a href="#2-2-自定义线程池" class="headerlink" title="2.2 自定义线程池"></a>2.2 自定义线程池</h3><blockquote><p>建议在不同的业务线上使用不同的自定义线程池</p></blockquote><h4 id="2-2-1-自定义线程池配置类-ThreadPoolConfig-class"><a href="#2-2-1-自定义线程池配置类-ThreadPoolConfig-class" class="headerlink" title="2.2.1 自定义线程池配置类 ThreadPoolConfig.class"></a>2.2.1 自定义线程池配置类 ThreadPoolConfig.class</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolConfig</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String THREAD_POOL_NAME_PREFIX <span class="token operator">=</span> <span class="token string">"demo-thread-pool"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_POOL_CORE_THREAD_SIZE <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_POOL_MAX_THREAD_SIZE <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_POOL_KEEP_ALIVE_TIME <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_POOL_QUEUE_CAPACITY <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ExecutorService <span class="token function">createThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span>THREAD_POOL_NAME_PREFIX <span class="token operator">+</span> <span class="token string">"-%d"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                THREAD_POOL_CORE_THREAD_SIZE<span class="token punctuation">,</span>                THREAD_POOL_MAX_THREAD_SIZE<span class="token punctuation">,</span>                THREAD_POOL_KEEP_ALIVE_TIME<span class="token punctuation">,</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>THREAD_POOL_QUEUE_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">,</span>                factory<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyAbortPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>        <span class="token function">MyAbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span>                    <span class="token string">"【线程默认饱和策略】:"</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"线程被"</span> <span class="token operator">+</span> executor<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"线程执行器拒绝"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们一般是通过 <strong>ThreadPoolExecutor</strong> 的构造函数来创建线程池，然后提交任务给线程池执行就可以了。</p><p><strong>ThreadPoolExecutor</strong> 构造函数如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池的核心线程数量</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池的最大线程数</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>                          TimeUnit unit<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//时间单位</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//任务队列，用来储存等待执行任务的队列</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程工厂，用来创建线程，一般默认即可</span>                          RejectedExecutionHandler handler<span class="token comment" spellcheck="true">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>                           <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-线程池使用"><a href="#2-2-2-线程池使用" class="headerlink" title="2.2.2 线程池使用"></a>2.2.2 线程池使用</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> ExecutorService executorService<span class="token punctuation">;</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/threadPoolAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">threadPoolAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【不关心返回值】，日常使用注意合理配置线程池参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"thread sleep end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>线程池在配置时需要结合业务点进行参数配置，但使用起来还是很方便的。<br>线程池时常可以应用于单应用或者业务解耦的场景，例如，支付成功在第三方支付回调流程中异步发送短信通知服务告知消费者等，减少主流程花费时间</p></blockquote><h3 id="2-3-线程池实践知识点"><a href="#2-3-线程池实践知识点" class="headerlink" title="2.3 线程池实践知识点"></a>2.3 线程池实践知识点</h3><p>实际使用中需要根据自己机器的性能、业务场景来<strong>手动配置线程池的参数</strong>比如核心线程数、使用的任务队列、饱和策略等等。</p><p><strong>线程数设置</strong></p><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)</strong>： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)</strong>： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><p><strong>线程池命名</strong></p><p>每个业务线需要线程池时最好都各自使用对应的线程池，防止互相影响，线程池命名可根据业务进行命名，方便调试定位问题</p><h3 id="2-4-线程池获取结果"><a href="#2-4-线程池获取结果" class="headerlink" title="2.4 线程池获取结果"></a>2.4 线程池获取结果</h3><p>线程池在使用<code>submit()</code>方法时,会返回<code>Future</code>类型（实际为<code>FutureTask</code>类型）的结果</p><p><strong>获取线程执行方法的返回结果</strong></p><p>当我们需要获取线程执行结束返回的结果时，就可以通过Future来获取，实际使用如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/threadPoolFutureAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">threadPoolFutureAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    Future<span class="token operator">&lt;</span>String<span class="token operator">></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【关心返回值】，日常使用注意合理配置线程池参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"returnVal"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        String result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Future同步阻塞当前线程来获取返回值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"缺点：需要catch异常处理，代码不够优雅，当前线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Future result:{}"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> ExecutionException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"线程异常:{}"</span><span class="token punctuation">,</span>ExceptionUtil<span class="token punctuation">.</span><span class="token function">stacktraceToString</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上述代码，当我们使用postman调用此api时，主线程会通过<strong>同步阻塞</strong>的方式来等待获取异步线程返回结果（这种方式被经常成为假异步），当笔者第一次使用这种方式获取结果时，着实很困惑，既然还会阻塞我还不如直接同步进行，还省个线程..无法忍受之后就去找解决办法了（就是等会之后介绍的思路用法）<br><strong>当我们需要获取异步线程的返回值时，不建议使用Future来获取</strong></p></blockquote><h2 id="3-Spring-Async"><a href="#3-Spring-Async" class="headerlink" title="3.Spring @Async"></a>3.Spring <code>@Async</code></h2><p>异步编程，大名鼎鼎的Spring当然也来掺一脚，我们先来看下示例：</p><p><strong>AnnotationAsyncService.java</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@EnableAsync</span> <span class="token comment" spellcheck="true">// @Async注解需要先使用该注解来开启功能</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationAsyncService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Async</span><span class="token punctuation">(</span><span class="token string">"testThreadPool"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 指定线程池，若无指定则使用默认创建的线程池执行</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAnnotationMethod</span><span class="token punctuation">(</span>String param<span class="token punctuation">,</span>Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【关心返回值】，日常使用注意合理配置线程池参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为了灵活测试使用的参数param</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"测试异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>AsyncController.java</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> AnnotationAsyncService asyncService<span class="token punctuation">;</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/annotationAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">annotationAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"param"</span><span class="token punctuation">)</span> String param<span class="token punctuation">,</span>                            <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    asyncService<span class="token punctuation">.</span><span class="token function">testAnnotationMethod</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span> sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"annotationAsync Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用<code>@Async</code>要点</strong></p><ul><li><code>@Async</code>也是通过AOP（切面）实现的，与<code>@Transactional</code>相同</li><li>添加<code>@Async</code>注释的方法必须是<strong>public</strong>。因为AOP的本质是动态代理，动态代理要求方法必须是public</li><li><code>@Async</code>必须是<strong>跨类调用</strong>，原因也是同类直接调用无法被动态代理（导致会调用对象本身的方法而不是代理类的方法）</li><li>需要添加@EnableAsync注解</li><li>使用<code>@Async</code>的类需要被Spring所管理，即需要标注<code>@Component</code></li><li><code>@Async</code>标注的方法必须返回void或者Future</li><li>建议设置BlockingQueue的大小，默认设置容量为Integer.MAX_VALUE，也就是无界队列，可能会任务堆积导致内存溢出（容量大于0时<code>@Async</code>绑定的线程池队列为LinkedBlockingQueue，否则为SynchrousQueue），</li></ul><blockquote><p>其实<code>@Async</code>也有获取返回值的功能，但是因为同样是同步阻塞式获取，这里就不展示了。<br>代码上看，注解用起来还是很爽的。当异步方法出现异常时，我们可以配置来捕获异常友好输出到日志，这里需要进行额外配置，配置如下</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncExceptionConfig</span> <span class="token keyword">implements</span> <span class="token class-name">AsyncConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> AsyncUncaughtExceptionHandler <span class="token function">getAsyncUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringAsyncExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">SpringAsyncExceptionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">AsyncUncaughtExceptionHandler</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleUncaughtException</span><span class="token punctuation">(</span>Throwable throwable<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> objects<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"------我是Async无返回方法的异常处理方法---------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Guava-ListenableFuture"><a href="#4-Guava-ListenableFuture" class="headerlink" title="4.Guava ListenableFuture"></a>4.Guava ListenableFuture</h2><p>他来了她来了，他迈着大步走来了。前面我们提到，jdk为我们留下的疑难杂症：<strong>Future同步阻塞来获取异步线程返回值</strong>。</p><p>谷歌的开发人员给出了他们的答案 – <strong>Guava ListenableFuture</strong>，看到这个名称，大伙应该心里有了个想法，没错，就是常用的<strong>监听、回调</strong>的思路，如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/threadPoolGuavaAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">threadPoolGuavaFutureAsync</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"param"</span><span class="token punctuation">)</span> String param<span class="token punctuation">,</span>                                       <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    <span class="token comment" spellcheck="true">// guava在线程池上包装一层监听器</span>    ListeningExecutorService listenServicePool <span class="token operator">=</span> MoreExecutors<span class="token punctuation">.</span><span class="token function">listeningDecorator</span><span class="token punctuation">(</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListenableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> listenableFuture <span class="token operator">=</span> listenServicePool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【关心返回值】，日常使用注意合理配置线程池参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为了灵活测试使用的参数param</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"测试异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"returnVal"</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为指定线程池线程 新增回调函数</span>    Futures<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>listenableFuture<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FutureCallback</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> String result<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 成功</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Guava result:{}"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFailure</span><span class="token punctuation">(</span>Throwable t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 异常</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"系统异常:{}"</span><span class="token punctuation">,</span>ExceptionUtil<span class="token punctuation">.</span><span class="token function">stacktraceToString</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>listenServicePool<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这一做法完美地解决了同步阻塞获取结果的问题，我们可以使用<br>不过单单从代码量角度，下面<strong>jdk1.8</strong>的<code>completableFuture</code>则更胜一筹</p></blockquote><h2 id="5-JDK1-8-CompletableFuture"><a href="#5-JDK1-8-CompletableFuture" class="headerlink" title="5.JDK1.8 CompletableFuture"></a>5.JDK1.8 CompletableFuture</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/completableFutureAsync"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">completableFuture</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"param"</span><span class="token punctuation">)</span> String param<span class="token punctuation">,</span>                              <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepMillTime"</span><span class="token punctuation">)</span> Integer sleepMillTime<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 业务代码</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> future <span class="token operator">=</span> CompletableFuture            <span class="token comment" spellcheck="true">// 异步发起话费充值</span>            <span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">completableTest</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span> sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">,</span>executorService<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 记录异常</span>            <span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>throwable <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"【系统异常】:{}"</span><span class="token punctuation">,</span>ExceptionUtil<span class="token punctuation">.</span><span class="token function">stacktraceToString</span><span class="token punctuation">(</span>throwable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token string">"error"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> String <span class="token function">completableTest</span><span class="token punctuation">(</span>String param<span class="token punctuation">,</span>Integer sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"线程池异步【关心返回值】，日常使用注意合理配置线程池参数，线程池名称:{}"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为了灵活测试使用的参数param</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"测试异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepMillTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"CompletableFuture result"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码优雅，可读性高，还不知道选啥嘛！<br>两个字，舒服！</p></blockquote><h2 id="6-demo代码"><a href="#6-demo代码" class="headerlink" title="6.demo代码"></a>6.demo代码</h2><p><a href="https://github.com/xuyikai1/JavaDemo">JavaDemo：async-demo</a></p><blockquote><p>【参考链接】：<br>1：<a href="https://zhuanlan.zhihu.com/p/42682411">浅谈Java Future - 知乎</a><br>2：<a href="https://zhuanlan.zhihu.com/p/101716685">CompletableFuture：让你的代码免受阻塞之苦</a><br>3：<a href="https://zhuanlan.zhihu.com/p/146336940">你还在写同步程序？Java异步编程了解一下</a><br>4：<a href="https://zhuanlan.zhihu.com/p/42470582">浅谈Java异步编程 - 知乎</a><br>5：<a href="https://mp.weixin.qq.com/s/RZqv0jkq644KcGBHaz7lUA">笑了，面试官问我知不知道异步编程的Future</a><br>6：<a href="https://segmentfault.com/a/1190000022069911">guava并发工具</a><br>7：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/%E6%8B%BF%E6%9D%A5%E5%8D%B3%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.md">拿来即用的线程池最佳实践</a><br>8：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a><br>9：<a href="https://mp.weixin.qq.com/s/RcPWPkbiuKZsjbhAMS8Ppw">异步线程CompletableFuture让你的代码速度快到飞起</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aop切面与自定义注解的日常应用</title>
      <link href="/posts/aop.html"/>
      <url>/posts/aop.html</url>
      
        <content type="html"><![CDATA[<h1 id="Aop切面与自定义注解的日常应用"><a href="#Aop切面与自定义注解的日常应用" class="headerlink" title="Aop切面与自定义注解的日常应用"></a>Aop切面与自定义注解的日常应用</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>众所周知，AOP真的是面试里老生常谈的技术点..想当年毕业找工作时，10场面试里7.8场都问AOP。大学毕业前，你肯定怎么都想不到，这辈子会被三个字母搞的晕头转向，脑瓜子嗡嗡的。而如今混了几年的我，决定手撕了他..的表皮，拿来做灵活的日常开发小助手。</p><h2 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2.AOP"></a>2.AOP</h2><p>我们先来聊聊AOP这个知识点。AOP，面向切面编程，我们可以把例如<strong>日志管理、事务处理、权限控制</strong>等这样的公用模块封装起来，通过切面的方式嵌入到业务代码中，降<strong>低系统耦合度，也提升了系统的可扩展性和可维护性</strong>。</p><blockquote><p>日常使用中，大家可以想到<code>@Transaction</code>事务注解。<br>框架源码里，也有很多例子。例如<strong>Alibaba Sentinel</strong>有代码形式的限流和注解形式的限流，其中注解形式的限流就是用到AOP切面的思想，Around环绕来实现<strong>限流</strong></p></blockquote><p>AOP是基于<strong>动态代理</strong>的：</p><p><strong>JDK Proxy</strong>：如果要代理的对象，实现了某个接口，那么Spring AOP会使用 <strong>JDK Proxy</strong>，去创建代理对象;</p><p><strong>Cglib</strong>：对于没有实现接口的对象，就无法使用JDK Proxy 去进行代理了，这时候Spring AOP会使用 <strong>Cglib</strong>，Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：</p><blockquote><p>【面试题】：Spring AOP的实现原理是什么？<br>你可以首先用一句话回答，“Spring AOP是通过JDK的动态代理和CGLIB框架实现的”；然后进一步展开，讲述JDK动态代理和CGLIB的实现原理，“JDK动态代理的实现原理是在运行期目标类加载后，为接口动态生成代理类，将切面植入到代理类中；CGLIB的实现原理是在运行期动态生成一个要代理类的子类，将切面逻辑加入到子类中，子类重写要代理的类的所有不是final的方法。”</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-proxy.jpg" alt=""></p><p>使用AOP的选择有两种：<strong>Spring AOP</strong> 和 <strong>AspectJ AOP</strong>，Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>一般情况下，<strong>我们选择AspectJ AOP即可，他在切面多的情况下性能更高</strong>。</p><h2 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3.自定义注解"></a>3.自定义注解</h2><p>我们从业务角度想想，既然不是每个接口都打上log，而是通过AOP切面的方式来记录，那么肯定有一个<strong>通用模版或者说通用标识</strong>对吧？比如前面提到的<code>@Transaction</code>事务注解，我们要实现自己的业务，当然也搞个自己喜欢的注解，这里就用<code>@RequestLog</code>表示<strong>系统需要对请求打Log</strong>。</p><p>命名完了，我们是不是需要打Log这个动作做一些限制呢？比如我只让他在方法级别上打Log，这里就用到了元注解（注解的注解）<code>@Target(ElementType.METHOD)</code>。</p><p>限制完了，我们是不是可以打Log这个动作做一些备注或者记录呢？比如打Log的方法作用描述，让日志更友好，这里就用到了<strong>我们平时写实体类中的属性一样的东西</strong>（只不过换了种表现形式，这里用的是方法）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 描述 默认空字符串</span>String <span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>备注记录完了，那么如何把日志打上呢？我们就需要在这个方法执行的前后做点手脚，比如获取到被我们注解标注的方法啦，请求的参数、花费的时间啥的，拿到这些信息后打印记录下来。这里应运而生的就是切面类 <strong>RequestLogAop</strong> 了。</p><blockquote><p>自定义注解的小（冷）知识挺多也挺细节的，我这里就简单介绍一下我们即将用到的。实战搞定后，大家可以查看底部的参考链接来了解自定义注解</p></blockquote><h2 id="4-实战"><a href="#4-实战" class="headerlink" title="4.实战"></a>4.实战</h2><h3 id="4-1-依赖"><a href="#4-1-依赖" class="headerlink" title="4.1 依赖"></a>4.1 依赖</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>aop<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">2.3</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>projectlombok<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>lombok<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.18</span><span class="token punctuation">.</span><span class="token number">12</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>cn<span class="token punctuation">.</span>hutool<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>hutool<span class="token operator">-</span>all<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">5.4</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>redisson<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>redisson<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">3.13</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-入参日志Log"><a href="#4-2-入参日志Log" class="headerlink" title="4.2 入参日志Log"></a>4.2 入参日志Log</h3><h4 id="1-自定义注解-RequestLog"><a href="#1-自定义注解-RequestLog" class="headerlink" title="1.自定义注解@RequestLog"></a>1.自定义注解<code>@RequestLog</code></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">RequestLog</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 描述     * @return     */</span>    String <span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>1：<code>@Retention(RetentionPolicy.RUNTIME)</code>：运行时可以使用该注解标识目标（这里具体指方法）<br>2：<code>@Target(ElementType.METHOD)</code>：此注解标识在方法上<br>3：<code>@Documented</code>：用于制作文档<br>4：<code>@interface</code>：用来定义注解，类似于interface用于定义接口<br>5：<strong>desc()</strong>：可以理解为该注解的属性</p></blockquote><h4 id="2-日志封装类-RequestLogInfo"><a href="#2-日志封装类-RequestLogInfo" class="headerlink" title="2.日志封装类 RequestLogInfo"></a>2.日志封装类 RequestLogInfo</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Builder</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestLogInfo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 请求链接     */</span>    <span class="token keyword">private</span> String requestUri<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 接口描述     */</span>    <span class="token keyword">private</span> String apiDesc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求类型     */</span>    <span class="token keyword">private</span> String requestType<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * HTTP请求方法     */</span>    <span class="token keyword">private</span> String httpMethod<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Class路径方法     */</span>    <span class="token keyword">private</span> String classMethod<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求IP     */</span>    <span class="token keyword">private</span> String requestIp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求参数     */</span>    <span class="token keyword">private</span> String requestParams<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 花费时间 单位毫秒(ms)     */</span>    <span class="token keyword">private</span> Long costTimeMillis<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 接口返回结果     */</span>    <span class="token keyword">private</span> String result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>用于记录信息用的封装类</p></blockquote><h4 id="3-日志切面类-RequestLogAop"><a href="#3-日志切面类-RequestLogAop" class="headerlink" title="3.日志切面类 RequestLogAop"></a>3.日志切面类 RequestLogAop</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span> <span class="token comment" spellcheck="true">// 标识这是一个切面</span><span class="token annotation punctuation">@Slf4j</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestLogAop</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 被 @requestLog 所注解的切点     * @param requestLog     */</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(requestLog)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestLogPointcut</span><span class="token punctuation">(</span>RequestLog requestLog<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 环绕增强     * @param pjp     * @param requestLog     */</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"requestLogPointcut(requestLog)"</span><span class="token punctuation">,</span> argNames <span class="token operator">=</span> <span class="token string">"pjp,requestLog"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">around</span><span class="token punctuation">(</span>ProceedingJoinPoint pjp<span class="token punctuation">,</span> RequestLog requestLog<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 请求信息</span>        ServletRequestAttributes requestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span>ServletRequestAttributes<span class="token punctuation">)</span> RequestContextHolder<span class="token punctuation">.</span><span class="token function">currentRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpServletRequest request <span class="token operator">=</span> requestAttributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用包装类目的为了减少多请求情况下 日志串行的问题</span>        RequestLogInfo info <span class="token operator">=</span> RequestLogInfo<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestUri</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiDesc</span><span class="token punctuation">(</span>requestLog<span class="token punctuation">.</span><span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">httpMethod</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span>pjp<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaringTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span>pjp<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestIp</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getRemoteHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestParams</span><span class="token punctuation">(</span>JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>pjp<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        log.info("【请求链接】:{}",request.getRequestURI());</span><span class="token comment" spellcheck="true">//        log.info("【接口描述】:{}",requestLog.desc());</span><span class="token comment" spellcheck="true">//        log.info("【请求类型】:{}",request.getMethod());</span><span class="token comment" spellcheck="true">//        log.info("【请求方法】:{}.{}",pjp.getSignature().getDeclaringTypeName(),pjp.getSignature().getName());</span><span class="token comment" spellcheck="true">//        log.info("【请求IP】:{},{}:{}",request.getRemoteAddr(),request.getRemoteHost(),request.getRemotePort());</span><span class="token comment" spellcheck="true">//        log.info("【请求参数】:{}", JSONUtil.toJsonStr(pjp.getArgs()));</span>        <span class="token comment" spellcheck="true">// 执行原方法逻辑</span>        Object result <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        info<span class="token punctuation">.</span><span class="token function">setCostTimeMillis</span><span class="token punctuation">(</span>stopWatch<span class="token punctuation">.</span><span class="token function">getTotalTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        info<span class="token punctuation">.</span><span class="token function">setResult</span><span class="token punctuation">(</span>JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【requestLog】:{}"</span><span class="token punctuation">,</span>JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        log.info("【接口花费时间统计】:{} 秒",stopWatch.getTotalTimeSeconds());</span><span class="token comment" spellcheck="true">//        log.info("【接口花费时间调度】:{}",stopWatch.prettyPrint());</span><span class="token comment" spellcheck="true">//        log.info("【请求返回结果】:{}",JSONUtil.toJsonStr(result));</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>@Aspect</code>：声明该类为一个注解类<br><code>@Pointcut</code>：定义一个切点，后面跟随一个表达式，表达式可以定义为切某个注解，也可以切某个 package 下的方法<br><code>@Before</code>: 在切点之前，织入相关代码<br><code>@After</code>: 在切点之后，织入相关代码<br><code>@AfterReturning</code>: 在切点返回内容后，织入相关代码，一般用于<strong>对返回值做些加工处理的场景</strong><br><code>@AfterThrowing</code>: 用来处理当织入的代码抛出异常后的逻辑处理<br><code>@Around</code>: 环绕，可以在切入点前后织入代码，并且可以自由的控制何时执行切点</p></blockquote><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestLog</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/requestLog/test"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">requestLog</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> String param<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试Controller类方法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-request-log-post.png" alt="Postman请求示例"></p><p><strong>postman请求示例</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-request-log-log.png" alt="打印Log"></p><h3 id="4-3-分布式锁（本文基于Redisson）"><a href="#4-3-分布式锁（本文基于Redisson）" class="headerlink" title="4.3 分布式锁（本文基于Redisson）"></a>4.3 分布式锁（本文基于Redisson）</h3><blockquote><p>关于Redisson分布式锁相关，可以查看笔者的另一篇文章<br><a href="http://xuyk.top/posts/redisson.html">浅谈Redis客户端Redisson | 寒暄</a></p></blockquote><h4 id="1-相关配置类"><a href="#1-相关配置类" class="headerlink" title="1.相关配置类"></a>1.相关配置类</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1.application.yml配置</span># 应用端口号server<span class="token operator">:</span>  port<span class="token operator">:</span> <span class="token number">10086</span># redis配置redisson<span class="token operator">:</span>  address<span class="token operator">:</span> redis<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span>  database<span class="token operator">:</span> <span class="token number">0</span># password<span class="token operator">:</span> foobared<span class="token comment" spellcheck="true">// 2.redisson配置参数(yml)</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"redisson"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedissonProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer database<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3.redisson配置类</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span>RedissonProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedissonConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Primary</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"defaultRedisClient"</span><span class="token punctuation">,</span>destroyMethod <span class="token operator">=</span> <span class="token string">"shutdown"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> RedissonClient <span class="token function">redissonClient</span><span class="token punctuation">(</span>RedissonProperties redissonProperties<span class="token punctuation">)</span><span class="token punctuation">{</span>        Config config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>redissonProperties<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setDatabase</span><span class="token punctuation">(</span>redissonProperties<span class="token punctuation">.</span><span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 连接最小初始化的个数</span>                <span class="token punctuation">.</span><span class="token function">setConnectionMinimumIdleSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>redissonProperties<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Redisson<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-自定义注解-DistributedLock"><a href="#2-自定义注解-DistributedLock" class="headerlink" title="2.自定义注解@DistributedLock"></a>2.自定义注解<code>@DistributedLock</code></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">DistributedLock</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 锁时间 默认2000毫秒     * @return     */</span>    <span class="token keyword">long</span> <span class="token function">lockTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> 2000L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-切面类-DistributedLockAop"><a href="#3-切面类-DistributedLockAop" class="headerlink" title="3.切面类 DistributedLockAop"></a>3.切面类 DistributedLockAop</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DistributedLockAop</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * redisson客户端     */</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedissonClient redissonClient<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(distributedLock)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">distributeLockPointcut</span><span class="token punctuation">(</span>DistributedLock distributedLock<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 环绕增强     * @param pjp     * @param distributedLock     */</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"distributeLockPointcut(distributedLock)"</span><span class="token punctuation">,</span> argNames <span class="token operator">=</span> <span class="token string">"pjp,distributedLock"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">around</span><span class="token punctuation">(</span>ProceedingJoinPoint pjp<span class="token punctuation">,</span> DistributedLock distributedLock<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        ServletRequestAttributes requestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span>ServletRequestAttributes<span class="token punctuation">)</span> RequestContextHolder<span class="token punctuation">.</span><span class="token function">currentRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpServletRequest request <span class="token operator">=</span> requestAttributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 请求路径</span>        String servletPath <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getServletPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用户ID</span>        Long userId <span class="token operator">=</span> MapUtil<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>ApiReqContextHolder<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String lockKey <span class="token operator">=</span> userId <span class="token operator">+</span> <span class="token string">" | "</span> <span class="token operator">+</span> servletPath<span class="token punctuation">;</span>        RLock lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> waitTime <span class="token operator">=</span> distributedLock<span class="token punctuation">.</span><span class="token function">waitTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> leaseTime <span class="token operator">=</span> distributedLock<span class="token punctuation">.</span><span class="token function">leaseTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"lockKey = {}，重复提交！"</span><span class="token punctuation">,</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">,</span><span class="token string">"访问太多次啦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 尝试加锁，最多等待lockTime毫秒，上锁以后leaseTime毫秒自动解锁</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span>leaseTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"lockKey = {}，正在处理中！"</span><span class="token punctuation">,</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">,</span><span class="token string">"正在处理中，请稍后再试！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 真正执行的方法</span>            <span class="token keyword">return</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"lockKey = {}，重复提交！"</span><span class="token punctuation">,</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">,</span> <span class="token string">"请勿重复提交！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 解锁(当前线程持有该锁才可进行解锁操作)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> lock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【分布式锁-解锁】lockKey:{}"</span><span class="token punctuation">,</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>解锁时的注意事项</strong>：<br>lock.isHeldByCurrentThread()表示锁是否被当前线程所持有<br>如果少了lock.isHeldByCurrentThread()这一判断，在有异步操作时会出现下面这样的异常，提示当前线程并不持有我们需要解的锁，无法尝试去解锁</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-lock-exception.png" alt="异常堆栈"></p><h4 id="4-测试-1"><a href="#4-测试-1" class="headerlink" title="4.测试"></a>4.测试</h4><p><strong>测试Controller类方法</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DistributedLock</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/distributedLock/test"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">distributedLock</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"sleepTime"</span><span class="token punctuation">)</span> Integer sleepTime<span class="token punctuation">,</span>                                  <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"isError"</span><span class="token punctuation">)</span> Boolean isError<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isError<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token string">"出现异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>postman请求示例</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AOP-request-log-postman-lock.png" alt="Postman请求示例"></p><h3 id="4-4-异常日志"><a href="#4-4-异常日志" class="headerlink" title="4.4 异常日志"></a>4.4 异常日志</h3><h4 id="1-自定义注解-ExceptionLog"><a href="#1-自定义注解-ExceptionLog" class="headerlink" title="1.自定义注解@ExceptionLog"></a>1.自定义注解<code>@ExceptionLog</code></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 运行时使用该注解</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 作用于方法</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ExceptionLog</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-mysql异常日志记录表"><a href="#2-mysql异常日志记录表" class="headerlink" title="2.mysql异常日志记录表"></a>2.mysql异常日志记录表</h4><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/aop-exceptionLogInfo.png" alt=""></p><h4 id="3-表对应异常日志类-ExceptionLogInfo"><a href="#3-表对应异常日志类-ExceptionLogInfo" class="headerlink" title="3.表对应异常日志类 ExceptionLogInfo"></a>3.表对应异常日志类 ExceptionLogInfo</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Builder</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"exception_log"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionLogInfo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * api请求路径     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"api_path"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String apiPath<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * api方法     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"api_method"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String apiMethod<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求路径     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"uri_path"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String uriPath<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求参数     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"request_param"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String requestParam<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 异常堆栈信息     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"ex_message"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String exMessage<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 创建时间     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"create_time"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date createTime<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-日志切面类-ExceptionLogAop"><a href="#4-日志切面类-ExceptionLogAop" class="headerlink" title="4.日志切面类 ExceptionLogAop"></a>4.日志切面类 ExceptionLogAop</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionLogAop</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ExceptionLogMapper exceptionLogMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token function">ExceptionLogAop</span><span class="token punctuation">(</span>ExceptionLogMapper exceptionLogMapper<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>exceptionLogMapper <span class="token operator">=</span> exceptionLogMapper<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 被 @exceptionLog 所注解的切点     * @param exceptionLog     */</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(exceptionLog)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionLogPointcut</span><span class="token punctuation">(</span>ExceptionLog exceptionLog<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 异常记录处理     * @param joinPoint     * @param exceptionLog     * @param e     */</span>    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"exceptionLogPointcut(exceptionLog)"</span><span class="token punctuation">,</span> throwing <span class="token operator">=</span> <span class="token string">"e"</span><span class="token punctuation">,</span> argNames <span class="token operator">=</span> <span class="token string">"joinPoint,exceptionLog,e"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saveExceptionLog</span><span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">,</span>ExceptionLog exceptionLog<span class="token punctuation">,</span> Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 请求信息</span>        ServletRequestAttributes requestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span>ServletRequestAttributes<span class="token punctuation">)</span> RequestContextHolder<span class="token punctuation">.</span><span class="token function">currentRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpServletRequest request <span class="token operator">=</span> requestAttributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Signature signature <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 持久化异常相关信息到数据库</span>        ExceptionLogInfo log <span class="token operator">=</span> ExceptionLogInfo<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiPath</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getServletPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiMethod</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">uriPath</span><span class="token punctuation">(</span>signature<span class="token punctuation">.</span><span class="token function">getDeclaringTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> signature<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestParam</span><span class="token punctuation">(</span><span class="token function">convertMap</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">exMessage</span><span class="token punctuation">(</span>ExceptionUtil<span class="token punctuation">.</span><span class="token function">stacktraceToOneLineString</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">createTime</span><span class="token punctuation">(</span>DateUtil<span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        exceptionLogMapper<span class="token punctuation">.</span><span class="token function">insertSelective</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 请求参数格式转换     * Map&lt;String,String[]> -> Map&lt;String,String>的json字符串     * @param paramMap     * @return     */</span>    <span class="token keyword">private</span> String <span class="token function">convertMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> paramMap<span class="token punctuation">)</span><span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span> entries <span class="token operator">=</span> paramMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>entries<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> entry <span class="token operator">:</span> entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> JSONUtil<span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>记录异常日志信息主要使用到的是<code>@AfterThrowing</code>注解和切面。再结合切点和request/反射等方式获取到请求和异常等信息，汇总记录持久化下来</p></blockquote><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h4><p><strong>测试Controller类方法</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/aop-async-exception-controller.png" alt=""></p><p><strong>postman请求示例</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/aop-exception-postman.png" alt=""></p><p><strong>数据库记录</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/aop-exception-mysql.png" alt=""></p><h3 id="4-5-demo代码"><a href="#4-5-demo代码" class="headerlink" title="4.5 demo代码"></a>4.5 demo代码</h3><p><a href="https://github.com/xuyikai1/JavaDemo">JavaDemo：aop-demo</a></p><blockquote><p>参考链接：<br>1：<a href="https:\zhuanlan.zhihu.com\p\60730622">自定义注解（Annontation）</a><br>2：<a href="https:\zhuanlan.zhihu.com\p\143434806">厉害了！老大利用AOP实现自定义注解，半小时完成我三天工作量</a><br>3：<a href="https:\zhuanlan.zhihu.com\p\82539232">如何优雅地在 Spring Boot 中使用自定义注解，AOP 切面统一打印出入参日志</a><br>4：<a href="https:\zhuanlan.zhihu.com\p\81420343">Spring 自定义注解从入门到精通</a><br>5：<a href="https:\zhuanlan.zhihu.com\p\202586806">9000字，通俗易懂的讲解下Java注解</a><br>6：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.md">JavaGuide/Spring常见问题总结</a><br>7：<a href="https://mp.weixin.qq.com/s/1ol0ewxckG06V-NqMFib4g">写了个牛逼的日志切面，甩锅更方便了</a><br>8：<a href="https://mp.weixin.qq.com/s/BXwjFpEGBLqqqivpMqfZPA">使用 SpringBoot AOP 记录操作日志、异常日志</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常工作应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
            <tag> 自定义注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon负载均衡策略总结</title>
      <link href="/posts/ribbon-load-balance.html"/>
      <url>/posts/ribbon-load-balance.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ribbon负载均衡策略总结"><a href="#Ribbon负载均衡策略总结" class="headerlink" title="Ribbon负载均衡策略总结"></a>Ribbon负载均衡策略总结</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  学过Spring Cloud/Spring Boot的可能都或多或少的听过用过Ribbon，而正是这个短小而又精悍的组件，因为本身可插拔的独特与便捷性，与Eureka、feign、gateway、zuul、hystrix甚至自定义SpringBoot都能完美融合使用。而今天，我们将抛砖引玉，从Ribbon中总结出他的核心：<strong>负载均衡策略</strong>。</p><h2 id="1-RandomRule-随机"><a href="#1-RandomRule-随机" class="headerlink" title="1. RandomRule - 随机"></a>1. RandomRule - 随机</h2><p>从可用服务节点中，随机挑选一个节点进行访问。</p><blockquote><p>yield+自旋的方式做重试，采用了严格的防御型编程</p></blockquote><p>拓展：<strong>防御型编程</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>server <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>防御型编程：基本可以确定list中的server不会为null，但是也会判空并且为空时进行线程出让，到下一个循环<br>yield：Thread.yield方法，表示当前线程发生退让，其他线程可以优先获得当前资源</p></blockquote><h2 id="2-RoundRobinRule-轮询（Ribbon默认负载均衡策略）"><a href="#2-RoundRobinRule-轮询（Ribbon默认负载均衡策略）" class="headerlink" title="2. RoundRobinRule - 轮询（Ribbon默认负载均衡策略）"></a>2. RoundRobinRule - 轮询（Ribbon默认负载均衡策略）</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/RoundRobinRule.png" alt="轮询"></p><p>很实在，就是采用轮询的机制把列表中的节点一个个的分发过去</p><blockquote><p>Q：那么如何保证多线程安全（多个请求到来如何保证顺序）？<br>A：根据CAS + 自旋锁的方式来进行同步操作，防止多线程请求的情况下按照顺序下发到节点</p></blockquote><h2 id="3-RetryRule-重试机制"><a href="#3-RetryRule-重试机制" class="headerlink" title="3. RetryRule - 重试机制"></a>3. RetryRule - 重试机制</h2><p>Ribbon里的这一策略秉承了23种经典设计模式之一的装饰模式，直白的理解就是<strong>为其他负载均衡策略加上重试的功能</strong></p><blockquote><p>可以类比Java IO流中的InputStream下有ObjectInputStream/FileInputStream/ByteInputStream等等，为输入流提供转化成对象/文件/字节等功能</p></blockquote><h2 id="4-WeightedResponseTimeRule-权重"><a href="#4-WeightedResponseTimeRule-权重" class="headerlink" title="4. WeightedResponseTimeRule - 权重"></a>4. WeightedResponseTimeRule - 权重</h2><p>Ribbon中这一负载均衡策略，会根据服务节点的响应时间计算权重，<strong>响应时间越长权重越低，此机器被选中的概率也越低</strong></p><blockquote><p>当然，在初期采样不足时，聪明的Ribbon也想到了，他们决定先采用轮询才收集样本，积累足够后会自动切换成权重机制</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/WeightedResponseTimeRule.png" alt="权重"></p><h2 id="5-BestAvailableRule-最少连接数-并发"><a href="#5-BestAvailableRule-最少连接数-并发" class="headerlink" title="5. BestAvailableRule - 最少连接数/并发"></a>5. BestAvailableRule - 最少连接数/并发</h2><p>Ribbon在<strong>过滤掉故障服务</strong>后，对基于<strong>过去30分钟</strong>的统计结果来选取当前并发量最小的服务节点，也就是最闲的节点来下发请求。相同的，采样不足时先使用备胎..不，轮询来负责。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/BestAvailableRule.png" alt="最少连接数"></p><h2 id="6-AvailabilityFilteringRule-条件-要求"><a href="#6-AvailabilityFilteringRule-条件-要求" class="headerlink" title="6. AvailabilityFilteringRule - 条件/要求"></a>6. AvailabilityFilteringRule - 条件/要求</h2><p>顾名思义，节点列表中需要满足一定条件的节点才可能被初步选中，并且这个节点不能处于<strong>熔断状态</strong>，还有请求数也不能超过特定阈值，才可被选中下发（选中后不幸宕机，则会发起重试，失败则再选择下一个节点）</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AvailabilityFilteringRule.png" alt="条件"></p><h2 id="7-ZoneAvoidanceRule-组合过滤"><a href="#7-ZoneAvoidanceRule-组合过滤" class="headerlink" title="7. ZoneAvoidanceRule - 组合过滤"></a>7. ZoneAvoidanceRule - 组合过滤</h2><p>1.每个在Eureka注册的节点都有三个身份信息：Zone、Region和URL，Zone可以理解为机房大区，这个策略会对每个节点的Zone做健康检查，筛选返回健康的节点列表<br>2.对筛选出来的列表做可用性过滤（如AvailabilityFilteringRule一样排除处于熔断状态的节点以及并发压力大（超过阈值）的结点）</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/ZoneAvoidanceRule.png" alt="组合过滤"></p><h2 id="8-加餐：LVS的负载均衡"><a href="#8-加餐：LVS的负载均衡" class="headerlink" title="8.  加餐：LVS的负载均衡"></a>8.  加餐：LVS的负载均衡</h2><p>LVS，全称为Linux Virtual Server，本质上就是一个负载均衡器，是linux上的虚拟服务，属于四层负载均衡（IP+端口），<strong>只负责转发请求</strong>。业界一般使用 <strong>keepalived+Lvs+Nginx</strong> 来搭建高可用集群负载均衡</p><blockquote><p>【四层负载均衡】：基于IP+端口的负载均衡，只负责转发并且记录当前链接由哪个服务器处理，后续这个链接的请求也会由这一台服务器去处理（相当于浏览器的长连接（keep-alive）），一般使用LVS，F5（F5成本很高）<br>【七层负载均衡】：不仅可以转发，也可以处理JS，CSS或者压缩等，一般使用Nginx，Apache（apache远不如nginx，百万级别性能降低）</p></blockquote><p><strong>LVS的源地址散列</strong>：等同于Nginx的ip-hash负载均衡算法，通俗地讲，就是LVS/Nginx通过把IP做hash之后对当前服务器总数取模分配到特定服务器，目的：<strong>确保同一个用户的请求能落到同一个服务器上</strong></p><blockquote><p>LVS的负载均衡算法有很多，这里来简单介绍以下源地址散列，具体其他的可参考笔者之前的笔记：<a href="http://note.youdao.com/s/M3DftIYr">LVS的负载均衡算法-有道云笔记</a></p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/hash.png" alt="hash算法"></p><blockquote><p>【%】表示求模<br>【node_counts】表示服务器的数量<br>【7 % 3 = 1】表示 7除以3余1 所以等于1<br>ip-hash负载均衡算法其实也有比较明显的缺点，例如对于ip动态变化的用户不太友好，新增/减少服务器都会与原来计算结果背道而驰，这时候可以考虑一致性hash算法（<a href="http://note.youdao.com/s/B3obmiGK">一致性hash算法-有道云笔记</a>）</p></blockquote><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>当然，除了以上的负载均衡策略，其实还有很多没列举出来的，例如Nginx中的最少连接策略、加权轮询等各种加权组合策略等，我们主要还是从中学习理解思想。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群搭建</title>
      <link href="/posts/redis-cluster.html"/>
      <url>/posts/redis-cluster.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h1><h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><table><thead><tr><th align="center">实例</th><th align="center">角色</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">192.168.10.139</td><td align="center">Master</td><td align="center">主节点</td></tr><tr><td align="center">192.168.10.142</td><td align="center">Slave</td><td align="center">从节点,对应139</td></tr><tr><td align="center">192.168.10.140</td><td align="center">Master</td><td align="center">主节点</td></tr><tr><td align="center">192.168.10.143</td><td align="center">Slave</td><td align="center">从节点,对应140</td></tr><tr><td align="center">192.168.10.141</td><td align="center">Master</td><td align="center">主节点</td></tr><tr><td align="center">192.168.10.144</td><td align="center">Slave</td><td align="center">从节点,对应141</td></tr></tbody></table><p>每个redis节点的配置(redis.conf)：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>conf文件中搜索cluster# <span class="token number">2</span><span class="token punctuation">.</span>开启集群cluster<span class="token operator">-</span>enabled yes# <span class="token number">3</span><span class="token punctuation">.</span>每个节点之间的关系<span class="token punctuation">,</span>注释开放即可cluster<span class="token operator">-</span>config<span class="token operator">-</span>file nodes<span class="token operator">-</span><span class="token number">6379</span><span class="token punctuation">.</span>conf# <span class="token number">4</span><span class="token punctuation">.</span>节点超时切换cluster<span class="token operator">-</span>node<span class="token operator">-</span>timeout <span class="token number">5000</span># <span class="token number">5</span><span class="token punctuation">.</span>默认关闭<span class="token punctuation">,</span>yes开启AOFappendonly yes# <span class="token number">6</span><span class="token punctuation">.</span>进入working目录<span class="token punctuation">,</span>删除rdb和aof备份文件<span class="token punctuation">,</span>否则搭建集群会报错# <span class="token number">7</span><span class="token punctuation">.</span>其中如果master有设置密码，则节点配置都需要加上masterauth password# PS：一般不需要密码，生产环境上端口一般配置为不对外开放的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-构建集群"><a href="#2-构建集群" class="headerlink" title="2. 构建集群"></a>2. 构建集群</h2><pre class="line-numbers language-java"><code class="language-java">redis<span class="token operator">-</span>cli <span class="token operator">-</span>a pwd <span class="token operator">--</span>cluster create ip1<span class="token operator">:</span>port1  ip2<span class="token operator">:</span>port2  ip3<span class="token operator">:</span>port3  ip4<span class="token operator">:</span>port4  ip5<span class="token operator">:</span>port5  ip6<span class="token operator">:</span>port6 <span class="token operator">--</span>cluster<span class="token operator">-</span>replicas <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-验证集群"><a href="#3-验证集群" class="headerlink" title="3. 验证集群"></a>3. 验证集群</h2><h3 id="1-随机登陆一台redis客户端"><a href="#1-随机登陆一台redis客户端" class="headerlink" title="(1) 随机登陆一台redis客户端"></a>(1) 随机登陆一台redis客户端</h3><pre class="line-numbers language-java"><code class="language-java">redis<span class="token operator">-</span>cli <span class="token operator">-</span>c <span class="token operator">-</span>a <span class="token number">123456</span> <span class="token operator">-</span>h <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">10.140</span> <span class="token operator">-</span>p <span class="token number">6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>-c：表示采用集群模式<br>-h：表示host<br>-p：端口</p></blockquote><h3 id="2-查看集群"><a href="#2-查看集群" class="headerlink" title="(2) 查看集群"></a>(2) 查看集群</h3><pre class="line-numbers language-java"><code class="language-java">cluster info：集群信息cluster nodes：集群节点信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/cluster%20info.png" alt="cluster-info"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/cluster%20nodes.png" alt="cluster-nodes"></p><h3 id="3-故障转移"><a href="#3-故障转移" class="headerlink" title="(3) 故障转移"></a>(3) 故障转移</h3><p>使用kill命令强制关闭一个redis master节点进程,此时集群状态<br>依旧为ok，在经过n秒(conf配置参数cluster-node-timeout)，<br>此宕机master节点的从节点会升级为master节点。之后原master节点恢复会自动降为slave节点</p><h2 id="4-redis-manager搭建"><a href="#4-redis-manager搭建" class="headerlink" title="4. redis-manager搭建"></a>4. redis-manager搭建</h2><p><a href="https://github.com/ngbdf/redis-manager/wiki/2.x-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8">redis-manager搭建</a></p><h3 id="搭建说明"><a href="#搭建说明" class="headerlink" title="搭建说明"></a>搭建说明</h3><h4 id="1-创建项目所需目录"><a href="#1-创建项目所需目录" class="headerlink" title="(1) 创建项目所需目录"></a>(1) 创建项目所需目录</h4><pre class="line-numbers language-java"><code class="language-java">mkdir <span class="token operator">-</span>p <span class="token operator">/</span>opt<span class="token operator">/</span>tool<span class="token operator">/</span>redis<span class="token operator">-</span>manager<span class="token operator">/</span>data<span class="token operator">/</span>avatarmkdir <span class="token operator">-</span>p <span class="token operator">/</span>opt<span class="token operator">/</span>tool<span class="token operator">/</span>redis<span class="token operator">-</span>manager<span class="token operator">/</span>data<span class="token operator">/</span>confmkdir <span class="token operator">-</span>p <span class="token operator">/</span>opt<span class="token operator">/</span>tool<span class="token operator">/</span>redis<span class="token operator">-</span>manager<span class="token operator">/</span>data<span class="token operator">/</span>machine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-添加到开机自启动"><a href="#2-添加到开机自启动" class="headerlink" title="(2) 添加到开机自启动"></a>(2) 添加到开机自启动</h4><pre class="line-numbers language-java"><code class="language-java"># <span class="token number">1</span><span class="token punctuation">.</span>编辑rc<span class="token punctuation">.</span>local文件vim <span class="token operator">/</span>etc<span class="token operator">/</span>rc<span class="token punctuation">.</span>d<span class="token operator">/</span>rc<span class="token punctuation">.</span>local# <span class="token number">2</span><span class="token punctuation">.</span>加入需要执行的脚本命令sh <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>redis<span class="token operator">-</span>manager<span class="token operator">/</span>bin<span class="token operator">/</span>start<span class="token punctuation">.</span>sh# <span class="token number">3</span><span class="token punctuation">.</span>设置rc<span class="token punctuation">.</span>local可执行权限<span class="token punctuation">(</span>centos7下rc<span class="token punctuation">.</span>local的权限被降低，需要手动为其赋予可执行权限<span class="token punctuation">)</span>chmod u<span class="token operator">+</span>x <span class="token operator">/</span>etc<span class="token operator">/</span>rc<span class="token punctuation">.</span>d<span class="token operator">/</span>rc<span class="token punctuation">.</span>local# <span class="token number">4</span><span class="token punctuation">.</span>重启服务器查看效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-redis-manager添加集群"><a href="#3-redis-manager添加集群" class="headerlink" title="(3) redis-manager添加集群"></a>(3) redis-manager添加集群</h4><p>1.通过<a href="http://192.168.10.139:8182"></a><a href="http://192.168.10.139:8182">http://192.168.10.139:8182</a>访问redis-manager管理端(ip为部署该项目的ip，默认端口为8182)，用户名密码默认皆为admin</p><p>2.Import Cluster导入已部署的集群<br><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/import%20cluster.png" alt="import cluster"></p><p>3.查看集群状态信息<br><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/rediss-manager%20cluster%20info.png" alt="rediss-manager cluster info"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从配置</title>
      <link href="/posts/mysql-configure.html"/>
      <url>/posts/mysql-configure.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql配置"><a href="#Mysql配置" class="headerlink" title="Mysql配置"></a>Mysql配置</h1><h2 id="0-整体思路"><a href="#0-整体思路" class="headerlink" title="0.整体思路"></a>0.整体思路</h2><ul><li>1.主节点和从节点配置my.cnf配置文件</li><li>2.锁住主节点数据库，将主节点数据库转化成dumpdb文件加载入从节点数据库</li><li>3.从节点设置主从配置，开启主从</li><li>4.同步失效排查</li></ul><blockquote><p>当前Mysql版本为8.0</p></blockquote><h2 id="1-节点说明"><a href="#1-节点说明" class="headerlink" title="1.节点说明"></a>1.节点说明</h2><table><thead><tr><th align="center">节点</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">192.168.10.155</td><td align="center">主节点</td></tr><tr><td align="center">192.168.10.166</td><td align="center">从节点</td></tr></tbody></table><blockquote><p>MYSQL8.0安装可在我的有道云笔记中查看：<br><a href="http:\note.youdao.com\s\mHRa5u3">MYSQL8.0安装概要笔记</a></p></blockquote><h2 id="2-主从节点配置配置"><a href="#2-主从节点配置配置" class="headerlink" title="2.主从节点配置配置"></a>2.主从节点配置配置</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1.155</span>主节点编辑mysql配置文件，在<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>标签下加入如下信息：# 编辑my<span class="token punctuation">.</span>cnf文件vim \etc\my<span class="token punctuation">.</span>cnflog<span class="token operator">-</span>bin<span class="token operator">=</span>my_mysql# server<span class="token operator">-</span>id要与从节点的server<span class="token operator">-</span>id不一致server<span class="token operator">-</span>id<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token number">2.156</span>从节点编辑mysql配置文件（vim \etc\my<span class="token punctuation">.</span>cnf），在<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>标签下加入如下信息：# server<span class="token operator">-</span>id要与主节点的server<span class="token operator">-</span>id不一致server<span class="token operator">-</span>id<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token number">3.155</span>主节点进入mysql客户端新增用于主从间同步的用户并且授权<span class="token punctuation">,</span>后刷新配置# 创建user用户create user <span class="token string">'repl'</span>@<span class="token string">'%'</span> identified by <span class="token string">'Xyk@950807'</span><span class="token punctuation">;</span># 赋予user用户权限grant replication slave on <span class="token operator">*</span><span class="token punctuation">.</span>* to <span class="token string">'repl'</span>@<span class="token string">'%'</span><span class="token punctuation">;</span># 刷新配置flush privileges<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token number">4.155</span>主节点使用命令进行锁表，而后主库备份数据到从库# 锁表，无法插入数据flush tables with read lock<span class="token punctuation">;</span># 查看当前主节点存储数据的文件File和存储位置position，并且记录下来show master status<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5Cmaster%20status.png" alt=""></p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">5</span><span class="token punctuation">.</span>新建一个<span class="token number">155</span>的会话，输入命令将锁之前的数据下载下来mysqldump <span class="token operator">--</span>all<span class="token operator">-</span>databases <span class="token operator">--</span>master<span class="token operator">-</span>data <span class="token operator">></span> dbdump<span class="token punctuation">.</span>db <span class="token operator">-</span>uroot <span class="token operator">-</span>p<span class="token number">6.156</span>节点使用scp命令将<span class="token number">155</span>的文件获取过来（在<span class="token number">156</span>节点输入命令）scp root<span class="token annotation punctuation">@192</span><span class="token punctuation">.</span><span class="token number">168.10</span><span class="token punctuation">.</span><span class="token number">155</span><span class="token operator">:</span><span class="token operator">~</span>\dbdump<span class="token punctuation">.</span>db <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5Cdumpdb.png" alt=""></p><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5Cscp%20dumpdb.png" alt=""></p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">7</span><span class="token punctuation">.</span>把dump<span class="token punctuation">.</span>db文件加载入<span class="token number">156</span>从库中（<span class="token number">156</span>从库执行）mysql <span class="token operator">&lt;</span> dbdump<span class="token punctuation">.</span>db <span class="token operator">-</span>uroot <span class="token operator">-</span>p输入密码<span class="token number">8.155</span>节点释放锁unlock tables<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token number">9.156</span>从节点上配置主从配置信息（mysql客户端）mysql<span class="token operator">></span> change master to    <span class="token operator">-</span><span class="token operator">></span> master_host<span class="token operator">=</span><span class="token string">'192.168.10.155'</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span> master_user<span class="token operator">=</span><span class="token string">'repl'</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span> master_password<span class="token operator">=</span><span class="token string">'Xyk@950807'</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span> master_log_file<span class="token operator">=</span><span class="token string">'my_mysql.000001'</span><span class="token punctuation">,</span>    <span class="token operator">-</span><span class="token operator">></span> master_log_pos<span class="token operator">=</span><span class="token number">984</span><span class="token punctuation">;</span><span class="token number">10</span><span class="token punctuation">.</span>开启主从start slave<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https:%5Cxuyk-picture-bed.oss-cn-beijing.aliyuncs.com%5Cchange%20master%20to.png" alt=""></p><h2 id="3-同步无效思路"><a href="#3-同步无效思路" class="headerlink" title="3.同步无效思路"></a>3.同步无效思路</h2><p>1.从库mysql 命令【show slave status】</p><p>查看Slave_IO_Running和Slave_SQL_Running是否两个都是yes</p><p>2.有No的情况，则根据Last_IO_Errno的错误码和错误报错排查问题谷歌或者百度解决</p><blockquote><p>【无效参考链接】<br>1.<a href="https:\www.cnblogs.com\ryxiong-blog\p\12516875.html">[mysql] [主从同步错误] Last_IO_Errno: 2061</a><br>2.<a href="https:\blog.csdn.net\qq_42395490\article\details\107451996">Last_IO_Errno: 13114(mysql主从复制)</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> configure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap-链表散列</title>
      <link href="/posts/hmap.html"/>
      <url>/posts/hmap.html</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-链表散列"><a href="#HashMap-链表散列" class="headerlink" title="HashMap-链表散列"></a>HashMap-链表散列</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>  大家在码代码或者面试的过程中，或多或少都肯定用过HashMap或者被问到过。事实上，大部分人包括笔者自己都会把他当作临时内存存储一些对象使用，方便快捷。那么，在这个简单易用的HashMap背后又是什么牛鬼蛇神呢？让我们一探究竟。</p><p>  我们来一个问题抛砖引玉：在刚接触Java的时候，不管是刚学习还是面试题中，都会有这个问题：数组和单链表的特点和不同点有哪些？在这里笔者才疏学浅地脱口而出：</p><ul><li><strong>数组</strong>：连续的内存。根据游标（index）查询快，时间复杂度O(1)；增删慢，时间复杂度O(n)</li><li><strong>单链表</strong>：查询慢，时间复杂度O(n)；增删快，时间复杂度O(1)</li><li>两者查询指定内容的时间复杂度为O(n)</li></ul><p>他们的特点也是由他们本身的数据结构息息相关的，如下图：</p><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E7%BB%84.png" alt="1"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A51.png" alt="2"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A52.png" alt="3"></p><p>如图：<br>（1）<strong>说明</strong>：数组是一段连续的内存，创建时必须定义好长度，创建后无法修改<br>（2）<strong>查询</strong>：在这个Int array[8]的数组中，如果想要查询下标为1的数据，则直接可以使用array[1]来获取<br>（3）<strong>插入</strong>：270需要插入到268和289中，先让289和320向后移动一位，然后插入。由此看出插入过程繁杂</p><h3 id="1-2-单链表"><a href="#1-2-单链表" class="headerlink" title="1.2 单链表"></a>1.2 单链表</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9.png" alt="单链表"></p><p>如图：<br>（1）<strong>说明</strong>：单链表只存储头结点和尾结点的信息，链表中的每个节点都保存了一个指向下一个节点的指针<br>（2）<strong>查询</strong>：从头结点根据指针向下遍历查询，过程繁杂<br>（3）<strong>插入</strong>：上图可看出，270插入到268和289之间，只需要两步：a.270的指针指向289 b.268的指针指向270</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/hashmap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="数据结构"></p><blockquote><p>备注：当<strong>链表长度大于8</strong> 并且 <strong>数组长度大于64时</strong> 链表才转换为红黑树</p></blockquote><p>  HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。<br>  <strong>HashMap融合了数组与单链表，数组用来定位键（key）存储的位置</strong>（单链表，jdk1.8后优化增加红黑树），<strong>如果有其他键值对存储在这个位置上，则从单链表/红黑树中遍历插入进去</strong>（jdk1.7采用头插法，1.8优化为尾插法）</p><h2 id="3-属性说明"><a href="#3-属性说明" class="headerlink" title="3. 属性说明"></a>3. 属性说明</h2><h3 id="3-1-默认初始容量"><a href="#3-1-默认初始容量" class="headerlink" title="3.1 默认初始容量"></a>3.1 默认初始容量</h3><p>HashMap的数组初始容量（DEFAULT_INITIAL_CAPACITY）为16，当我们使用Map map = new HashMap();时，如果指定了初始容量A，则HashMap内部会初始化为该容量<strong>最近的2的幂方的值（大于等于A）</strong>，例如我们初始化容量为10，则HashMap会为我们新建一个容量为16的数组</p><h3 id="3-2-最大容量"><a href="#3-2-最大容量" class="headerlink" title="3.2 最大容量"></a>3.2 最大容量</h3><p>HashMap的数组最大容量（MAXIMUM_CAPACITY）为 1&lt;&lt; 30，也就是1073741824，当我们创建时指定容量比此值大时，HashMap则会使用此值为容量</p><h3 id="3-3-负载因子"><a href="#3-3-负载因子" class="headerlink" title="3.3 负载因子"></a>3.3 负载因子</h3><p>HashMap的负载因子（DEFAULT_LOAD_FACTOR）默认值为0.75，标识数组存放数据的疏密程度。loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，反之就越稀疏</p><p>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。<strong>loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。</strong></p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，<strong>当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容</strong>，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><h3 id="3-4-转换阈值"><a href="#3-4-转换阈值" class="headerlink" title="3.4 转换阈值"></a>3.4 转换阈值</h3><ul><li>链表转换红黑树时，链表长度的阈值（TREEIFY_THRESHOLD）：8</li><li>链表转换红黑树时，数组长度的阈值（MIN_TREEIFY_CAPACITY）：64</li><li>红黑树恢复成链表的阈值（UNTREEIFY_THRESHOLD）：6</li></ul><p>对应HashMap数据插入或者删除时会有以下三种情况（<strong>jdk1.8版本</strong>）：<br>（1）插入数据后，单链表长度&gt;=8，数组长度小于64，则调用resize方法进行数组扩容<br>（2）插入数据后，单链表长度&gt;=8，数组长度大于等于64，则单链表转换为红黑树<br>（3）删除数据后，单链表长度&lt;=6，当前红黑树恢复回单链表</p><h2 id="4-核心方法"><a href="#4-核心方法" class="headerlink" title="4. 核心方法"></a>4. 核心方法</h2><h3 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h3><p>（1）默认构造函数：只初始化了负载因子</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0.75</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）带参构造函数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>   <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断table是否已经初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>            <span class="token comment" spellcheck="true">// 未初始化，s为m的实际元素个数</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>                    <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算得到的t大于阈值，则初始化阈值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将m中的所有元素添加至HashMap中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）指定容量的构造函数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（4）指定容量和负载因子的构造函数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>       initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-扩容机制"><a href="#4-2-扩容机制" class="headerlink" title="4.2 扩容机制"></a>4.2 扩容机制</h3><p>  HashMap在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容。</p><p>  扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，<strong>方法是使用一个新的数组代替已有的容量小的数组</strong>，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>  进行扩容，会伴随着一次<strong>重新hash分配（rehash）</strong>，并且会遍历hash表中所有的元素，是非常耗时的。<strong>我们在编写程序中，要尽量避免resize</strong>。</p><h3 id="4-3-扰动函数（hash方法）"><a href="#4-3-扰动函数（hash方法）" class="headerlink" title="4.3 扰动函数（hash方法）"></a>4.3 扰动函数（hash方法）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>作用：<br>1.尽可能降低hash碰撞，通俗来说就是减少通过hash方法之后得到相同值也就是定位到同个位置的可能性<br>2.高效，因为属于高频操作，使用位运算使得性能更高</p><blockquote><p>问：jdk 1.7做了四次移位和四次异或，为什么jdk 1.8只用一次异或？<br>答：做1次扰动效率更高，并且两者实际效果差距不大</p></blockquote><h3 id="4-4-插入方法"><a href="#4-4-插入方法" class="headerlink" title="4.4 插入方法"></a>4.4 插入方法</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap-put.png" alt="插入原理"></p><ul><li>（1）对key做hash操作（扰动函数）：如果key为null则返回0，不为null时，key的hashCode对自身无符号向右移后的hashCode做^操作，也就是按位异或，返回值假设为i</li><li>（2）判断键值对数组table是否为空或为null，否则执行resize()进行扩容（对应前方的无参构造函数）；</li><li>（3）查找数组i位置上是否存在节点（table[i] == null），不存在则直接新增此节点直接到（7）</li><li>（4）如果存在（table[i] != null），判断当前key和节点key是否相同，相同则覆盖原来的value</li><li>（5）两者key不相同，则判断当前结构是否已转换为红黑树，已转换则直接在插入到树中</li><li>（6）当前结构不为红黑树为链表时，遍历链表插入节点，然后判断当前长度是否大于等于8时，链表转换为红黑树；否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li><li>（7）插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ul><blockquote><p>【问】：为什么从jdk 1.7的数组+单链表 -&gt; jdk 1.8 数组+单链表/红黑树？<br>【答】：单链表查询的时间复杂度为O(n)，而红黑树的时间复杂度为O(logn)，提升效率</p></blockquote><blockquote><p>【问】：为什么jdk 1.7插入链表采用头插法，而jdk 1.8采用尾插法？<br>【答】：<br>jdk 1.7：作者认为最新插入的往往是查询中最希望被找到的<br>jdk 1.8：在1.7版本中，多线程环境下，A、B线程同时插入，A线程插入后，B线程扩容后重新hash，导致形成环</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/HashMap%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BC%8A%E7%AB%AF.jpg" alt="环"></p><h2 id="5-线程安全性"><a href="#5-线程安全性" class="headerlink" title="5. 线程安全性"></a>5. 线程安全性</h2><p>  HashMap是<strong>线程不安全</strong>的，举个数据覆盖的例子：当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；还有++size这个地方也会造成多线程同时扩容等问题。</p><p>  可以使用<strong>ConcurrentHashMap</strong>保证线程安全性（分段锁）</p><blockquote><p>ConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。</p></blockquote><h2 id="6-使用常识与小结"><a href="#6-使用常识与小结" class="headerlink" title="6. 使用常识与小结"></a>6. 使用常识与小结</h2><p>（1）创建HashMap时尽可能预估存储容量，从而调用指定容量的构造参数方法，尽量减少扩容（扩容涉及到rehash、复制数据等，小号性能）</p><p>（2）HashMap的key可传null，但是只能存储1个，value则不限制</p><p>（3）存取遍历HashMap时，优先使用entrySet()方法，可以同时获取到Key和对应的Value；而使用keySet()方法再map.get(key)的话，内部会进行两次遍历，消耗性能</p><pre class="line-numbers language-java"><code class="language-java"> Set<span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entrys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entrys<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（4）负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p><p>（5）HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p><p>（6）JDK1.8引入红黑树大程度优化了HashMap的性能。</p><blockquote><p>【参考链接】<br>1：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md">JavaGuide HashMap</a><br>2：<a href="https://zhuanlan.zhihu.com/p/125628540">一个HashMap跟面试官扯了半个小时</a><br>3：<a href="https://zhuanlan.zhihu.com/p/21673805">Java 8系列之重新认识HashMap</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初涉自动化部署</title>
      <link href="/posts/operation.html"/>
      <url>/posts/operation.html</url>
      
        <content type="html"><![CDATA[<h1 id="自动化部署与持续交付"><a href="#自动化部署与持续交付" class="headerlink" title="自动化部署与持续交付"></a>自动化部署与持续交付</h1><p>日常工作中，每个程序员都会经历<strong>项目部署</strong>，而很多人在这时大多会经历以下环节：</p><ul><li><strong>Git</strong> ：分布式版本控制系统，负责项目代码的分支拉取与分支更新等；</li><li><strong>Maven</strong> ：项目管理工具，负责项目打包；</li><li><strong>项目部署</strong> ：日常可能使用ftp方式传输项目包，Shell相关脚本部署，或者使用IDEA Alibaba Cloud Toolkit相关插件的部署功能等。</li></ul><p>而以上内容中比较传统的方式有一个缺点，就是需要人为的衔接每一步，稍微掉以轻心，则部署就比较容易出问题。</p><p>而如今更需要一个自动化部署与持续交付的组合拳来分担压力，更为准确和系统化的实现项目部署。接下来介绍一下Git\Maven + Jenkins + Ansible三剑客，能轻松解决这一难题，实现自动化部署。</p><p>简单分析图：</p><hr><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-1.png" alt=""></p><p>Git\Maven + Jenkins + Ansible自动化部署三剑客分工：</p><ul><li><strong>Git</strong> ：分布式版本控制系统，负责项目代码的分支拉取与分支更新等工作；</li><li><strong>Maven</strong> ：项目管理工具，负责项目打包工作；</li><li><strong>Ansible</strong> ：自动化运维工具，实现了批量系统配置、批量程序部署、批量运行命令等功能；</li><li><strong>Jenkins</strong> ：持续集成工具，用于监控持续重复的工作，通过插件管理来集成Git、Maven、Ansible来实现对应功能；</li></ul><h2 id="1-版本清单"><a href="#1-版本清单" class="headerlink" title="1. 版本清单"></a>1. 版本清单</h2><table><thead><tr><th align="left">Item</th><th align="left">Version</th></tr></thead><tbody><tr><td align="left">CentOS</td><td align="left">7</td></tr><tr><td align="left">JDK</td><td align="left">1.8</td></tr><tr><td align="left">Python</td><td align="left">3.6.5</td></tr><tr><td align="left">Jenkins</td><td align="left">2.204.1</td></tr><tr><td align="left">Maven</td><td align="left">3.6.3</td></tr><tr><td align="left">Ansible</td><td align="left">2.9.2</td></tr></tbody></table><h2 id="2-安装与部署"><a href="#2-安装与部署" class="headerlink" title="2. 安装与部署"></a>2. 安装与部署</h2><h3 id="2-1-Jenkins安装前的环境部署"><a href="#2-1-Jenkins安装前的环境部署" class="headerlink" title="2.1 Jenkins安装前的环境部署"></a>2.1 Jenkins安装前的环境部署</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-2.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-3.png" alt=""></p><blockquote><p>生产环境中防火墙可能不能关闭，那么则需要放行相关程序所需要的端口(jenkins默认为8080)</p></blockquote><p><strong>下载jenkins rpm包：</strong></p><blockquote><p>https:\pkg.jenkins.io\redhat-stable\</p></blockquote><h4 id="2-1-1-jdk1-8安装"><a href="#2-1-1-jdk1-8安装" class="headerlink" title="2.1.1 jdk1.8安装"></a>2.1.1 jdk1.8安装</h4><blockquote><p>参考链接中安装jdk1.8的部分：<br>https:\blog.csdn.net\qq_26368081\article\details\78984316    </p></blockquote><h4 id="2-1-2-maven安装"><a href="#2-1-2-maven安装" class="headerlink" title="2.1.2 maven安装"></a>2.1.2 maven安装</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>下载maven压缩包wget http<span class="token operator">:</span>\\mirror<span class="token punctuation">.</span>bit<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn\apache\maven\maven<span class="token operator">-</span><span class="token number">3</span>\<span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">3</span>\binaries\apache<span class="token operator">-</span>maven<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">-</span>bin<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz<span class="token number">2</span><span class="token punctuation">.</span>解压mavan压缩包tar  <span class="token operator">-</span>zxvf apache<span class="token operator">-</span>maven<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">-</span>bin<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz<span class="token number">3</span><span class="token punctuation">.</span>查看maven版本号进入maven目录<span class="token punctuation">.</span>\mvn <span class="token operator">--</span>version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Jenkins安装与部署"><a href="#2-2-Jenkins安装与部署" class="headerlink" title="2.2 Jenkins安装与部署"></a>2.2 Jenkins安装与部署</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-4.png" alt=""></p><blockquote><p>JENKINS_USER = deploy表示jenkins的用户<br>JENKINS_PORT = 8080表示jenkins的端口</p></blockquote><pre class="line-numbers language-java"><code class="language-java">启动jenkins服务：systemctl start jenkins开机自启动jenkins服务： systemctl enable jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-登陆jenkins管理平台"><a href="#2-2-1-登陆jenkins管理平台" class="headerlink" title="2.2.1 登陆jenkins管理平台"></a>2.2.1 登陆jenkins管理平台</h4><p>接下来使用可以访问到该服务器jenkins端口的电脑登陆：服务器ip + jenkins端口号<br>例如：http:\192.168.10.132:8080</p><h4 id="2-2-2-复制输入初始密码登陆"><a href="#2-2-2-复制输入初始密码登陆" class="headerlink" title="2.2.2 复制输入初始密码登陆"></a>2.2.2 复制输入初始密码登陆</h4><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-5.png" alt=""></p><pre class="line-numbers language-java"><code class="language-java">复制文件中的密码vi \var\lib\jenkins\secrets\initialAdminPassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-3-安装插件"><a href="#2-2-3-安装插件" class="headerlink" title="2.2.3 安装插件"></a>2.2.3 安装插件</h4><p>选择推荐安装的插件即可</p><h4 id="2-2-4-创建管理员帐户"><a href="#2-2-4-创建管理员帐户" class="headerlink" title="2.2.4 创建管理员帐户"></a>2.2.4 创建管理员帐户</h4><p>创建平台管理员帐户</p><h4 id="2-2-5-角色权限部署"><a href="#2-2-5-角色权限部署" class="headerlink" title="2.2.5 角色权限部署"></a>2.2.5 角色权限部署</h4><p>0.目的：<strong>每个用户只管理属于自己的自动化部署项目</strong><br>路径：<strong>Manage Jenkins - Manage Plugins - 可选插件</strong></p><p>1.安装所需插件：<br><strong>Role-based Authorization Strategy - 直接安装</strong><br><strong>Authorize Project - 直接安装</strong></p><p>2.部署路径：<strong>Manage Jenkins - Configure Global Security</strong><br>按图示开启用户登陆和选择Role-Based Strategy策略</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-6.png" alt=""></p><p>3.路径：<strong>Manage Jenkins - Manage and Assign Roles</strong></p><p>4.配置：</p><p><strong>帐号准备</strong><br>新建三个帐号prod、test、abc分别表示生产环境帐号、测试环境帐号、未知帐号<br>路径：<strong>管理平台页面 - 注销 - 创建一个用户帐号</strong></p><p><strong>配置Manage Roles</strong><br>在Manage Roles中有两种角色<br><strong>Global roles</strong>：分配全局策略<br><strong>Project roles</strong>：根据项目环境来分配项目权限</p><p><strong>Global roles栏</strong><br>可添加guest游客的角色，只赋予read权限（Overrall - Read），可查看全局的面板</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-7.png" alt=""></p><p><strong>Item roles栏</strong><br>可根据环境（例如生产环境、测试环境等）来进行项目分类</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-8.png" alt=""></p><p><strong>Role</strong>：分类名<br><strong>Pattern</strong>：正则表达式匹配</p><blockquote><p>例子：<br><strong>.*test</strong>    ：匹配所有以test结尾的项目，并分配图上的权限。注意使用通配符‘’时，需要在’’前添加’.’,否则无法保存并会报错。例如：.*plat</p></blockquote><p><strong>配置Assign Roles</strong><br>把具体用户（prod、test）与<strong>Manage Roles</strong>中配置的角色权限关联起来</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-9.png" alt=""></p><blockquote><p>注意：<br>Anonymous User不分配权限，只需要给admin分配管理员权限</p></blockquote><p><strong>验证权限</strong><br>新建Item：a.test和a.prod<br>路径：<strong>管理平台 - 新建Item - a.test - Freestyle project - 确定 - 返回管理平台页面</strong></p><blockquote><p>因为是测试Item，所以没有继续创建具体Item内容</p></blockquote><p><strong>admin管理用户的管理界面</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-10.png" alt=""></p><p><strong>test用户的管理界面</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-11.png" alt=""></p><p><strong>prod用户的管理界面</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-12.png" alt=""></p><blockquote><p>具体的权限在前面的<strong>Manage Roles - Item roles</strong>里根据需要进行设置</p></blockquote><p><strong>关闭用户注册入口</strong><br>路径：<strong>Manage Jenkins - Configure Global Security - 访问控制 - Jenkins’ own user database - 允许用户注册</strong><br>取消√即可</p><h3 id="2-3-Ansible安装与部署"><a href="#2-3-Ansible安装与部署" class="headerlink" title="2.3 Ansible安装与部署"></a>2.3 Ansible安装与部署</h3><h4 id="2-3-1-Ansible安装前的环境部署"><a href="#2-3-1-Ansible安装前的环境部署" class="headerlink" title="2.3.1 Ansible安装前的环境部署"></a>2.3.1 Ansible安装前的环境部署</h4><p><strong>python安装与部署</strong></p><p>1.在安装Python之前，需要先安装一些后面遇到的依赖问题（如果有依赖问题，按照提示安装）：</p><pre class="line-numbers language-java"><code class="language-java">yum <span class="token operator">-</span>y install zlib<span class="token operator">-</span>devel bzip2<span class="token operator">-</span>devel openssl<span class="token operator">-</span>devel ncurses<span class="token operator">-</span>devel sqlite<span class="token operator">-</span>devel readline<span class="token operator">-</span>devel tk<span class="token operator">-</span>devel gdbm<span class="token operator">-</span>devel db4<span class="token operator">-</span>devel libpcap<span class="token operator">-</span>devel xz<span class="token operator">-</span>devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.python压缩包下载</p><p><strong>使用命令</strong></p><pre class="line-numbers language-java"><code class="language-java">wget https<span class="token operator">:</span>\\www<span class="token punctuation">.</span>python<span class="token punctuation">.</span>org\ftp\python\<span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">5</span>\Python<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>or</p><p>*<em>进入该网址直接本地下载然后ftp方式传输至服务器上 *</em></p><blockquote><p>https:\<a href="http://www.python.org\ftp\python\">www.python.org\ftp\python\</a></p></blockquote><p>3.解压、配置与编译安装</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>解压文件tar <span class="token operator">-</span>xvf Python<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>tgz<span class="token number">2</span><span class="token punctuation">.</span>包安装在\usr\local\Python3（具体安装位置看个人喜好）mkdir <span class="token operator">-</span>p \usr\local\Python3<span class="token number">3</span><span class="token punctuation">.</span>配置cd Python<span class="token operator">-</span><span class="token number">3.6</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">.</span>\configure <span class="token operator">--</span>prefix<span class="token operator">=</span>\usr\local\python3<span class="token number">4</span><span class="token punctuation">.</span>编译安装makemake install<span class="token number">5</span><span class="token punctuation">.</span>做软链接ln <span class="token operator">-</span>s \usr\local\python3\bin\python3<span class="token number">.6</span> \usr\bin\python3设置pip软连接ln <span class="token operator">-</span>s \usr\local\python3\bin\pip3<span class="token number">.6</span> \usr\bin\pip3<span class="token number">6</span><span class="token punctuation">.</span>测试是否安装成功python3 <span class="token operator">-</span>V<span class="token number">7</span><span class="token punctuation">.</span>因为yum源使用的Python2，替换为Python3以后，会导致其无法正常工作。需要修改以下信息：修改yum配置文件：vi \usr\bin\yum第一行修改为#<span class="token operator">!</span>\usr\bin\python2<span class="token number">.7</span><span class="token number">8</span><span class="token punctuation">.</span>验证yum源正常使用yum <span class="token operator">-</span>y install vim 执行两次测试安装与校验<span class="token number">9</span><span class="token punctuation">.</span>用pip安装PyQuery包pip3 install PyQuery<span class="token number">10</span><span class="token punctuation">.</span>升级pippip3 install <span class="token operator">--</span>upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-Ansible安装部署"><a href="#2-3-2-Ansible安装部署" class="headerlink" title="2.3.2 Ansible安装部署"></a>2.3.2 Ansible安装部署</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>sudo yum install epel<span class="token operator">-</span>release<span class="token number">2</span><span class="token punctuation">.</span>sudo yum install ansible<span class="token number">3</span><span class="token punctuation">.</span>pip install <span class="token operator">--</span>upgrade pip<span class="token number">4</span><span class="token punctuation">.</span>pip install paramiko PyYAML Jinja2 httplib2 six<span class="token number">5</span><span class="token punctuation">.</span>pip install ansible        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ssh免密码\密钥认证</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>本地机器上使用ssh<span class="token operator">-</span>keygen产生公钥私钥对ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa （一路回车）<span class="token number">2</span><span class="token punctuation">.</span>用ssh<span class="token operator">-</span>copy<span class="token operator">-</span>id将公钥复制到远程机器（<span class="token operator">~</span>\ <span class="token punctuation">.</span>ssh\authorized_key<span class="token punctuation">.</span>文件）中ssh<span class="token operator">-</span>copy<span class="token operator">-</span>id <span class="token operator">-</span>i \root\<span class="token punctuation">.</span>ssh\id_rsa<span class="token punctuation">.</span>pub 用户名<span class="token annotation punctuation">@192</span><span class="token punctuation">.</span><span class="token number">168</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span>xxx（\root\<span class="token punctuation">.</span>ssh\id_rsa<span class="token punctuation">.</span>pub这个路径有可能不同，以自身具体路径准，详见下方截图）<span class="token number">3</span><span class="token punctuation">.</span>输入yes继续连接，输入远程服务器的密码<span class="token punctuation">(</span>密钥文件的形式不需要输入密码，但<span class="token punctuation">)</span><span class="token number">4</span><span class="token punctuation">.</span>ssh方式登录远程服务器验证免密是否生效<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>密码方式：ssh 用户名<span class="token annotation punctuation">@192</span><span class="token punctuation">.</span><span class="token number">168</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>密钥方式：需要对密钥文件权限进行修改<span class="token operator">-</span>禁止文件的访问权限，否则系统会判断该文件可能被篡改而无法使用该密钥进行登录chmod <span class="token number">700</span> filenamessh <span class="token operator">-</span>i 密钥文件路径 用户名<span class="token annotation punctuation">@192</span><span class="token punctuation">.</span><span class="token number">168</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span>xxx<span class="token number">5</span><span class="token punctuation">.</span>完成ssh免密码\密钥认证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-13.png" alt=""></p><p><strong>Jenkins ansible插件安装</strong></p><p>路径：*<em>Manage Jenkins - Manage Plugins - 可选插件 *</em></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-14.png" alt=""></p><blockquote><p>未找到可能是因为已经安装了，在已安装里寻找</p></blockquote><h3 id="2-4-其他补充部署"><a href="#2-4-其他补充部署" class="headerlink" title="2.4 其他补充部署"></a>2.4 其他补充部署</h3><h4 id="2-4-1-Jenkins关于jdk的部署"><a href="#2-4-1-Jenkins关于jdk的部署" class="headerlink" title="2.4.1 Jenkins关于jdk的部署"></a>2.4.1 Jenkins关于jdk的部署</h4><p>路径：<strong>Manage Jenkins - Global Tool Configuration - JDK</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-15.png" alt=""></p><p>JAVA_HOME填写jre路径（以自己实际路径为准）</p><blockquote><p>红色警告无伤大雅，配置是正确的</p></blockquote><h4 id="2-4-2-Jenkins关于maven的部署"><a href="#2-4-2-Jenkins关于maven的部署" class="headerlink" title="2.4.2 Jenkins关于maven的部署"></a>2.4.2 Jenkins关于maven的部署</h4><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-16.png" alt=""></p><h2 id="3-新建Item完成自动化部署"><a href="#3-新建Item完成自动化部署" class="headerlink" title="3. 新建Item完成自动化部署"></a>3. 新建Item完成自动化部署</h2><h3 id="3-1-新建Item"><a href="#3-1-新建Item" class="headerlink" title="3.1 新建Item"></a>3.1 新建Item</h3><p>1.路径：<strong>Jenkins工作台 - 新建Item - 输入任务名称(例：abc.test) - 选择Freestyle project - 确定</strong></p><blockquote><p>Freestyle在普通集成中一般足够使用，如果现实业务中有复杂的逻辑而Freestyle无法满足时，建议可以使用Jenkins 流水线(pipeline)编写pipeline脚本来实现自定义逻辑。<br>流水线写法可参考：<strong>ip地址:port端口号\job\pipeline.test\pipeline-syntax\</strong>(例：http:\192.168.10.132:8080\job\pipeline.test\pipeline-syntax)<br><strong>流水线example</strong>：https:\jenkins.io\doc\pipeline\examples\</p></blockquote><p>2.<strong>This project is parameterized</strong>（项目参数配置）</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-17.png" alt=""></p><p>(1) <strong>添加git分支选择参数 - Git Parameter</strong></p><blockquote><p>添加该参数的作用是在部署该Item时，部署人员可以动态选择git remote branchs中的任意分支，实现灵活部署</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-18.png" alt=""></p><p>(2) <strong>源码管理 - Git\Multiple SCMs</strong></p><p>预备：<strong>添加Git凭据</strong><br>路径：<strong>工作台 - 凭据 - Stores scoped to Jenkins - Jenkins -     全局凭据 (unrestricted) - 添加一些凭据</strong><br>填写用户名密码保存即可</p><blockquote><p>需要从git\svn拉取多个项目情况需要安装<strong>Multiple SCMs plugin</strong>插件</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-19.png" alt=""></p><p>$ + 前面设置的参数名(例如：$playbookBranch)<br>实现动态选择远程分支的作用</p><p>(3) <strong>构建 - Maven</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-20.png" alt=""></p><p>Maven构建模块可以用来对项目进行install\package等操作</p><p>(4) <strong>构建  - Ansible playbook</strong></p><p>Ansible Playbooks常用模块介绍：</p><blockquote><p>http:\note.youdao.com\noteshare?id=0bfc53f1b967f11d8f7e26ce38cbb6d8</p></blockquote><p>Playbooks框架与格式介绍：</p><blockquote><p>http:\note.youdao.com\noteshare?id=d0d98975bc335c3e12fa73274e62c41f</p></blockquote><p>简单的ansible task脚本例子：</p><pre class="line-numbers language-java"><code class="language-java">  # 上传jar包到远程服务器指定目录下  # <span class="token punctuation">{</span><span class="token punctuation">{</span>appPkgSrcDir<span class="token punctuation">}</span><span class="token punctuation">}</span> 这些参数在inventory文件中定义  <span class="token operator">-</span> name<span class="token operator">:</span> upload jar file to server    tags<span class="token operator">:</span>     <span class="token operator">-</span> upload     <span class="token operator">-</span> test    copy<span class="token operator">:</span>     src<span class="token operator">:</span> <span class="token string">"{{ appPkgSrcDir }}\{{appName}}"</span>     dest<span class="token operator">:</span> <span class="token string">"{{appDeployDest}}"</span>  # 得到指定应用的pid  <span class="token operator">-</span> name<span class="token operator">:</span> get pid of service    shell<span class="token operator">:</span> <span class="token string">"ps -ef | grep -v grep | grep {{serviceName}} | awk '{print $2}'"</span>    register<span class="token operator">:</span> pid  # 展示pid  <span class="token operator">-</span> name<span class="token operator">:</span> display pid    debug<span class="token operator">:</span> msg<span class="token operator">=</span><span class="token string">"{{pid.stdout}}"</span>  <span class="token operator">-</span> name<span class="token operator">:</span> source profile    shell<span class="token operator">:</span> <span class="token string">"source \etc\profile"</span>  # 强制kill进程<span class="token punctuation">(</span>生产环境不建议直接这样操作<span class="token punctuation">)</span>  <span class="token operator">-</span> name<span class="token operator">:</span> Force kill stuck processes    shell<span class="token operator">:</span> <span class="token string">"kill -9 {{ pid.stdout }}"</span>  <span class="token operator">-</span> name<span class="token operator">:</span> sleep 2s     command<span class="token operator">:</span> sleep 2s  # 开启服务  <span class="token operator">-</span> name<span class="token operator">:</span> start <span class="token punctuation">{</span><span class="token punctuation">{</span>serviceName<span class="token punctuation">}</span><span class="token punctuation">}</span>    shell<span class="token operator">:</span> <span class="token string">"cd \data\mbApp\pay-mgt;nohup \home\jdk\jdk1.8.0_152\bin\java -jar {{appName}} --spring.profiles.active=test > nohup.out 2>&amp;1 &amp;"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这个例子比较简单，只适合在开发\测试环境进行测试时为了便捷而使用</p></blockquote><p><strong>Jenkins Ansible配置</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-21.png" alt=""></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/deploy-22.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于RabbitMQ的消息投递组件封装</title>
      <link href="/posts/rabbitmq.html"/>
      <url>/posts/rabbitmq.html</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ消息投递组件封装"><a href="#RabbitMQ消息投递组件封装" class="headerlink" title="RabbitMQ消息投递组件封装"></a>RabbitMQ消息投递组件封装</h1><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0.引言"></a>0.引言</h2><p>  在如今越来越内卷的IT行业，高并发，基本会出现在每一场面试中。而面试者关于此的回答中，我们也始终能听到一个熟悉的名词：消息队列，以及他所存在的一些特性和问题。例如：<strong>削峰填谷</strong>，<strong>异步化缓冲</strong>等，借着学习课程的契机以及自身的理解，也对消息队列中的RabbitMQ进行封装，做到开箱即用。</p><h2 id="1-架构图解"><a href="#1-架构图解" class="headerlink" title="1.架构图解"></a>1.架构图解</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/rabbitmq-%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3.png" alt="架构图解"></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Sender</td><td align="center">生产消息-生产端</td></tr><tr><td align="center">MQ Broker</td><td align="center">接收生产端发出的消息，MQ Broker接收</td></tr><tr><td align="center">Confirm Listener</td><td align="center">接收RabbitMQ响应给生产端，表示RabbitMQ收到消息，返回确认，而Listener接收确认消息</td></tr><tr><td align="center">分布式定时任务</td><td align="center">xxl-job分布式调度，定时轮询未投递\消费成功的消息，重新让Sender进行二次\重复投递</td></tr></tbody></table><blockquote><p>大体流程：消息生产端Sender在发送消息前，对消息进行初始化并且落库MSG DB（业务上也可同时记录-&gt; BIZ DB），而后发送至MQ，MQ Broker收到消息后发回该条消息的响应，表示消息已收到，Comfirm Listener负责接收响应，并且更新MSG DB的该条消息状态为已投递。而另一端定时任务会抽取待确认的消息，到达重试时间并且重试多次（自定义），让Sender进行再次投递，保证消息投递成功。</p></blockquote><h2 id="2-组件关键点概述"><a href="#2-组件关键点概述" class="headerlink" title="2.组件关键点概述"></a>2.组件关键点概述</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/rabbitmq-%E7%BB%84%E4%BB%B6%E6%A6%82%E8%BF%B0.png" alt="组件概述"></p><p>根据上图，组件封装的关键点清晰可见</p><table><thead><tr><th align="center">部分要点</th><th align="center">技术选型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">数据交互层</td><td align="center">tk-mybatis</td><td align="center">通用性mapper</td></tr><tr><td align="center">序列化</td><td align="center">jackson</td><td align="center">保证自定义message与amqp message的转换</td></tr><tr><td align="center">定时任务</td><td align="center">xxl-job分布式调度</td><td align="center">定时任务</td></tr></tbody></table><h3 id="1-1-消息类型区分"><a href="#1-1-消息类型区分" class="headerlink" title="1.1 消息类型区分"></a>1.1 消息类型区分</h3><p>消息在组件中分为三种类型：<br>（1）<strong>迅速\普通消息</strong>：普通消息，不要求MQ返回ack确认收到，力求消息投递速度<br>（2）<strong>可靠消息</strong>：要求MQ返回ack确认收到，生产端发出的每一条消息不回丢失<br>（3）<strong>延迟消息</strong>：要求MQ返回ack确认收到，生产端发出的消息会在自定义的时间后要求MQ返回ack确认收到</p><h3 id="1-2-消息异步化-序列化"><a href="#1-2-消息异步化-序列化" class="headerlink" title="1.2 消息异步化\序列化"></a>1.2 消息异步化\序列化</h3><p>（1）消息通过JacksonSerializer序列化和反序列化，做到amqp Message与自定义Message之间的转换。发送的时候是自定义的message，能通过自定义序列化保证收到也是自定义的message<br>（2）生产消息异步化</p><h3 id="1-3-链接池化-高性能"><a href="#1-3-链接池化-高性能" class="headerlink" title="1.3 链接池化\高性能"></a>1.3 链接池化\高性能</h3><p>（1）RabbitMQ每个topic对应一个RabbitTemplate，缓存起来，有效节约创建销毁开支。template单例模式下，在多生产者时（不同topic不同exchange）性能会受到影响，以topic为key生成多生产者，不同种类的topic对应相应的template，做不同的定制操作，提升性能<br>（2）在生产消息的过程中，由线程池统一调度</p><h3 id="1-4-完备的补偿机制"><a href="#1-4-完备的补偿机制" class="headerlink" title="1.4 完备的补偿机制"></a>1.4 完备的补偿机制</h3><p>消息信息落库，并且对消息进行状态标记，再由xxl-job分布式定时任务扫描进行重新投递，保证消息不因为网络抖动发生丢失，以达到准确投递</p><h2 id="3-可靠性投递剖析与改进点"><a href="#3-可靠性投递剖析与改进点" class="headerlink" title="3.可靠性投递剖析与改进点"></a>3.可靠性投递剖析与改进点</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/rabbitmq-%E7%94%9F%E4%BA%A7%E7%AB%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92.png" alt="可靠性投递"></p><h3 id="3-1-消息不可靠要点"><a href="#3-1-消息不可靠要点" class="headerlink" title="3.1 消息不可靠要点"></a>3.1 消息不可靠要点</h3><ul><li>RabbitMQ收到消息生产端发送的消息之后，因为负载压力过大等因素，返回给生产端的失败(confirm失败)，但实际是成功的</li><li>broker因为网络抖动没收到消息，消息丢失</li><li>broker收到消息，confirm因为网络抖动没收到消息，消息丢失</li></ul><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/rabbitmq-%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="解决方案"></p><h3 id="3-2-消息落库，消息打标"><a href="#3-2-消息落库，消息打标" class="headerlink" title="3.2 消息落库，消息打标"></a>3.2 消息落库，消息打标</h3><p>此项目采用的就是这一解决方案来做到可靠性投递</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/rabbitmq-%E6%B6%88%E6%81%AF%E4%BF%A1%E6%81%AF%E8%90%BD%E5%BA%93.png" alt="消息信息落库"></p><h3 id="3-3-消息的延迟投递，做二次确认，回调检查"><a href="#3-3-消息的延迟投递，做二次确认，回调检查" class="headerlink" title="3.3 消息的延迟投递，做二次确认，回调检查"></a>3.3 消息的延迟投递，做二次确认，回调检查</h3><blockquote><p>（99.99%的可靠性） - 减少数据库操作，保证性能</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/rabbitmq-%E4%BA%8C%E6%AC%A1%E7%A1%AE%E8%AE%A4.png" alt="延迟投递二次确认"></p><blockquote><p><strong>upstream service：</strong> 上游服务<br><strong>callback service：</strong> 回调服务<br><strong>重点：</strong> 一定是数据库操作完了再去发送消息，互联网大厂不加事务（导致性能瓶颈）<br><strong>优点：</strong> 主流程中，相比第一种方案少了一次DB操作，而是使用callback service异步来承担</p></blockquote><p>1.一次性生成两条MQ消息（第二条为延迟消息投递- 用来n分钟之后检查，两条消息投递的队列不同，查看图中线的颜色）</p><p>2.消费端处理完消息之后，再发一条处理成功的消息并且入库msg db，callback service来专门监听消费端的处理成功的消息队列，也同时监听生产端发出的延迟消息队列，callback收到延迟消息时查询db</p><p>3.如果消费端返回处理失败或者没有响应时，callback service要做消息补偿（即收到延迟消息查询之后发现没有处理成功，则主动发起rpc通信，给上游服务发送reSend命令，生产端再根据biz的业务相关id来查询biz db再次发送两条消息）</p><h2 id="4-封装组件源码"><a href="#4-封装组件源码" class="headerlink" title="4.封装组件源码"></a>4.封装组件源码</h2><p><strong><a href="https:\github.com\xuyikai1\rabbit-parent">源码link下载</a></strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解</title>
      <link href="/posts/spring-annotation.html"/>
      <url>/posts/spring-annotation.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><h2 id="1-SpringBootApplication注解"><a href="#1-SpringBootApplication注解" class="headerlink" title="1. @SpringBootApplication注解"></a>1. <code>@SpringBootApplication</code>注解</h2><p><code>@SpringBootApplication</code>注解默认加载主类上，可以把他看作是<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p><ul><li><strong>@Configuration</strong>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li><li><strong>@ComponentScan</strong>：扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li><li><strong>@EnableAutoConfiguration</strong>：启用 SpringBoot 的自动配置机制</li></ul><blockquote><p>其中<code>@EnableAutoConfiguration</code>的自动装配机制：该注解的Import注解导入了名为自动配置导入选择器的配置类(AutoConfigurationImportSelector)，自动装配导入选择器的selectImports方法中获取配置实例方法getAutoConfigurationEntry里，会有一个获取候选配置方法(getCandidateConfigurations)，有一个断言，表明选择器会从spring-boot-autoconfigure-2.1.5.RELEASE.jar包的META-INF目录下的spring,factories配置文件里获取到所有的候选配置，包括springboot内置的tomcat，事务等批量的自动装配，简化了很多繁琐的配置。</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/SpringbootApplication.png" alt="SpringbootApplication"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/EnableAutoConfiguration.png" alt="EnableAutoConfiguration"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/AutoConfigurationImportSelector.png" alt="AutoConfigurationImportSelector"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/getAutoConfigurationEntry%E6%96%B9%E6%B3%95.png" alt="getAutoConfigurationEntry方法"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/getCandidateConfigurations%E6%96%B9%E6%B3%95.png" alt="getCandidateConfigurations方法"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring.factories.png" alt="spring.factories"></p><h2 id="2-Spring-Bean相关注解"><a href="#2-Spring-Bean相关注解" class="headerlink" title="2 Spring Bean相关注解"></a>2 Spring Bean相关注解</h2><h3 id="2-1-Autowired注解"><a href="#2-1-Autowired注解" class="headerlink" title="2.1 @Autowired注解"></a>2.1 <code>@Autowired</code>注解</h3><p>自动导入对象到类，被Spring容器管理</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"\users"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Autowired</span>   <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Component-Repository-Service-Controller注解"><a href="#2-2-Component-Repository-Service-Controller注解" class="headerlink" title="2.2 @Component,@Repository,@Service, @Controller注解"></a>2.2 <code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code>注解</h3><p>如果想要使用<code>@Autowire</code>注解导入对象到指定类，就需要使用注解来标识被引入类，可以使用一下注解：</p><ul><li><strong>@Component</strong>：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</li><li><strong>@Repository</strong>：对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><strong>@Service</strong>：对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><strong>@Controller</strong>：对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="2-3-RestController和Controller注解"><a href="#2-3-RestController和Controller注解" class="headerlink" title="2.3 @RestController和Controller注解"></a>2.3 <code>@RestController</code>和<code>Controller</code>注解</h3><ul><li><strong>@RestController</strong>：是<code>@Controller</code>和<code>@ResponseBody</code>两个注解的合集，只返回对象对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）</li><li><strong>@Controller</strong>：返回一个页面，可以使用Thymeleaf 模板引擎进行渲染</li></ul><blockquote><p>参考链接：<a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485544&amp;idx=1&amp;sn=3cc95b88979e28fe3bfe539eb421c6d8&amp;chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&amp;token=1725092312&amp;lang=zh_CN#rd">@RestController和Controller注解</a></p></blockquote><h3 id="2-4-Scope注解"><a href="#2-4-Scope注解" class="headerlink" title="2.4 @Scope注解"></a>2.4 <code>@Scope</code>注解</h3><p>声明 Spring Bean 的作用域，使用方法:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"singleton"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Person <span class="token function">personSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>四种常见的 Spring Bean 的作用域：</strong></p><ul><li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li><li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li></ul><h2 id="3-HTTP请求"><a href="#3-HTTP请求" class="headerlink" title="3 HTTP请求"></a>3 HTTP请求</h2><ul><li><strong>@GetMapping</strong> ：请求从服务器获取特定资源。举个例子：GET \users（获取所有学生） </li><li><strong>@PostMapping</strong> ：在服务器上创建一个新的资源。举个例子：POST \users（创建学生）</li><li><strong>@PutMapping</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：PUT \users\12（更新编号为 12 的学生）</li><li><strong>@DeleteMapping</strong> ：从服务器删除特定的资源。举个例子：DELETE \users\12（删除编号为 12 的学生）</li><li><strong>@PatchMapping</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li></ul><blockquote><p>相当于<code>@RequestMapping(value="\users\{userId}",method=RequestMethod.*)</code></p></blockquote><h2 id="4-前后端传值"><a href="#4-前后端传值" class="headerlink" title="4 前后端传值"></a>4 前后端传值</h2><h3 id="4-1-PathVariable-和-RequestParam注解"><a href="#4-1-PathVariable-和-RequestParam注解" class="headerlink" title="4.1 @PathVariable 和 @RequestParam注解"></a>4.1 <code>@PathVariable</code> 和 <code>@RequestParam</code>注解</h3><p><code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"\klasses\{klassId}\teachers"</span><span class="token punctuation">)</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Teacher<span class="token operator">></span> <span class="token function">getKlassRelatedTeachers</span><span class="token punctuation">(</span>         <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"klassId"</span><span class="token punctuation">)</span> Long klassId<span class="token punctuation">,</span>         <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"type"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> String type <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果只有@RequestParam String type 的话，则参数type默认必传</p></blockquote><h3 id="4-2-RequestBody注解"><a href="#4-2-RequestBody注解" class="headerlink" title="4.2 @RequestBody注解"></a>4.2 <code>@RequestBody</code>注解</h3><p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 <strong>body</strong> 部分并且<strong>Content-Type 为 application\json 格式</strong>的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。</p><blockquote><p>系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的 body 中的 json 字符串转换为 java 对象。</p></blockquote><h2 id="5-读取配置信息"><a href="#5-读取配置信息" class="headerlink" title="5 读取配置信息"></a>5 读取配置信息</h2><p><strong>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</strong></p><p><code>application.yml</code>文件如下：</p><pre class="line-numbers language-java"><code class="language-java">wuhan2020<span class="token operator">:</span> <span class="token number">2020</span>年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！my<span class="token operator">-</span>profile<span class="token operator">:</span>  name<span class="token operator">:</span> name  email<span class="token operator">:</span> xx<span class="token annotation punctuation">@163</span><span class="token punctuation">.</span>comlibrary<span class="token operator">:</span>  location<span class="token operator">:</span> 湖北武汉加油中国加油  email<span class="token operator">:</span>xx<span class="token annotation punctuation">@163</span><span class="token punctuation">.</span>com  books<span class="token operator">:</span>    <span class="token operator">-</span> name<span class="token operator">:</span> 天才基本法      description<span class="token operator">:</span> 描述<span class="token number">1</span>    <span class="token operator">-</span> name<span class="token operator">:</span> 时间的秩序      description<span class="token operator">:</span> 描述<span class="token number">2</span>    <span class="token operator">-</span> name<span class="token operator">:</span> 了不起的我      description<span class="token operator">:</span> 描述<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-value-常用"><a href="#5-1-value-常用" class="headerlink" title="5.1 @value(常用)"></a>5.1 <code>@value</code>(常用)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${wuhan2020}"</span><span class="token punctuation">)</span>String wuhan2020<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>需要注意的是@value这种方式是不被推荐的，Spring 比较建议的是下面几种读取配置信息的方式。</p></blockquote><h3 id="5-2-ConfigurationProperties-常用"><a href="#5-2-ConfigurationProperties-常用" class="headerlink" title="5.2 @ConfigurationProperties(常用)"></a>5.2 <code>@ConfigurationProperties</code>(常用)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span> \\ 没有加<span class="token annotation punctuation">@Component</span>注解则需要在主类上加<span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span>LibraryProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"library"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Validated</span> \\ 校验需要加此注解，校验失败则启动报错<span class="token keyword">class</span> <span class="token class-name">LibraryProperties</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@NotEmpty</span>    <span class="token keyword">private</span> String location<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Email</span>    <span class="token annotation punctuation">@NotEmpty</span>    <span class="token keyword">private</span> String email<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Book<span class="token operator">></span> books<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Data</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>        String name<span class="token punctuation">;</span>        String description<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>加上<code>@Component</code>注解后可以像Bean一样引入使用</p></blockquote><h3 id="5-3-PropertySource（不常用）"><a href="#5-3-PropertySource（不常用）" class="headerlink" title="5.3 PropertySource（不常用）"></a>5.3 <code>PropertySource</code>（不常用）</h3><p><code>@PropertySource</code>读取指定 properties 文件</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">"classpath:website.properties"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token keyword">class</span> <span class="token class-name">WebSite</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${url}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String url<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-题外话：配置文件读取优先级"><a href="#5-4-题外话：配置文件读取优先级" class="headerlink" title="5.4 题外话：配置文件读取优先级"></a>5.4 题外话：配置文件读取优先级</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="配置文件优先级"></p><blockquote><p>其中如果有集成spring-cloud-config配置中心的话,则优先级最高的是配置中心的配置文件</p></blockquote><h2 id="6-参数校验"><a href="#6-参数校验" class="headerlink" title="6 参数校验"></a>6 参数校验</h2><p><strong>不止前端需要对数据进行初步校验，为了防止绕过浏览器直接访问接口的请求(含有违法\恶意的数据)，后端也需要对参数进行校验</strong></p><p>JSR(Java Specification Requests） 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便！</p><p>SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。</p><p>校验的时候我们实际用的是 Hibernate Validator 框架。</p><h3 id="6-1-一些常用的字段验证的注解"><a href="#6-1-一些常用的字段验证的注解" class="headerlink" title="6.1. 一些常用的字段验证的注解"></a>6.1. 一些常用的字段验证的注解</h3><p><strong>JSR提供的校验注解:</strong></p><ul><li><code>@Null</code> 被注释的元素必须为 null</li><li><code>@NotNull</code> 被注释的元素必须不为 null</li><li><code>@AssertTrue</code> 被注释的元素必须为 true</li><li><code>@AssertFalse</code> 被注释的元素必须为 false</li><li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li><li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li><li><code>@Digits(integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li><code>@Past</code>被注释的元素必须是一个过去的日期</li><li><code>@Future</code> 被注释的元素必须是一个将来的日期</li></ul><blockquote><p>例子：<br>@Pattern(regexp=”^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,10}$", message=”密码必须是6~10位数字和字母的组合<br>private String password;</p></blockquote><p><strong>Hibernate Validator提供的校验注解：</strong></p><ul><li><code>@NotBlank(message =)</code>  验证字符串非null，且长度必须大于0</li><li><code>@NotEmpty</code>  被注释的字符串的必须非空</li><li><code>@Email</code>  被注释的元素必须是电子邮箱地址</li><li><code>@Length(min=,max=)</code> 被注释的字符串的大小必须在指定的范围内</li><li><code>@Range(min=,max=,message=)</code>  被注释的元素必须在合适的范围内</li></ul><p><strong>Controller层在需要校验的接口参数上加上@Valid，类上加上@Validate注解，如果校验失败它将抛出<code>MethodArgumentNotValidException</code>的异常</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"\api"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Validate</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonController</span> <span class="token punctuation">{</span>    \<span class="token operator">*</span><span class="token operator">*</span> PS： <span class="token annotation punctuation">@RequestBody</span>不加的话就通过url的方式拼接在后面<span class="token operator">*</span><span class="token operator">*</span>\    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"\person"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ResponseEntity<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token annotation punctuation">@Valid</span> Person person<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ResponseEntity<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>拓展：<a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485783&amp;idx=1&amp;sn=a407f3b75efa17c643407daa7fb2acd6&amp;chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&amp;token=292197051&amp;lang=zh_CN#rd">如何在 Spring\Spring Boot 中做参数校验</a></p></blockquote><h2 id="7-全局异常处理"><a href="#7-全局异常处理" class="headerlink" title="7 全局异常处理"></a>7 全局异常处理</h2><ul><li>1：<code>@ControllerAdvice</code> :注解定义全局异常处理类</li><li>2：<code>@ExceptionHandler</code> :注解声明异常处理方法</li></ul><p>可以对抛出的异常进行捕获并且进行友好返回等处理</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>    \<span class="token operator">*</span><span class="token operator">*</span>     <span class="token operator">*</span> 请求参数异常处理     <span class="token operator">*</span>\    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>MethodArgumentNotValidException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ResponseEntity<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">handleMethodArgumentNotValidException</span><span class="token punctuation">(</span>MethodArgumentNotValidException ex<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>拓展：<br><a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485568&amp;idx=2&amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;token=2133161636&amp;lang=zh_CN#rd">SpringBoot 处理异常的几种常见姿势</a><br><a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486379&amp;idx=2&amp;sn=48c29ae65b3ed874749f0803f0e4d90e&amp;chksm=cea24460f9d5cd769ed53ad7e17c97a7963a89f5350e370be633db0ae8d783c3a3dbd58c70f8&amp;token=1054498516&amp;lang=zh_CN#rd">使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！</a></p></blockquote><h2 id="8-JPA相关-数据持久层"><a href="#8-JPA相关-数据持久层" class="headerlink" title="8 JPA相关(数据持久层)"></a>8 JPA相关(数据持久层)</h2><h3 id="8-1-创建表"><a href="#8-1-创建表" class="headerlink" title="8.1 创建表"></a>8.1 创建表</h3><ul><li><code>@Entity</code> 声明一个类对应一个数据库实体(实体类)</li><li><code>@Table(name = "table_name")</code> 声明表的名称</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"role"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Role</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String description<span class="token punctuation">;</span>    省略getter\setter<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-创建主键"><a href="#8-2-创建主键" class="headerlink" title="8.2 创建主键"></a>8.2 创建主键</h3><ul><li><code>@Id</code> 声明一个字段为主键。</li><li><code>@GeneratedValue</code> 直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Id</span><span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span><span class="token keyword">private</span> Integer id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>一般使用 MySQL 数据库的话，使用GenerationType.IDENTITY策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）<br>拓展：<a href="https:\www.jianshu.com\p\34d8199ac551">@GeneratedValue注解</a></p></blockquote><h3 id="8-3-设置字段类型"><a href="#8-3-设置字段类型" class="headerlink" title="8.3 设置字段类型"></a>8.3 设置字段类型</h3><ul><li><code>@Column</code> 声明字段。</li></ul><p>示例：</p><p>设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"user_name"</span><span class="token punctuation">,</span> nullable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> length<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token keyword">private</span> String userName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置字段类型并且加默认值，这个还是挺常用的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">Column</span><span class="token punctuation">(</span>columnDefinition <span class="token operator">=</span> <span class="token string">"tinyint(1) default 1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> Boolean enabled<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="8-4-指定不持久化特定字段"><a href="#8-4-指定不持久化特定字段" class="headerlink" title="8.4 指定不持久化特定字段"></a>8.4 指定不持久化特定字段</h3><ul><li><code>@Transient</code> ：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。</li></ul><h3 id="8-5-声明大字段"><a href="#8-5-声明大字段" class="headerlink" title="8.5 声明大字段"></a>8.5 声明大字段</h3><ul><li><code>@Lob</code>:声明某个字段为大字段。</li><li><code>@Column(length = 10000000)</code> 也可</li></ul><p><strong>更详细的声明：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Lob</span>\\指定 Lob 类型数据的获取策略， FetchType<span class="token punctuation">.</span>EAGER 表示非延迟 加载，而 FetchType<span class="token punctuation">.</span> LAZY 表示延迟加载 ；<span class="token annotation punctuation">@Basic</span><span class="token punctuation">(</span>fetch <span class="token operator">=</span> FetchType<span class="token punctuation">.</span>EAGER<span class="token punctuation">)</span>\\columnDefinition 属性指定数据表对应的 Lob 字段类型<span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"content"</span><span class="token punctuation">,</span> columnDefinition <span class="token operator">=</span> <span class="token string">"LONGTEXT NOT NULL"</span><span class="token punctuation">)</span><span class="token keyword">private</span> String content<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-6-创建枚举类型的字段"><a href="#8-6-创建枚举类型的字段" class="headerlink" title="8.6 创建枚举类型的字段"></a>8.6 创建枚举类型的字段</h3><p>可以使用枚举类型的字段，不过枚举字段要用<code>@Enumerated</code>注解修饰。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Gender <span class="token punctuation">{</span>    <span class="token function">MALE</span><span class="token punctuation">(</span><span class="token string">"男性"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">FEMALE</span><span class="token punctuation">(</span><span class="token string">"女性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String value<span class="token punctuation">;</span>    <span class="token function">Gender</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>        value<span class="token operator">=</span>str<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"role"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Role</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String description<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Enumerated</span><span class="token punctuation">(</span>EnumType<span class="token punctuation">.</span>STRING<span class="token punctuation">)</span>    <span class="token keyword">private</span> Gender gender<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-7-增加审计功能"><a href="#8-7-增加审计功能" class="headerlink" title="8.7 增加审计功能"></a>8.7 增加审计功能</h3><p>只要继承了 <code>AbstractAuditBase</code>的类都会默认加上下面四个字段。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> AuditingEntityListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@CreatedDate</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> Instant createdAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedDate</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> Instant updatedAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreatedBy</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> String createdBy<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedBy</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> String updatedBy<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableJpaAuditing</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuditSecurityConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    AuditorAware<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">auditorAware</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>SecurityContextHolder<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>SecurityContext<span class="token operator">:</span><span class="token operator">:</span>getAuthentication<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Authentication<span class="token operator">:</span><span class="token operator">:</span>isAuthenticated<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Authentication<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单介绍一下上面设计到的一些注解：</p><ul><li><p><code>@CreatedDate</code>: 表示该字段为创建时间时间字段，在这个实体被 insert 的时候，会设置值</p></li><li><p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p></li><li><p><code>@LastModifiedDate、@LastModifiedBy</code>同理。</p></li><li><p><code>@EnableJpaAuditing</code>：开启 JPA 审计功能。</p></li></ul><blockquote><p>数据库里面对应存储的是 MAIL\FEMAIL。</p></blockquote><h2 id="9-事务-Transactional"><a href="#9-事务-Transactional" class="headerlink" title="9 事务 @Transactional"></a>9 事务 <code>@Transactional</code></h2><p><code>@Transactional</code> 注解一般用在可以作用在类或者方法上。</p><ul><li>作用于类：当把<code>@Transactional</code> 注解放在类上时，表示所有该类的public 方法都配置相同的事务属性信息。</li><li>作用于方法：当类配置了<code>@Transactional</code>，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。</li></ul><p>事务管理主要分为两种：<code>编程式事务</code> 和 <code>声明式事务</code></p><ul><li><strong>编程式事务</strong>：使用事务代码来手动commit和rollback，代码侵入性比较强</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> DataSourceTransactionManager transactionManager<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    DefaultTransactionDefinition definition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TransactionStatus status <span class="token operator">=</span> transactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>        transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>声明式事务</strong>：基于AOP面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>默认使用<code>@Transactional</code>注解的话，事务传播为<code>Propagation.REQUIRED</code>，rollback为<code>RuntimeException.class</code></p><p>一般POST请求（新增修改删除）则事务传播使用<code>Propagation.REQUIRED</code>，GET请求事务传播使用<code>Propagation.SUPPORTS</code></p><blockquote><p>拓展：<a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486483&amp;idx=2&amp;sn=77be488e206186803531ea5d7164ec53&amp;chksm=cea243d8f9d5cacecaa5c5daae4cde4c697b9b5b21f96dfc6cce428cfcb62b88b3970c26b9c2&amp;token=816772476&amp;lang=zh_CN#rd">Spring 事务管理详解</a></p></blockquote><h2 id="10-Json解析"><a href="#10-Json解析" class="headerlink" title="10 Json解析"></a>10 Json解析</h2><h3 id="10-1-过滤-json-数据"><a href="#10-1-过滤-json-数据" class="headerlink" title="10.1. 过滤 json 数据"></a>10.1. 过滤 json 数据</h3><p>@JsonIgnoreProperties 作用在类上用于过滤掉特定字段不返回或者不解析。</p><pre class="line-numbers language-java"><code class="language-java">\\生成json时将userRoles属性过滤<span class="token annotation punctuation">@JsonIgnoreProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"userRoles"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String fullName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>UserRole<span class="token operator">></span> userRoles <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@JsonIgnore一般用于类的属性上，作用和上面的@JsonIgnoreProperties 一样。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String fullName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>   \\生成json时将userRoles属性过滤    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>UserRole<span class="token operator">></span> userRoles <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-2-格式化-json-数据"><a href="#10-2-格式化-json-数据" class="headerlink" title="10.2. 格式化 json 数据"></a>10.2. 格式化 json 数据</h3><p>@JsonFormat一般用来格式化 json 数据。</p><p>比如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@JsonFormat</span><span class="token punctuation">(</span>shape<span class="token operator">=</span>JsonFormat<span class="token punctuation">.</span>Shape<span class="token punctuation">.</span>STRING<span class="token punctuation">,</span> pattern<span class="token operator">=</span><span class="token string">"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"</span><span class="token punctuation">,</span> timezone<span class="token operator">=</span><span class="token string">"GMT"</span><span class="token punctuation">)</span><span class="token keyword">private</span> Date date<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="10-3-扁平化对象-JsonUnwrapped"><a href="#10-3-扁平化对象-JsonUnwrapped" class="headerlink" title="10.3. 扁平化对象 - @JsonUnwrapped"></a>10.3. 扁平化对象 - <code>@JsonUnwrapped</code></h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@ToString</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonUnwrapped</span>    <span class="token keyword">private</span> Location location<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonUnwrapped</span>    <span class="token keyword">private</span> PersonInfo personInfo<span class="token punctuation">;</span>  <span class="token annotation punctuation">@Getter</span>  <span class="token annotation punctuation">@Setter</span>  <span class="token annotation punctuation">@ToString</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Location</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> String provinceName<span class="token punctuation">;</span>     <span class="token keyword">private</span> String countyName<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Getter</span>  <span class="token annotation punctuation">@Setter</span>  <span class="token annotation punctuation">@ToString</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PersonInfo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String fullName<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>未扁平化之前：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>    <span class="token string">"location"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"provinceName"</span><span class="token operator">:</span><span class="token string">"湖北"</span><span class="token punctuation">,</span>        <span class="token string">"countyName"</span><span class="token operator">:</span><span class="token string">"武汉"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"personInfo"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"userName"</span><span class="token operator">:</span> <span class="token string">"coder1234"</span><span class="token punctuation">,</span>        <span class="token string">"fullName"</span><span class="token operator">:</span> <span class="token string">"shaungkou"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用@JsonUnwrapped 扁平对象之后：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@ToString</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonUnwrapped</span>    <span class="token keyword">private</span> Location location<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonUnwrapped</span>    <span class="token keyword">private</span> PersonInfo personInfo<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"provinceName"</span><span class="token operator">:</span><span class="token string">"湖北"</span><span class="token punctuation">,</span>  <span class="token string">"countyName"</span><span class="token operator">:</span><span class="token string">"武汉"</span><span class="token punctuation">,</span>  <span class="token string">"userName"</span><span class="token operator">:</span> <span class="token string">"coder1234"</span><span class="token punctuation">,</span>  <span class="token string">"fullName"</span><span class="token operator">:</span> <span class="token string">"shaungkou"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参考链接：<br>1：<a href="https:\github.com\Snailclimb\JavaGuide\blob\master\docs\system-design\framework\spring\spring-annotations.md">Spring\Spring常用注解总结！- JavaGuide</a><br>2：<a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485544&amp;idx=1&amp;sn=3cc95b88979e28fe3bfe539eb421c6d8&amp;chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&amp;token=1725092312&amp;lang=zh_CN#rd">@RestController vs @Controller</a><br>3：<a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486181&amp;idx=2&amp;sn=10db0ae64ef501f96a5b0dbc4bd78786&amp;chksm=cea2452ef9d5cc384678e456427328600971180a77e40c13936b19369672ca3e342c26e92b50&amp;token=816772476&amp;lang=zh_CN#rd">SpringBoot 如何优雅读取配置文件</a><br>4：<a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485783&amp;idx=1&amp;sn=a407f3b75efa17c643407daa7fb2acd6&amp;chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&amp;token=292197051&amp;lang=zh_CN#rd">如何在 Spring\Spring Boot 中做参数校验</a><br>5：<a href="https:\mp.weixin.qq.com\s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486483&amp;idx=2&amp;sn=77be488e206186803531ea5d7164ec53&amp;chksm=cea243d8f9d5cacecaa5c5daae4cde4c697b9b5b21f96dfc6cce428cfcb62b88b3970c26b9c2&amp;token=816772476&amp;lang=zh_CN#rd">Spring 事务管理详解</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常工作中的策略模式轻实践</title>
      <link href="/posts/strategy-pattern.html"/>
      <url>/posts/strategy-pattern.html</url>
      
        <content type="html"><![CDATA[<h1 id="日常工作中的策略模式轻实践"><a href="#日常工作中的策略模式轻实践" class="headerlink" title="日常工作中的策略模式轻实践"></a>日常工作中的策略模式轻实践</h1><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0.引言"></a>0.引言</h2><p>在座的各位应该都知道，在日常的面试中，设计模式都是面试官屡试不爽的面试主题，借这个话题，面试官可以从面试者的回答中了解他对设计模式的熟悉程度，是否有自己的理解，更可以挖掘平时是否付诸实践，从而初步判断面试者对代码解耦的理解程度。今天，我们就来谈谈其中之一也是最常见的设计模式-策略模式，在我们的日常工作中如何运用上，达到轻松解耦(zhuangbei)的目的。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-yeah.png" alt="oh yeah"></p><h2 id="1-场景简述"><a href="#1-场景简述" class="headerlink" title="1.场景简述"></a>1.场景简述</h2><p>基本在每个设计支付的项目中，我们都会涉及到这个场景：</p><p>用户用手机下单之后，支付请求发送至服务端接口，api接口根据请求参数判断为属于<strong>支付宝支付</strong>还是<strong>微信支付</strong>，又或者是<strong>京东支付</strong>或者<strong>银联支付</strong>，经过校验\计算订单金额等通用流程后，来调用第三方支付接口进行支付和支付回调。这里包括我可能都选择第2点的做法，我们来看：</p><h2 id="2-一般做法"><a href="#2-一般做法" class="headerlink" title="2.一般做法"></a>2.一般做法</h2><p>在controller层的接口进入服务端，再经过分布式锁之后，调用service层来执行相应的业务逻辑，而后通过if else的方式分别进入不同的方法来调用第三方预支付接口，大概通过以下伪代码可以看出：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-%E4%B8%8D%E7%9C%8B%E4%B8%8D%E7%9C%8B.png" alt="不看不看"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 伪代码 1.支付宝 2.微信 3....</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.校验 根据不同支付通道来进行不同的校验 </span>    <span class="token comment" spellcheck="true">// 需要if else</span>    <span class="token function">validate</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.计算金额 这里可能因为支付方式的不同</span>    <span class="token comment" spellcheck="true">// 也需要if else计算金额</span>    <span class="token function">calculate</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.创建订单 这里因为业务不同,例如订单记录支付通道</span>    <span class="token comment" spellcheck="true">// 所以也需要if else</span>    <span class="token function">createOrder</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// n.调用第三方支付接口 </span>    <span class="token comment" spellcheck="true">// 需要if else</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>channel <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">aliRequest</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>channel <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">wxPayRequest</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">aliRequest</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用支付宝第三方支付预创建接口</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">wxPayRequest</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用微信第三方支付预创建接口</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相信大多数人都是都是这样写的，包括笔者自己，因为确实没有一些问题，毕竟只是简单的判断，if else就完事了，还要啥自行车？</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-%E5%BF%AB%E4%B9%90%E5%B0%B1%E5%AE%8C%E4%BA%8B%E4%BA%86.png" alt="快落就完事了"></p><p>但是去年，因为需求我需要做支付宝小程序支付，需要在支付中信拓展支付宝小程序支付时，看了下同事支付端的代码结构，发现自己在集成时非常方便，只需要实现支付接口拓展一个甚至不需要动同事的代码再加上一些业务代码即可，他省事我也省事。顿时觉得自己还是太年轻了。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-zz.jpg" alt="zz"></p><h2 id="3-别样思考"><a href="#3-别样思考" class="headerlink" title="3.别样思考"></a>3.别样思考</h2><h3 id="3-1-缘起"><a href="#3-1-缘起" class="headerlink" title="3.1 缘起"></a>3.1 缘起</h3><p>在做完这个需求后的最近，支付同事离职了，自己暂时接管支付这部分的内容，所以也对这部分代码进行了复盘，受益良多。</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-%E7%9C%9F.jpg" alt="真?"></p><p>大家应该有听过开闭原则：对修改关闭，对扩展开放。这个原则是说，在设计一个软件模块时，应该使这个模块可以在不被修改的前提下被扩展。换句话说，就是应该可以在不修改原有源代码的情况下，改变这个模块的行为。我感觉，这个结构还是听符合开闭原则的，让编码者码着舒服让参与者无压力加入。</p><h3 id="3-2-代码结构图"><a href="#3-2-代码结构图" class="headerlink" title="3.2 代码结构图"></a>3.2 代码结构图</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="结构图"></p><h3 id="3-3-简单说明"><a href="#3-3-简单说明" class="headerlink" title="3.3 简单说明"></a>3.3 简单说明</h3><p>strategy模块可以从以下图中看出端倪：</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-strategy%E6%A8%A1%E5%9D%97.png" alt="strategy模块"></p><p>首先定义了一个PayStrategy接口类，声明了基本的方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PayStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * 校验     * @param payRequest     */</span>    <span class="token keyword">void</span> <span class="token function">validate</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * 处理支付请求     * @param payRequest     * @return     */</span>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * 请求第三方支付接口     * @param payRequest     */</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里其中，request就是前面所谈能够替代if else的核心🔑。<br>接着，当然是得创建类来实现这个接口了，不过再这之前需要对这个接口做一层抽象，作用的话我们稍后再谈。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BasePayStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">PayStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     *  缓存&lt;支付通道,支付实例>     */</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> PayStrategy<span class="token operator">></span> payMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * 根据支付通道获取支付策略实例     * @param channel     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> PayStrategy <span class="token function">getPayStrategy</span><span class="token punctuation">(</span>Integer channel<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> payMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里可以写通用流程</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"【此处BasePayStrategy】执行调用第三方支付接口前的通用流程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1.校验</span>        <span class="token function">validateParams</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.计算支付金额</span>        BigDecimal totalFee <span class="token operator">=</span> <span class="token function">calculateFee</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.预创建订单等...</span>        <span class="token function">preCreateOrder</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">,</span>totalFee<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// n.调用第三方支付接口</span>        <span class="token function">request</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">validateParams</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"这里校验通用的参数,例如是否为有效用户\商品是否有效已下架等"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不同通道的特定参数校验</span>        <span class="token function">validate</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> BigDecimal <span class="token function">calculateFee</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 计算金额 如果也需要不同渠道计算金额也可和校验参数一样设计</span>        <span class="token keyword">return</span> BigDecimal<span class="token punctuation">.</span>ZERO<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preCreateOrder</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">,</span> BigDecimal totalFee<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 预创建订单 如果也需要不同渠道计算金额也可和校验参数一样设计</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以从代码中看到，抽象类中做了一层缓存，而目的就是存储每个通道对应的策略实例类。在请求发起时，工厂类可以根据请求中的通道参数获取对应的策略实例类进行处理。（不小心简单工厂模式就上手了，代码看下方）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ApplicationContext context<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取对应支付类型的策略实例     * @param channel     * @return     */</span>    <span class="token keyword">public</span> PayStrategy <span class="token function">getPayStrategy</span><span class="token punctuation">(</span>Integer channel<span class="token punctuation">)</span><span class="token punctuation">{</span>        PayStrategy payStrategy <span class="token operator">=</span> BasePayStrategy<span class="token punctuation">.</span><span class="token function">getPayStrategy</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>payStrategy <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span>FAIL_CODE<span class="token punctuation">,</span><span class="token string">"无效支付通道"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>payStrategy<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用工厂：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> PayFactory payFactory<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 这里直接省略了分布式锁\service类\聚合类，直接写在api方法上     * @param payRequest     * @return     */</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"\pay1"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pay1</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> PayRequest payRequest<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.根据支付通道获取对应支付策略类</span>        Integer channel <span class="token operator">=</span> payRequest<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PayStrategy payStrategy <span class="token operator">=</span> payFactory<span class="token punctuation">.</span><span class="token function">getPayStrategy</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.封装支付请求处理器(策略模式)</span>        PayHandler payHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayHandler</span><span class="token punctuation">(</span>payStrategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.处理请求</span>        payHandler<span class="token punctuation">.</span><span class="token function">processRequest</span><span class="token punctuation">(</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续这个抽象类，可以看出他只实现了PayStrategy的process方法，这个方法在这里起到中间层承上启下的作用，可以在这其中进行相关的校验\计算\订单创建等操作，再执行调用第三方接口-request方法，看下面两个具体的策略实现类</p><p>AliPayStrategy：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AliPayStrategy</span> <span class="token keyword">extends</span> <span class="token class-name">BasePayStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        payMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>AliPay<span class="token punctuation">.</span><span class="token function">getPayChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">validate</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"校验支付宝通道的特殊参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"\n██【调用阿里支付接口】\n██接口参数:{}"</span><span class="token punctuation">,</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用阿里支付接口流程</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WxPayStrategy：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WxPayStrategy</span> <span class="token keyword">extends</span> <span class="token class-name">BasePayStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        payMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>WxPay<span class="token punctuation">.</span><span class="token function">getPayChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">validate</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"校验微信通道的特殊参数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span>PayRequest payRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"\n██【调用微信支付接口】\n██接口参数:{}"</span><span class="token punctuation">,</span>payRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用微信支付接口流程</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个就是具体的通道实现，在日志备注中可以看出相应的作用了吧！是不是觉得很简单！</p><h3 id="3-4-测试与demo"><a href="#3-4-测试与demo" class="headerlink" title="3.4 测试与demo"></a>3.4 测试与demo</h3><p>当然，代码只有执行了才能印证一切<br><strong><a href="https://github.com/xuyikai1/JavaDemo">源码demo</a></strong></p><p>启动项目，调用 <strong>http:\localhost:8081\pay</strong> 接口</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-%E8%AF%B7%E6%B1%82.png" alt="postman调用+请求参数"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-%E6%97%A5%E5%BF%97.png" alt="打印日志"></p><p>怎么样，是不是觉得代码清新了许多！</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/strategy-%E7%A8%B3.png" alt="稳"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常工作应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job分布式调度的简单实践</title>
      <link href="/posts/xxl-job.html"/>
      <url>/posts/xxl-job.html</url>
      
        <content type="html"><![CDATA[<h1 id="xxl-job任务调度中心文档"><a href="#xxl-job任务调度中心文档" class="headerlink" title="xxl-job任务调度中心文档"></a>xxl-job任务调度中心文档</h1><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0.简介"></a>0.简介</h2><blockquote><p>官方文档地址：<a href="https://www.xuxueli.com/xxl-job/#">分布式任务调度平台XXL-JOB</a></p></blockquote><p>  XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。<br>  本文只介绍xxl-job的简单使用</p><h2 id="1-xxl-job管理端"><a href="#1-xxl-job管理端" class="headerlink" title="1.xxl-job管理端"></a>1.xxl-job管理端</h2><h3 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1 配置文件"></a>1.1 配置文件</h3><pre class="line-numbers language-java"><code class="language-java">### 调度中心数据库链接<span class="token punctuation">,</span>xxl<span class="token operator">-</span>job相关表存放的数据库spring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>url<span class="token operator">=</span>jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>xxl_job<span class="token operator">?</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>characterEncoding<span class="token operator">=</span>UTF<span class="token operator">-</span><span class="token number">8</span><span class="token operator">&amp;</span>autoReconnect<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>serverTimezone<span class="token operator">=</span>Asia<span class="token operator">/</span>Shanghaispring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>username<span class="token operator">=</span>rootspring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>password<span class="token operator">=</span>root_pwdspring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>driver<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>name<span class="token operator">=</span>com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver### 报警邮箱spring<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>host<span class="token operator">=</span>smtp<span class="token punctuation">.</span>qq<span class="token punctuation">.</span>comspring<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">25</span>spring<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>username<span class="token operator">=</span>xxx<span class="token annotation punctuation">@qq</span><span class="token punctuation">.</span>comspring<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>password<span class="token operator">=</span>xxxspring<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>properties<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>smtp<span class="token punctuation">.</span>auth<span class="token operator">=</span><span class="token boolean">true</span>spring<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>properties<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>smtp<span class="token punctuation">.</span>starttls<span class="token punctuation">.</span>enable<span class="token operator">=</span><span class="token boolean">true</span>spring<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>properties<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>smtp<span class="token punctuation">.</span>starttls<span class="token punctuation">.</span>required<span class="token operator">=</span><span class="token boolean">true</span>spring<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>properties<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>smtp<span class="token punctuation">.</span>socketFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token operator">=</span>javax<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>SSLSocketFactory### 调度中心通讯TOKEN <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：非空时启用；xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>accessToken<span class="token operator">=</span>### 调度中心国际化配置 <span class="token punctuation">[</span>必填<span class="token punctuation">]</span>： 默认为 <span class="token string">"zh_CN"</span><span class="token operator">/</span>中文简体<span class="token punctuation">,</span> 可选范围为 <span class="token string">"zh_CN"</span><span class="token operator">/</span>中文简体<span class="token punctuation">,</span> <span class="token string">"zh_TC"</span><span class="token operator">/</span>中文繁体 and <span class="token string">"en"</span><span class="token operator">/</span>英文；xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>i18n<span class="token operator">=</span>zh_CN## 调度线程池最大线程配置【必填】xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>triggerpool<span class="token punctuation">.</span>fast<span class="token punctuation">.</span>max<span class="token operator">=</span><span class="token number">200</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>triggerpool<span class="token punctuation">.</span>slow<span class="token punctuation">.</span>max<span class="token operator">=</span><span class="token number">100</span>### 调度中心日志表数据保存天数 <span class="token punctuation">[</span>必填<span class="token punctuation">]</span>：过期日志自动清理；限制大于等于<span class="token number">7</span>时生效，否则<span class="token punctuation">,</span> 如<span class="token operator">-</span><span class="token number">1</span>，关闭自动清理功能；xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>logretentiondays<span class="token operator">=</span><span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-部署启动"><a href="#1-2-部署启动" class="headerlink" title="1.2 部署启动"></a>1.2 部署启动</h3><blockquote><p>xxl-job管理端地址：<a href="http://localhost:8080/xxl-job-admin/">任务调度中心</a></p></blockquote><p>可访问代表启动成功</p><h3 id="1-3-界面说明（演示xxl-job版本为2-0-2）"><a href="#1-3-界面说明（演示xxl-job版本为2-0-2）" class="headerlink" title="1.3 界面说明（演示xxl-job版本为2.0.2）"></a>1.3 界面说明（演示xxl-job版本为2.0.2）</h3><h4 id="1-3-1-执行器管理"><a href="#1-3-1-执行器管理" class="headerlink" title="1.3.1 执行器管理"></a>1.3.1 执行器管理</h4><p>  一个独立的应用绑定着一个执行器，例如对账项目绑定着对账执行器，项目启动后，可以在执行器管理中的【OnLine 机器地址】这一列查看到绑定成功的ip+端口，显示即表示在管理端注册成功，至此启动的应用可提供被管理端执行相应的job</p><blockquote><p>执行器需要进行创建<br>执行器检测采用的是心跳检测，所以项目关闭时会有延迟</p></blockquote><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/xxl-job-1.png" alt="1"></p><h4 id="1-3-2-任务管理"><a href="#1-3-2-任务管理" class="headerlink" title="1.3.2 任务管理"></a>1.3.2 任务管理</h4><p>  选择相应的执行器，对账项目中创建的job对应这里的一个任务</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/xxl-job-2.png" alt="2"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/xxl-job-3.png" alt="3"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/xxl-job-4.png" alt="4"></p><blockquote><p>cron：定义任务执行的规律<br>JobHandler：对应项目中创建的job类</p></blockquote><h4 id="1-3-3-日志管理"><a href="#1-3-3-日志管理" class="headerlink" title="1.3.3 日志管理"></a>1.3.3 日志管理</h4><p>  在项目中穿插使用XxlJobLogger.log(..)来打日志（使用方式与Slfj相似），方便调试和检查问题，在每个任务中可查看执行日志<br>  PS：日志只支持字符串,日志展示的类需要使用该类的toString,例如XxlJobLogger.log(“\n██【设备商品信息】\n██{}”,pmsTermGoods.toString());</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/xxl-job-5.png" alt="5"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 分布式任务调度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试都要谈的设计模式</title>
      <link href="/posts/design-pattern.html"/>
      <url>/posts/design-pattern.html</url>
      
        <content type="html"><![CDATA[<h1 id="面试都要谈的设计模式"><a href="#面试都要谈的设计模式" class="headerlink" title="面试都要谈的设计模式"></a>面试都要谈的设计模式</h1><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p><p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p><ol><li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FoodFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Food <span class="token function">makeFood</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"noodle"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Food noodle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LanZhouNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            noodle<span class="token punctuation">.</span><span class="token function">addSpicy</span><span class="token punctuation">(</span><span class="token string">"more"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> noodle<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"chicken"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Food chicken <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HuangMenChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            chicken<span class="token punctuation">.</span><span class="token function">addCondiment</span><span class="token punctuation">(</span><span class="token string">"potato"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> chicken<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p><p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FoodFactory</span> <span class="token punctuation">{</span>    Food <span class="token function">makeFood</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChineseFoodFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FoodFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Food <span class="token function">makeFood</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ChineseFoodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ChineseFoodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericanFoodFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FoodFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Food <span class="token function">makeFood</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AmericanFoodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AmericanFoodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">APP</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先选择一个具体的工厂</span>        FoodFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChineseFoodFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span>        Food food <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">makeFood</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p><p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/factory-1.png" alt="factory-1"></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png" alt="factory-1"></p><p>这个时候的客户端调用是这样的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 得到 Intel 的 CPU</span>CPUFactory cpuFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntelCPUFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>CPU cpu <span class="token operator">=</span> intelCPUFactory<span class="token punctuation">.</span><span class="token function">makeCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 得到 AMD 的主板</span>MainBoardFactory mainBoardFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmdMainBoardFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MainBoard mainBoard <span class="token operator">=</span> mainBoardFactory<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 组装 CPU 和主板</span>Computer computer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Computer</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> mainBoard<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png" alt="abstract-factory-2"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png" alt="abstract-factory-3"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第一步就要选定一个“大厂”</span>    ComputerFactory cf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmdFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从这个大厂造 CPU</span>    CPU cpu <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">makeCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从这个大厂造主板</span>    MainBoard board <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">makeMainBoard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 从这个大厂造硬盘</span>      HardDisk hardDisk <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">makeHardDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span>    Computer result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Computer</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> board<span class="token punctuation">,</span> hardDisk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p><p>饿汉模式最简单：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，将 new Singleton() 堵死</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span>    <span class="token comment" spellcheck="true">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Date <span class="token function">getDate</span><span class="token punctuation">(</span>String mode<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p></blockquote><p>饱汉模式最容易出错：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，也是先堵死 new Singleton() 这条路</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Singleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这一次判断也是必须的，不然会有并发问题</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton3</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton3 instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton3 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Holder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p><p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p><pre class="line-numbers language-java"><code class="language-java">Food food <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FoodBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Food food <span class="token operator">=</span> Food<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p><p>来一个中规中矩的建造者模式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 下面是“一堆”的属性</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> String nickName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造方法私有化，不然客户端就会直接调用构造方法了</span>    <span class="token keyword">private</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String password<span class="token punctuation">,</span> String nickName<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nickName <span class="token operator">=</span> nickName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span>    <span class="token comment" spellcheck="true">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> UserBuilder <span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">UserBuilder</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 下面是和 User 一模一样的一堆属性</span>        <span class="token keyword">private</span> String  name<span class="token punctuation">;</span>        <span class="token keyword">private</span> String password<span class="token punctuation">;</span>        <span class="token keyword">private</span> String nickName<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token function">UserBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span>        <span class="token keyword">public</span> UserBuilder <span class="token function">name</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> UserBuilder <span class="token function">password</span><span class="token punctuation">(</span>String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> UserBuilder <span class="token function">nickName</span><span class="token punctuation">(</span>String nickName<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>nickName <span class="token operator">=</span> nickName<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> UserBuilder <span class="token function">age</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span>        <span class="token comment" spellcheck="true">// 当然，可以在 “复制” 之前做点检验</span>        <span class="token keyword">public</span> User <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> null <span class="token operator">||</span> password <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"用户名和密码必填"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> age <span class="token operator">>=</span> <span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"年龄不合法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 还可以做赋予”默认值“的功能</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>nickName <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nickName <span class="token operator">=</span> name<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">,</span> nickName<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p><p>看看客户端的调用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">APP</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User d <span class="token operator">=</span> User<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">password</span><span class="token punctuation">(</span><span class="token string">"pAss12345"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">age</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><blockquote><p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Builder</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String  name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> String nickName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><pre class="line-numbers language-java"><code class="language-java">User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p></blockquote><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p><p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p><p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">native</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p></blockquote><p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p><p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><blockquote><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FoodService</span> <span class="token punctuation">{</span>    Food <span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Food <span class="token function">makeNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FoodServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">FoodService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Food <span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          Food f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span><span class="token function">setChicken</span><span class="token punctuation">(</span><span class="token string">"1kg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          f<span class="token punctuation">.</span><span class="token function">setSpicy</span><span class="token punctuation">(</span><span class="token string">"1g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          f<span class="token punctuation">.</span><span class="token function">setSalt</span><span class="token punctuation">(</span><span class="token string">"3g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> f<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Food <span class="token function">makeNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Food f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Noodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setNoodle</span><span class="token punctuation">(</span><span class="token string">"500g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setSalt</span><span class="token punctuation">(</span><span class="token string">"5g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> f<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FoodServiceProxy</span> <span class="token keyword">implements</span> <span class="token class-name">FoodService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span>    <span class="token keyword">private</span> FoodService foodService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FoodServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Food <span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我们马上要开始制作鸡肉了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span>        <span class="token comment" spellcheck="true">// 代理只是在核心代码前后做些“无足轻重”的事情</span>        Food food <span class="token operator">=</span> foodService<span class="token punctuation">.</span><span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"鸡肉制作完成啦，加点胡椒粉"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 增强</span>          food<span class="token punctuation">.</span><span class="token function">addCondiment</span><span class="token punctuation">(</span><span class="token string">"pepper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> food<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Food <span class="token function">makeNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"准备制作拉面~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Food food <span class="token operator">=</span> foodService<span class="token punctuation">.</span><span class="token function">makeNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"制作完成啦"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> food<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端调用，注意，我们要用代理来实例化接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这里用代理类来实例化</span>FoodService foodService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FoodServiceProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>foodService<span class="token punctuation">.</span><span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://www.javadoop.com/blogimages/design-pattern/proxy-1.png" alt="proxy"></p><p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p><p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p><p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p><p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式<strong>默认适配器模式(Default Adapter)</strong>是怎么样的。</p><p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FileAlterationListener</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token keyword">final</span> FileAlterationObserver observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">onDirectoryCreate</span><span class="token punctuation">(</span><span class="token keyword">final</span> File directory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">onDirectoryChange</span><span class="token punctuation">(</span><span class="token keyword">final</span> File directory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">onDirectoryDelete</span><span class="token punctuation">(</span><span class="token keyword">final</span> File directory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">onFileCreate</span><span class="token punctuation">(</span><span class="token keyword">final</span> File file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">onFileChange</span><span class="token punctuation">(</span><span class="token keyword">final</span> File file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">onFileDelete</span><span class="token punctuation">(</span><span class="token keyword">final</span> File file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">onStop</span><span class="token punctuation">(</span><span class="token keyword">final</span> FileAlterationObserver observer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileAlterationListenerAdaptor</span> <span class="token keyword">implements</span> <span class="token class-name">FileAlterationListener</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token keyword">final</span> FileAlterationObserver observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDirectoryCreate</span><span class="token punctuation">(</span><span class="token keyword">final</span> File directory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDirectoryChange</span><span class="token punctuation">(</span><span class="token keyword">final</span> File directory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDirectoryDelete</span><span class="token punctuation">(</span><span class="token keyword">final</span> File directory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFileCreate</span><span class="token punctuation">(</span><span class="token keyword">final</span> File file<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFileChange</span><span class="token punctuation">(</span><span class="token keyword">final</span> File file<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFileDelete</span><span class="token punctuation">(</span><span class="token keyword">final</span> File file<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStop</span><span class="token punctuation">(</span><span class="token keyword">final</span> FileAlterationObserver observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileMonitor</span> <span class="token keyword">extends</span> <span class="token class-name">FileAlterationListenerAdaptor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFileCreate</span><span class="token punctuation">(</span><span class="token keyword">final</span> File file<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 文件创建</span>        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFileDelete</span><span class="token punctuation">(</span><span class="token keyword">final</span> File file<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 文件删除</span>        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Duck</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 鸭的呱呱叫</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 飞</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Cock</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">gobble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 鸡的咕咕叫</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 飞</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WildCock</span> <span class="token keyword">implements</span> <span class="token class-name">Cock</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">gobble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"咕咕叫"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"鸡也会飞哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CockAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Duck</span> <span class="token punctuation">{</span>    Cock cock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span>      <span class="token keyword">public</span> <span class="token function">CockAdapter</span><span class="token punctuation">(</span>Cock cock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cock <span class="token operator">=</span> cock<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 实现鸭的呱呱叫方法</span>    <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 内部其实是一只鸡的咕咕叫</span>        cock<span class="token punctuation">.</span><span class="token function">gobble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cock<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端调用很简单了：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 有一只野鸡</span>      Cock wildCock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WildCock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 成功将野鸡适配成鸭</span>      Duck duck <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CockAdapter</span><span class="token punctuation">(</span>wildCock<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p><p>我们用一个图来简单说明下：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-1.png" alt="adapter-1"></p><p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-2.png" alt="adapter-1"></p><p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol><li><p>类适配和对象适配的异同</p><blockquote><p>一个采用继承，一个采用组合；</p><p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p><p>总体来说，对象适配用得比较多。</p></blockquote></li><li><p>适配器模式和代理模式的异同</p><p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p></li></ol><h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p><p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DrawAPI</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后是一系列实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedPen</span> <span class="token keyword">implements</span> <span class="token class-name">DrawAPI</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用红色笔画图，radius:"</span> <span class="token operator">+</span> radius <span class="token operator">+</span> <span class="token string">", x:"</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">", y:"</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GreenPen</span> <span class="token keyword">implements</span> <span class="token class-name">DrawAPI</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用绿色笔画图，radius:"</span> <span class="token operator">+</span> radius <span class="token operator">+</span> <span class="token string">", x:"</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">", y:"</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BluePen</span> <span class="token keyword">implements</span> <span class="token class-name">DrawAPI</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用蓝色笔画图，radius:"</span> <span class="token operator">+</span> radius <span class="token operator">+</span> <span class="token string">", x:"</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">", y:"</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> DrawAPI drawAPI<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token function">Shape</span><span class="token punctuation">(</span>DrawAPI drawAPI<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>drawAPI <span class="token operator">=</span> drawAPI<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义抽象类的子类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 圆形</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> radius<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> DrawAPI drawAPI<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>drawAPI<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> radius<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        drawAPI<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>radius<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 长方形</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> DrawAPI drawAPI<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>drawAPI<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        drawAPI<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们来看客户端演示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Shape greenCircle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">GreenPen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Shape redRectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RedPen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    greenCircle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    redRectangle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p><blockquote><p>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm">这里</a>的例子，并对其进行了修改。</p></blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-1.png" alt="decorator-1"></p><p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p><blockquote><p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p></blockquote><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator*</strong> 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p><blockquote><p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p></blockquote><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p><p>不说废话了，上代码。</p><p>首先，定义饮料抽象基类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 返回描述</span>      <span class="token keyword">public</span> <span class="token keyword">abstract</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 返回价格</span>      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlackTea</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"红茶"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GreenTea</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"绿茶"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">11</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 咖啡省略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 调料</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Condiment</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Lemon</span> <span class="token keyword">extends</span> <span class="token class-name">Condiment</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Beverage bevarage<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span>    <span class="token comment" spellcheck="true">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span>    <span class="token keyword">public</span> <span class="token function">Lemon</span><span class="token punctuation">(</span>Beverage bevarage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bevarage <span class="token operator">=</span> bevarage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 装饰</span>        <span class="token keyword">return</span> bevarage<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 加柠檬"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 装饰</span>        <span class="token keyword">return</span> beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加柠檬需要 2 元</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mango</span> <span class="token keyword">extends</span> <span class="token class-name">Condiment</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Beverage bevarage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Mango</span><span class="token punctuation">(</span>Beverage bevarage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bevarage <span class="token operator">=</span> bevarage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> bevarage<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 加芒果"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加芒果需要 3 元</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 给每一种调料都加一个类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看客户端调用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span>    Beverage beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GreenTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 开始装饰</span>    beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lemon</span><span class="token punctuation">(</span>beverage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先加一份柠檬</span>    beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mongo</span><span class="token punctuation">(</span>beverage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 再加一份芒果</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beverage<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 价格：￥"</span> <span class="token operator">+</span> beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//"绿茶, 加柠檬, 加芒果 价格：￥16"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p><pre class="line-numbers language-java"><code class="language-java">Beverage beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mongo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pearl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Lemon</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Lemon</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BlackTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是不是很变态？</p><p>看看下图可能会清晰一些：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-2.png" alt="decorator-2"></p><p>到这里，大家应该已经清楚装饰模式了吧。</p><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-3.png" alt="decorator-3"></p><p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p><p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><pre class="line-numbers language-java"><code class="language-java">InputStream inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LineNumberInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p><p>我们应该像下面这样使用：</p><pre class="line-numbers language-java"><code class="language-java">DataInputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>                              <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>                                  <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p><p>首先，我们定义一个接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>   <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义几个实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Circle::draw()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Rectangle::draw()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端调用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 画一个圆形</span>      Shape circle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      circle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 画一个长方形</span>      Shape rectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      rectangle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p><p>我们先定义一个门面：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShapeMaker</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> Shape circle<span class="token punctuation">;</span>   <span class="token keyword">private</span> Shape rectangle<span class="token punctuation">;</span>   <span class="token keyword">private</span> Shape square<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">ShapeMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      circle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      rectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      square <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定   */</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      circle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawRectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      rectangle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawSquare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      square<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看现在客户端怎么调用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ShapeMaker shapeMaker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShapeMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 客户端调用现在更加清晰了</span>  shapeMaker<span class="token punctuation">.</span><span class="token function">drawCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shapeMaker<span class="token punctuation">.</span><span class="token function">drawRectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shapeMaker<span class="token punctuation">.</span><span class="token function">drawSquare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p><p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> String name<span class="token punctuation">;</span>   <span class="token keyword">private</span> String dept<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> salary<span class="token punctuation">;</span>   <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> subordinates<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 下属</span>   <span class="token keyword">public</span> <span class="token function">Employee</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>String dept<span class="token punctuation">,</span> <span class="token keyword">int</span> sal<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>dept <span class="token operator">=</span> dept<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> sal<span class="token punctuation">;</span>      subordinates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Employee e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      subordinates<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Employee e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      subordinates<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> <span class="token function">getSubordinates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> subordinates<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"Employee :[ Name : "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", dept : "</span> <span class="token operator">+</span> dept <span class="token operator">+</span> <span class="token string">", salary :"</span> <span class="token operator">+</span> salary<span class="token operator">+</span><span class="token string">" ]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p><p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p><p>这种简单的代码我就不演示了。</p><h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><p>首先，先定义一个策略接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后我们定义具体的几个策略：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedPen</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用红色笔画图，radius:"</span> <span class="token operator">+</span> radius <span class="token operator">+</span> <span class="token string">", x:"</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">", y:"</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GreenPen</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用绿色笔画图，radius:"</span> <span class="token operator">+</span> radius <span class="token operator">+</span> <span class="token string">", x:"</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">", y:"</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BluePen</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用蓝色笔画图，radius:"</span> <span class="token operator">+</span> radius <span class="token operator">+</span> <span class="token string">", x:"</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">", y:"</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用策略的类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> Strategy strategy<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>Strategy strategy<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">executeDraw</span><span class="token punctuation">(</span><span class="token keyword">int</span> radius<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> strategy<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>radius<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端演示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BluePen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用绿色笔来画</span>      context<span class="token punctuation">.</span><span class="token function">executeDraw</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>放到一张图上，让大家看得清晰些：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/strategy-1.png" alt="strategy-1"></p><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p><p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 数据已变更，通知观察者们</span>        <span class="token function">notifyAllObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 注册观察者</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 通知观察者们</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyAllObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer observer <span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义观察者接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Subject subject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p><p>我们来定义具体的几个观察者类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryObserver</span> <span class="token keyword">extends</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在构造方法中进行订阅主题</span>    <span class="token keyword">public</span> <span class="token function">BinaryObserver</span><span class="token punctuation">(</span>Subject subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通常在构造方法中将 this 发布出去的操作一定要小心</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 该方法由主题类在数据变更的时候进行调用</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String result <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>subject<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"订阅的数据发生变化，新的数据处理为二进制值为："</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HexaObserver</span> <span class="token keyword">extends</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">HexaObserver</span><span class="token punctuation">(</span>Subject subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String result <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>subject<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"订阅的数据发生变化，新的数据处理为十六进制值为："</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端使用也非常简单：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先定义一个主题</span>    Subject subject1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义观察者</span>    <span class="token keyword">new</span> <span class="token class-name">BinaryObserver</span><span class="token punctuation">(</span>subject1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">HexaObserver</span><span class="token punctuation">(</span>subject1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span>    subject<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>output:</p><pre><code>订阅的数据发生变化，新的数据处理为二进制值为：1011订阅的数据发生变化，新的数据处理为十六进制值为：B</code></pre><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><blockquote><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p></blockquote><p>首先，我们要定义流程上节点的基类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">RuleHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 后继节点</span>    <span class="token keyword">protected</span> RuleHandler successor<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSuccessor</span><span class="token punctuation">(</span>RuleHandler successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">=</span> successor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> RuleHandler <span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> successor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们需要定义具体的每个节点了。</p><p>校验用户是否是新用户：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewUserRuleHandler</span> <span class="token keyword">extends</span> <span class="token class-name">RuleHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">isNewUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果有后继节点的话，传递下去</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"该活动仅限新用户参与"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>校验用户所在地区是否可以参与：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LocationRuleHandler</span> <span class="token keyword">extends</span> <span class="token class-name">RuleHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> allowed <span class="token operator">=</span> activityService<span class="token punctuation">.</span><span class="token function">isSupportedLocation</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>getLocation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>allowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"非常抱歉，您所在的地区无法参与本次活动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>校验奖品是否已领完：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LimitRuleHandler</span> <span class="token keyword">extends</span> <span class="token class-name">RuleHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> remainedTimes <span class="token operator">=</span> activityService<span class="token punctuation">.</span><span class="token function">queryRemainedTimes</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 查询剩余奖品</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remainedTimes <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"您来得太晚了，奖品被领完了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RuleHandler newUserHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewUserRuleHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RuleHandler locationHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LocationRuleHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RuleHandler limitHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LimitRuleHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span>    locationHandler<span class="token punctuation">.</span><span class="token function">setSuccessor</span><span class="token punctuation">(</span>limitHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    locationHandler<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p><p>通常会有一个抽象类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractTemplate</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这就是模板方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这个是重点</span>        <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可以作为钩子方法</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"init 抽象层已经实现，子类也可以选择覆写"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 留给子类实现</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p>我们写一个实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteTemplate</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractTemplate</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类实现抽象方法 apply"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端调用演示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    AbstractTemplate t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用模板方法</span>    t<span class="token punctuation">.</span><span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p>定义状态接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义减库存的状态：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeductState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"商品卖出，准备减库存"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//... 执行减库存的具体操作</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Deduct State"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义补库存状态：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RevertState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"给此商品补库存"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//... 执行加库存的具体操作</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Revert State"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> State state<span class="token punctuation">;</span>      <span class="token keyword">private</span> String name<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>State state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来看下客户端调用，大家就一清二楚了：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 我们需要操作的是 iPhone X</span>    Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token string">"iPhone X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 看看怎么进行补库存操作</span>      State revertState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RevertState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      revertState<span class="token punctuation">.</span><span class="token function">doAction</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同样的，减库存操作也非常简单</span>      State deductState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeductState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      deductState<span class="token punctuation">.</span><span class="token function">doAction</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 如果需要我们可以获取当前的状态</span>    <span class="token comment" spellcheck="true">// context.getState().toString();</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p><p>（全文完）</p><blockquote><p>原文作者：javadoop<br>原文链接：<a href="https://javadoop.com/post/design-pattern">https://javadoop.com/post/design-pattern</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Redis客户端Redisson</title>
      <link href="/posts/redisson.html"/>
      <url>/posts/redisson.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><h2 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1.分布式锁"></a>1.分布式锁</h2><h3 id="1-单应用使用锁"><a href="#1-单应用使用锁" class="headerlink" title="(1) 单应用使用锁"></a>(1) 单应用使用锁</h3><p><strong>说明</strong>：使用 Java 的 <strong>Synchronized</strong> 或者 <strong>ReentrantLock</strong> 关键字加锁</p><p><strong>缺点</strong>：当用户扩大并发飙升时，单应用扛不住流量出现宕机从而影响整个项目，如果选择用多加机器的方式来解决，此加锁方式无法解决超卖等问题（库存为1，两个应用分别从两台服务器中请求进来）</p><blockquote><p>各个服务器加的锁只对属于自己 JVM 里面的线程有效，对于其他 JVM 的线程是无效的,所以只适合并发量不大的单应用场景</p></blockquote><h3 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="(2) 分布式锁"></a>(2) 分布式锁</h3><blockquote><p>原理：为整个集群或者系统中提供一个全局唯一能获取锁的应用（redis、ZK等），不同服务器在同一业务场景下获取的锁保证为同一个锁</p></blockquote><h4 id="传统redis分布式锁"><a href="#传统redis分布式锁" class="headerlink" title="传统redis分布式锁"></a>传统redis分布式锁</h4><p><strong>获取锁</strong>： Redis SETNX命令(后期redis版本使用set命令同步设置过期时间即可)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取锁 </span><span class="token comment" spellcheck="true">// NX是指如果key不存在就成功，key存在返回false，PX可以指定过期时间 </span>SET anyLock unique_value NX PX <span class="token number">30000</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>释放锁</strong>：通过执行一段lua脚本</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>释放锁涉及到两条指令，这两条指令不是原子性的 <span class="token number">2</span><span class="token punctuation">.</span>需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的 Lua脚本代码：<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> then    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>关键点</strong>：<br>1.必须使用set命令（附上NX），单独使用set和设置过期时间不为原子操作<br>2.set命令（附上NX）设置的value必须具有唯一性，例如随机字符串（防止A获取锁因为时间超时导致锁释放后B获取锁，A再释放B刚获取到的锁的问题）</p></blockquote><h4 id="redis部署方式弊端"><a href="#redis部署方式弊端" class="headerlink" title="redis部署方式弊端"></a>redis部署方式弊端</h4><ul><li><strong>单机模式</strong>：当这台redis宕机之后就无法提供加锁导致业务血崩</li><li><strong>主从\集群模式</strong>：当master节点宕机，哨兵sentinel选举后发生主从切换时，原先的从节点可能丢失锁</li></ul><h4 id="红锁RedLock"><a href="#红锁RedLock" class="headerlink" title="红锁RedLock"></a>红锁RedLock</h4><blockquote><p>无法保证加锁的过程一定正确 </p></blockquote><h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h3><h4 id="传统redis分布式锁的弊端"><a href="#传统redis分布式锁的弊端" class="headerlink" title="传统redis分布式锁的弊端"></a>传统redis分布式锁的弊端</h4><blockquote><p>  使用setnx命令设置超时时间为30s，但是当30s过后业务A未执行完但是另外一个线程\请求B已进来也获取到该锁，而后业务A执行结束释放锁，就会出现超卖等线程安全问题；<br>PS：所以需要人为根据业务来维护这个超时时间</p></blockquote><h4 id="redisson优点"><a href="#redisson优点" class="headerlink" title="redisson优点"></a>redisson优点</h4><h5 id="1-传统分布式锁弊端解决-watchDog看门狗"><a href="#1-传统分布式锁弊端解决-watchDog看门狗" class="headerlink" title="1.传统分布式锁弊端解决 - watchDog看门狗"></a>1.传统分布式锁弊端解决 - watchDog看门狗</h5><p>  看门狗作用：监控锁</p><blockquote><p>1：当获取锁没有设置key超时时间时，会设置默认超时时间为30s，之后看门狗会每隔10s把key的超时时间延长至30s，保证锁一直被当前线程占用直至业务结束释放锁<br>2：Redisson 的“看门狗”逻辑保证了没有死锁发生。(如果机器宕机了，看门狗也就没了。此时就不会延长 Key 的过期时间，到了 30s 之后就会自动过期了，其他线程可以获取到锁)<br>3：当设置了key超时时间时，则超时key会自动释放<br>4：个人思考：加锁是加在了当前redis实例中，当实例redis宕机时，看门狗消失就不会延长时间而自动过期（当为redis主从集群例如三主三从时，每个key根据算法（相关：只分配给master的槽节点）分配到对应redis中）</p></blockquote><h5 id="2-使用简单"><a href="#2-使用简单" class="headerlink" title="2.使用简单"></a>2.使用简单</h5><pre class="line-numbers language-java"><code class="language-java">Config config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addNodeAddress</span><span class="token punctuation">(</span><span class="token string">"redis:\\192.168.31.101:7001"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDatabase</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> RedissonClient redissonClient <span class="token operator">=</span> Redisson<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span> RLock lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"anyLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 尝试加锁，最多等待lockTime毫秒，上锁以后leaseTime毫秒自动解锁</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span>leaseTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"lockKey = {}，重复提交！"</span><span class="token punctuation">,</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">,</span><span class="token string">"请勿重复提交！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>1：Redisson 所有指令都通过 Lua 脚本执行，Redis 支持 Lua 脚本原子性执行。</p></blockquote><h2 id="2-发布订阅实现配置缓存相关操作"><a href="#2-发布订阅实现配置缓存相关操作" class="headerlink" title="2.发布订阅实现配置缓存相关操作"></a>2.发布订阅实现配置缓存相关操作</h2><p><strong>说明</strong>：redisson简单的api + springboot CommandLineRunner实现启动时执行配置初始化和发布订阅的功能，当redis客户端发布命令时，进行相应的操作</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> CommandLineRunner <span class="token function">init</span><span class="token punctuation">(</span>ApplicationContext ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> args <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// RedissonClient在config中已配置</span>        RedissonClient redissonClient <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>RedissonClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SysTenantServiceImpl sysTenantService <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>SysTenantServiceImpl<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化配置</span>        sysTenantService<span class="token punctuation">.</span><span class="token function">initSysTenant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// redis发布订阅</span>        RTopic<span class="token operator">&lt;</span>String<span class="token operator">></span> topic <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span>KEY<span class="token punctuation">,</span> StringCodec<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加监听器</span>        topic<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            JSONObject msg <span class="token operator">=</span> JSONUtil<span class="token punctuation">.</span><span class="token function">parseObj</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"DEL"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>MapUtil<span class="token punctuation">.</span><span class="token function">getStr</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"action"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sysTenantService<span class="token punctuation">.</span><span class="token function">removeByOrgId</span><span class="token punctuation">(</span>MapUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"Id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"ALL"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>MapUtil<span class="token punctuation">.</span><span class="token function">getStr</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"action"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sysTenantService<span class="token punctuation">.</span><span class="token function">initSysTenant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"UPDATE"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>MapUtil<span class="token punctuation">.</span><span class="token function">getStr</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"action"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sysTenantService<span class="token punctuation">.</span><span class="token function">updateByOrgId</span><span class="token punctuation">(</span>MapUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"Id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TOPIC-BILL-BOOK-CONFIG-REFRESH Listener创建成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>redis 客户端命令例子：<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> publish KEY <span class="token string">"{\"action\":\"ALL\"}"</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> publish KEY <span class="token string">"{\"action"</span><span class="token operator">:</span>\<span class="token string">"DEL\", \"Id\":\"1\"}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-布隆过滤器-bloomfilter"><a href="#3-布隆过滤器-bloomfilter" class="headerlink" title="3.布隆过滤器 - bloomfilter"></a>3.布隆过滤器 - bloomfilter</h2><blockquote><p>PS：创建布隆过滤器需要根据业务场关注 <strong>期望插入值</strong> 和 <strong>判断失误的概率</strong><br>详细了解布隆过滤器可参考笔者写的<a href="http:\xuyk.top\posts\bloom-filter.html">5分钟搞懂布隆过滤器 | 寒暄</a></p></blockquote><pre class="line-numbers language-java"><code class="language-java"># <span class="token number">1</span><span class="token punctuation">.</span>从redis获取布隆过滤器RBloomFilter<span class="token operator">&lt;</span>String<span class="token operator">></span> filter <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getBloomFilter</span><span class="token punctuation">(</span><span class="token string">"testBloomFilter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span># <span class="token number">2</span><span class="token punctuation">.</span>不存在则初始化filter<span class="token punctuation">.</span><span class="token function">tryInit</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span># <span class="token number">3</span><span class="token punctuation">.</span>新增<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    filter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>StrUtil<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span># <span class="token number">4</span><span class="token punctuation">.</span>判断是否存在<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"key:{},是否存在：{}"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>filter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>StrUtil<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-redis集群配置-redis-cluster"><a href="#4-redis集群配置-redis-cluster" class="headerlink" title="4.redis集群配置 - redis cluster"></a>4.redis集群配置 - redis cluster</h2><p>集群初始化配置</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> nodes <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"redis:\\192.168.10.139:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"redis:\\192.168.10.140:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"redis:\\192.168.10.141:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"redis:\\192.168.10.142:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"redis:\\192.168.10.143:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"redis:\\192.168.10.144:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">toStrArray</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>Config config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ClusterServersConfig clusterServersConfig <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">useClusterServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>clusterServersConfig        <span class="token punctuation">.</span><span class="token function">setScanInterval</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 集群状态扫描间隔时间，单位是毫秒</span>        <span class="token punctuation">.</span><span class="token function">addNodeAddress</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>redissonClient <span class="token operator">=</span> Redisson<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【参考链接】<br>1：<a href="https:\zhuanlan.zhihu.com\p\73807097">分布式锁</a><br>2：<a href="https:\zhuanlan.zhihu.com\p\78300382">Redis解析：SET复合命令和简易的分布式锁优化</a><br>3：<a href="http:\www.redis.cn\commands\set.html">redis官方文档 – set 命令</a><br>4：<a href="https:\github.com\redisson\redisson\wiki%E7%9B%AE%E5%BD%95">redisson官方文档</a><br>5：<a href="https:\github.com\Snailclimb\JavaGuide\blob\master\docs\dataStructures-algorithms\data-structure\bloom-filter.md">布隆过滤器</a><br>6：<a href="https:\zhuanlan.zhihu.com\p\111354065">细说Redis分布式锁</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redisson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事件发布监听机制实现业务解耦</title>
      <link href="/posts/spring-event.html"/>
      <url>/posts/spring-event.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring事件发布监听机制实现业务解耦"><a href="#Spring事件发布监听机制实现业务解耦" class="headerlink" title="Spring事件发布监听机制实现业务解耦"></a>Spring事件发布监听机制实现业务解耦</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><blockquote><p>假设一个下单场景，订单创建成功后可能有一些后续逻辑要处理，但是和创建订单本身没有关系，此时就可以在创建订单完成后，发送一个消息，有相应部分的代码进行监听处理，避免代码耦合到一起</p></blockquote><p>这样的解决思路类似于MQ，但是小项目有时候又不需要MQ这样的第三方队列来实现，那么就可以使用Spring Context包的<strong>事件发布监听的机制来进行处理</strong></p><h2 id="2-Spring事件发布监听机制"><a href="#2-Spring事件发布监听机制" class="headerlink" title="2.Spring事件发布监听机制"></a>2.Spring事件发布监听机制</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring%20event.png" alt="spring-event"></p><p><strong>流程：</strong> 当事件源（发布者）发布事件时，相应监听此事件的监听者接收到事件对象并且进行处理</p><p>Spring的事件发布监听机制本质上就是<strong>发布-订阅</strong>，即<strong>生产者-消费者</strong>，也体现了设计模式中的<strong>观察者模式</strong></p><h2 id="3-三要素"><a href="#3-三要素" class="headerlink" title="3.三要素"></a>3.三要素</h2><ul><li>ApplicationEvent：事件</li><li>ApplicationListener：事件监听者</li><li>ApplicationEventPublisher：事件发布者</li></ul><h3 id="3-1-事件（ApplicationEvent）"><a href="#3-1-事件（ApplicationEvent）" class="headerlink" title="3.1 事件（ApplicationEvent）"></a>3.1 事件（ApplicationEvent）</h3><p><strong>消息类：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Builder</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long messageId<span class="token punctuation">;</span>    <span class="token keyword">private</span> String content<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事件包含的实体类</p></blockquote><p><strong>事件类：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Setter</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 4181929072911659524L<span class="token punctuation">;</span>    <span class="token keyword">private</span> Message message<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MessageEvent</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事件类，继承了ApplicationEvent，并且包含了传递实体类Message</p></blockquote><p><strong>MessageEvent的关系类图（Diagram）：</strong></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring%20event%20diagram.png" alt="spring even diagram"></p><p><strong>其中ApplicationEvent的源码：</strong></p><pre class="line-numbers language-java"><code class="language-java">\<span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">*</span> Class <span class="token class-name">to</span> be extended by all application events<span class="token punctuation">.</span> Abstract as it <span class="token operator">*</span> doesn't make sense <span class="token keyword">for</span> generic events to be published directly<span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token annotation punctuation">@author</span> Rod Johnson <span class="token operator">*</span> <span class="token annotation punctuation">@author</span> Juergen Hoeller <span class="token operator">*</span> <span class="token annotation punctuation">@see</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationListener <span class="token operator">*</span> <span class="token annotation punctuation">@see</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>event<span class="token punctuation">.</span>EventListener <span class="token operator">*</span>\<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationEvent</span> <span class="token keyword">extends</span> <span class="token class-name">EventObject</span> <span class="token punctuation">{</span>    \<span class="token operator">*</span><span class="token operator">*</span> use serialVersionUID from Spring <span class="token number">1.2</span> <span class="token keyword">for</span> interoperability<span class="token punctuation">.</span> <span class="token operator">*</span>\    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 7099057708183571937L<span class="token punctuation">;</span>    \<span class="token operator">*</span><span class="token operator">*</span> System time when the event happened<span class="token punctuation">.</span> <span class="token operator">*</span>\    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timestamp<span class="token punctuation">;</span>    \<span class="token operator">*</span><span class="token operator">*</span>     <span class="token operator">*</span> Create a <span class="token keyword">new</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@code</span> ApplicationEvent<span class="token punctuation">}</span><span class="token punctuation">.</span>     <span class="token operator">*</span> <span class="token annotation punctuation">@param</span> source the object on which the event initially occurred or with     <span class="token operator">*</span> which the event is <span class="token function">associated</span> <span class="token punctuation">(</span>never <span class="token punctuation">{</span><span class="token annotation punctuation">@code</span> null<span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token operator">*</span>\    <span class="token keyword">public</span> <span class="token function">ApplicationEvent</span><span class="token punctuation">(</span>Object source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    \<span class="token operator">*</span><span class="token operator">*</span>     <span class="token operator">*</span> Return the system time in milliseconds when the event occurred<span class="token punctuation">.</span>     <span class="token operator">*</span>\    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以看出ApplicationEvent有<strong>记录发生event的时间</strong>，并且source的意义就是<strong>当做发布事件的实体类</strong></p></blockquote><h3 id="3-2-事件监听者（ApplicationListener）"><a href="#3-2-事件监听者（ApplicationListener）" class="headerlink" title="3.2 事件监听者（ApplicationListener）"></a>3.2 事件监听者（ApplicationListener）</h3><p><strong>事件监听类：方式一（EventListener注解实现）</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageListener</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@EventListener</span><span class="token punctuation">(</span>value <span class="token operator">=</span> MessageEvent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span>MessageEvent event<span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"\n██listener1线程:{}"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> "\" <span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"event:{}"</span><span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        \\ 处理逻辑    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注解实现监听的原理：</strong></p><p>1：查看<code>@EventListener</code>注解的调用链，其中EventListenerMethodProcessor类的processBean方法（1）</p><pre class="line-numbers language-java"><code class="language-java">\\ 截取的代码Map<span class="token operator">&lt;</span>Method<span class="token punctuation">,</span> EventListener<span class="token operator">></span> annotatedMethods <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>  annotatedMethods <span class="token operator">=</span> MethodIntrospector<span class="token punctuation">.</span><span class="token function">selectMethods</span><span class="token punctuation">(</span>targetType<span class="token punctuation">,</span>      <span class="token punctuation">(</span>MethodIntrospector<span class="token punctuation">.</span>MetadataLookup<span class="token operator">&lt;</span>EventListener<span class="token operator">></span><span class="token punctuation">)</span> method <span class="token operator">-</span><span class="token operator">></span>          AnnotatedElementUtils<span class="token punctuation">.</span><span class="token function">findMergedAnnotation</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> EventListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>  \\ An unresolvable type in a method signature<span class="token punctuation">,</span> probably from a lazy bean <span class="token operator">-</span> let's ignore it<span class="token punctuation">.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Could not resolve methods for bean with name '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>获取所有被<code>@EventListener</code>注解修饰的Listener</p></blockquote><p>2：EventListenerMethodProcessor类的processBean方法（2）</p><pre class="line-numbers language-java"><code class="language-java">\\ 截取的代码\\ Non<span class="token operator">-</span>empty set of methodsConfigurableApplicationContext context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>context <span class="token operator">!=</span> null<span class="token punctuation">,</span> <span class="token string">"No ApplicationContext set"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>EventListenerFactory<span class="token operator">></span> factories <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>eventListenerFactories<span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>factories <span class="token operator">!=</span> null<span class="token punctuation">,</span> <span class="token string">"EventListenerFactory List not initialized"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> annotatedMethods<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>EventListenerFactory factory <span class="token operator">:</span> factories<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>factory<span class="token punctuation">.</span><span class="token function">supportsMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Method methodToUse <span class="token operator">=</span> AopUtils<span class="token punctuation">.</span><span class="token function">selectInvocableMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ApplicationListener<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> applicationListener <span class="token operator">=</span>                    factory<span class="token punctuation">.</span><span class="token function">createApplicationListener</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> targetType<span class="token punctuation">,</span> methodToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>applicationListener <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationListenerMethodAdapter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ApplicationListenerMethodAdapter<span class="token punctuation">)</span> applicationListener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>evaluator<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            context<span class="token punctuation">.</span><span class="token function">addApplicationListener</span><span class="token punctuation">(</span>applicationListener<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用Listener Factory类生产出所有被<code>@EventListener</code>的类注入进Spring Context</p></blockquote><p><strong>事件监听类：方式二（实现ApplicationListener接口）</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageListener2</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>MessageEvent<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>MessageEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"\n██listener2线程:{}"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> "\" <span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"event:{}"</span><span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        \\ 处理逻辑    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现接口来实现监听的原理：</strong></p><p>1：<strong>ApplicationListenerDetector的postProcessAfterInitialization方法</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationListener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            \\ potentially not detected as a listener by getBeanNamesForType retrieval            Boolean flag <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonNames<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                \\ singleton <span class="token function">bean</span> <span class="token punctuation">(</span>top<span class="token operator">-</span>level or inner<span class="token punctuation">)</span><span class="token operator">:</span> register on the fly                <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">addApplicationListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ApplicationListener<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">containsBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    \\ inner bean with other scope <span class="token operator">-</span> can't reliably process events                    logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Inner bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' implements ApplicationListener interface "</span> <span class="token operator">+</span>                            <span class="token string">"but is not reachable for event multicasting by its containing ApplicationContext "</span> <span class="token operator">+</span>                            <span class="token string">"because it does not have singleton scope. Only top-level listener beans are allowed "</span> <span class="token operator">+</span>                            <span class="token string">"to be of non-singleton scope."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>singletonNames<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>判断一个Bean如果是ApplicationListener，则也是使用context.addApplicationListener添加</p></blockquote><p><strong>总结：</strong> 相对于实现ApplicationListener接口来监听事件的方式，<strong>使用注解的方式更加简便</strong>，并且方式二一个监听类只能监听一个事件，方式一则可新增方法来监听多个其他的事件</p><h3 id="3-3-事件发布者（ApplicationEventPublisher）"><a href="#3-3-事件发布者（ApplicationEventPublisher）" class="headerlink" title="3.3 事件发布者（ApplicationEventPublisher）"></a>3.3 事件发布者（ApplicationEventPublisher）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> ApplicationContext applicationContext<span class="token punctuation">;</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"\sendMessage"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"\n██Test线程:{}"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> "\" <span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Message newMessage <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">messageId</span><span class="token punctuation">(</span>20200610111500000L<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token string">"消息内容"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MessageEvent event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageEvent</span><span class="token punctuation">(</span>newMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>    \\ 事件发布    applicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"消息发送成功"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事件发布原理分析：</strong></p><p><strong>1：查看ApplicationContext类</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationContext</span> <span class="token keyword">extends</span> <span class="token class-name">EnvironmentCapable</span><span class="token punctuation">,</span> ListableBeanFactory<span class="token punctuation">,</span> HierarchicalBeanFactory<span class="token punctuation">,</span>        MessageSource<span class="token punctuation">,</span> ApplicationEventPublisher<span class="token punctuation">,</span> ResourcePatternResolver <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>ApplicationContext实现了ApplicationEventPublisher类的pulish方法，ApplicationContext的抽象类AbstractApplicationContext里阐述了具体的publishEvent方法</p></blockquote><p><strong>2：AbstractApplicationContext类的publishEvent方法</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span>Object event<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ResolvableType eventType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token string">"Event must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        \\ Decorate event as an ApplicationEvent <span class="token keyword">if</span> necessary        ApplicationEvent applicationEvent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            applicationEvent <span class="token operator">=</span> <span class="token punctuation">(</span>ApplicationEvent<span class="token punctuation">)</span> event<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            applicationEvent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayloadApplicationEvent</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>eventType <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                eventType <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PayloadApplicationEvent<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> applicationEvent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResolvableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        \\ Multicast right now <span class="token keyword">if</span> possible <span class="token operator">-</span> or lazily once the multicaster is initialized        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>earlyApplicationEvents <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>earlyApplicationEvents<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>applicationEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">getApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multicastEvent</span><span class="token punctuation">(</span>applicationEvent<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        \\ Publish event via parent context as well<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token keyword">instanceof</span> <span class="token class-name">AbstractApplicationContext</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>AbstractApplicationContext<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>getApplicationEventMulticaster().multicastEvent方法可以看出事件是通过<strong>SimpleApplicationEventMulticaster的multicastEvent方法</strong>发布的</p></blockquote><p>3：<strong>SimpleApplicationEventMulticaster的multicastEvent方法</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">multicastEvent</span><span class="token punctuation">(</span><span class="token keyword">final</span> ApplicationEvent event<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ResolvableType eventType<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ResolvableType type <span class="token operator">=</span> <span class="token punctuation">(</span>eventType <span class="token operator">!=</span> null <span class="token operator">?</span> eventType <span class="token operator">:</span> <span class="token function">resolveDefaultEventType</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Executor executor <span class="token operator">=</span> <span class="token function">getTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>ApplicationListener<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> listener <span class="token operator">:</span> <span class="token function">getApplicationListeners</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">invokeListener</span><span class="token punctuation">(</span>listener<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token function">invokeListener</span><span class="token punctuation">(</span>listener<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以看出如果设置了Executor（线程池）的话，则异步执行监听方法，否则执行同步方法<br>所以后续可以用设置Executor的方法实现异步</p></blockquote><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>Postman调用sendMessage接口，成功实现功能</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/spring%20event%20log.png" alt="spring event log"></p><h2 id="5-支持异步"><a href="#5-支持异步" class="headerlink" title="5.支持异步"></a>5.支持异步</h2><h3 id="5-1-设置Executor的方法实现异步（推荐）"><a href="#5-1-设置Executor的方法实现异步（推荐）" class="headerlink" title="5.1 设置Executor的方法实现异步（推荐）"></a>5.1 设置Executor的方法实现异步（推荐）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"applicationEventMulticaster"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ApplicationEventMulticaster <span class="token function">simpleApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SimpleApplicationEventMulticaster eventMulticaster                <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        eventMulticaster<span class="token punctuation">.</span><span class="token function">setTaskExecutor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleAsyncTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> eventMulticaster<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-异步注解"><a href="#5-2-异步注解" class="headerlink" title="5.2 异步注解"></a>5.2 异步注解</h3><p><strong>1：主类新增<code>@EnableAsync</code>注解开启异步</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableAsync</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringEventDemoApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringEventDemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2：监听类监听方法新增注解<code>@Async</code></strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageListener</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Async</span>    <span class="token annotation punctuation">@EventListener</span><span class="token punctuation">(</span>value <span class="token operator">=</span> MessageEvent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span>MessageEvent event<span class="token punctuation">)</span><span class="token punctuation">{</span>        ThreadUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"\n██listener1线程:{}"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> "\" <span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"event:{}"</span><span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这种做法可以实现异步，但是其实有点违背了Spring事件机制的设计初衷，所以推荐第一种做法实现异步</p></blockquote><h2 id="6-Demo代码"><a href="#6-Demo代码" class="headerlink" title="6.Demo代码"></a>6.Demo代码</h2><p><a href="https://github.com/xuyikai1/JavaDemo">JavaDemo：spring-event-demo</a></p><blockquote><p>参考链接：<br><a href="https:\zhuanlan.zhihu.com\p\101128672">Spring事件监听机制 - 知乎</a><br><a href="https:\zhuanlan.zhihu.com\p\145927110">深入浅出Spring\SpringBoot 事件监听机制 - 知乎</a><br><a href="https:\blog.csdn.net\fenglllle\article\details\88370998">Spring事件发布监听</a><br><a href="http:\zhengw-tech.com\2019\11\30\practical-spring-function\">spring 事件及异步方法使用</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常工作应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Event </tag>
            
            <tag> 事件监听 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5分钟搞懂布隆过滤器</title>
      <link href="/posts/bloom-filter.html"/>
      <url>/posts/bloom-filter.html</url>
      
        <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0.引言"></a>0.引言</h2><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/bloomfilter-douyin.png" alt=""></p><p>P：我们平时在刷抖音时，开发人员如何保证 <strong>不会刷到同样的内容</strong> ？</p><ul><li>1：<strong>把算法推荐中的内容根据历史记录做一遍筛选</strong>？在用户量大，用户查看内容多的场景，<strong>性能低</strong></li><li>2：<strong>历史记录全部计入缓存</strong>？资源量大，并且会随着时间逐渐上涨，<strong>服务器耗费up</strong></li><li>3：<strong>布隆过滤器</strong>？专门用于解决去重问题，存在一定误判概率但是在去重的同时能节省90%的空间</li></ul><h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1.使用场景"></a>1.使用场景</h2><ul><li>1：<strong>在数据量很大(5亿以上)的场景下判断某一数据是否存在</strong>。对比hashMap节省了很大的存储空间</li><li>2：<strong>黑名单、邮箱的垃圾邮件过滤</strong>。正常邮件被放入垃圾邮箱，就是布隆过滤器的误判导致</li><li>3：<strong>去重</strong>。例如爬虫时，对已经爬取过的内容去重</li><li>4：<strong>缓存穿透</strong>（非法用户会使用一般数据库里没有的key来进行访问导致请求一直打到数据库，导致数据库崩溃）。布隆过滤器删除key困难（会影响其他key），更建议直接使用redis set（设置过期时间）</li></ul><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/bloomFilter%20blackList.png" alt="黑名单解决缓存穿透"></p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/bloomFilter%20whiteList.png" alt="白名单解决缓存穿透"></p><h2 id="2-什么是布隆过滤器"><a href="#2-什么是布隆过滤器" class="headerlink" title="2.什么是布隆过滤器"></a>2.什么是布隆过滤器</h2><h3 id="2-1数据结构"><a href="#2-1数据结构" class="headerlink" title="2.1数据结构"></a>2.1数据结构</h3><p>布隆过滤器（Bloom Filter）1970年由Bloom的老哥提出</p><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/bloomFilter-init.png" alt="init"></p><p>它由一个二进制数组来记录数据的相关性,数组中只有1或0</p><blockquote><p>二进制数组的优势：申请一个 100w 个元素的位数组只占用 1000000Bit \ 8 = 125000 Byte = 125000\1024 kb ≈ 122kb 的空间。</p></blockquote><p>因为数组为固定长度，在数据量越多而空间越少的情况，判断误差率会变大</p><h3 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h3><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/bloomFilter-add.png" alt="add"></p><p><strong>当一个元素加入布隆过滤器时：</strong></p><ol><li>布隆过滤器中的多个哈希函数对元素值进行计算，得到索引值，之后数组长度对该索引值取模算的数组位置</li><li>多个哈希函数有多个计算后的数组位置，置为1，完成add操作</li></ol><p><img src="https://xuyk-picture-bed.oss-cn-beijing.aliyuncs.com/bloomFilter-exist.png" alt="exist"></p><p><strong>当判断一个元素是否存在时：</strong></p><ol><li>多个哈希函数对元素值计算出位置后，如果有一个位置值为0，则肯定不存在</li><li>如果多个位置值都为1，则表示极有可能存在（可能其他元素把这几个位置提前置为1了，导致的误判）</li></ol><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><h4 id="1-使用注意点"><a href="#1-使用注意点" class="headerlink" title="1. 使用注意点"></a>1. 使用注意点</h4><ol><li>使用时 不要让实际元素数量远大于初始化数量；</li><li>当实际元素数量超过初始化数量时，应该对布隆过滤器进行 重建，重新分配一个 size 更大的过滤器，再将所有的历史元素批量 add 进行；</li><li>初始化的数量和误判率根据实际业务场景分配</li></ol><h4 id="2-场景"><a href="#2-场景" class="headerlink" title="2. 场景"></a>2. 场景</h4><h5 id="1-单机场景中-Guava-Bloom-Filter"><a href="#1-单机场景中-Guava-Bloom-Filter" class="headerlink" title="1. 单机场景中 - Guava Bloom Filter"></a>1. 单机场景中 - Guava Bloom Filter</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>依赖<span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>guava<span class="token operator">&lt;</span>\groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>guava<span class="token operator">&lt;</span>\artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">28.0</span><span class="token operator">-</span>jre<span class="token operator">&lt;</span>\version<span class="token operator">></span><span class="token operator">&lt;</span>\dependency<span class="token operator">></span># <span class="token number">2</span><span class="token punctuation">.</span>使用# <span class="token number">2.1</span> 创建布隆过滤器对象BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> filter <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>        Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token number">1500</span><span class="token punctuation">,</span>        <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span># <span class="token number">2.2</span> 判断指定元素是否存在System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span># <span class="token number">2.3</span> 将元素添加进布隆过滤器filter<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>filter<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-分布式场景中-Redisson-Bloom-Filter"><a href="#2-分布式场景中-Redisson-Bloom-Filter" class="headerlink" title="2. 分布式场景中 - Redisson Bloom Filter"></a>2. 分布式场景中 - Redisson Bloom Filter</h5><pre class="line-numbers language-java"><code class="language-java"># <span class="token number">1</span><span class="token punctuation">.</span>依赖<span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>redisson<span class="token operator">&lt;</span>\groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>redisson<span class="token operator">&lt;</span>\artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">3.7</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token operator">&lt;</span>\version<span class="token operator">></span><span class="token operator">&lt;</span>\dependency<span class="token operator">></span># <span class="token number">2</span><span class="token punctuation">.</span>获取存储在redis中的布隆过滤器RBloomFilter<span class="token operator">&lt;</span>String<span class="token operator">></span> filter <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getBloomFilter</span><span class="token punctuation">(</span><span class="token string">"BloomFilter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span># <span class="token number">3</span><span class="token punctuation">.</span>不存在时初始化<span class="token punctuation">,</span>filter<span class="token punctuation">.</span><span class="token function">tryInit</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    # <span class="token number">4</span><span class="token punctuation">.</span>新增    filter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>StrUtil<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span># <span class="token number">5</span><span class="token punctuation">.</span>判断是否存在<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"key:{},是否存在：{}"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>filter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>StrUtil<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参考链接：<br>1：<a href="https:\github.com\Snailclimb\JavaGuide\blob\master\docs\dataStructures-algorithms\data-structure\bloom-filter.md">JavaGuide - 布隆过滤器</a><br>2：<a href="https:\mp.weixin.qq.com\s\wNtpO7TtxnhoiDHuv1grXg">亿级数据过滤和布隆过滤器</a><br>3：<a href="https://mp.weixin.qq.com/s/NfFt_OMAcDrhnJ6lD2VlOA">学会布隆过滤器，能当CEO？</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bloomFilter </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
